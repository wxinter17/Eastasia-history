<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏ú‰∫öÂéÜÂè≤ÂÖ®ÊôØ (v88.01)</title>
    <!-- [Unified CSS] Native Style (Merged) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@500;700;900&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <style id="dynamic-styles"></style>

    <style>
        /* =========================================
           EastAsia History - Standard Styles (v1.0)
           Replaces Tailwind CSS with native CSS
           ========================================= */

        :root {
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --slate-950: #020617;

            --blue-300: #93c5fd;
            --blue-400: #60a5fa;
            --blue-500: #3b82f6;
            --blue-600: #2563eb;

            --amber-300: #fcd34d;
            --amber-500: #f59e0b;
        }

        /* --- Âü∫Á°ÄËÆæÁΩÆ --- */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: var(--slate-900);
            color: var(--slate-300);
            font-family: 'Inter', -apple-system, sans-serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .pano-body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
            background: var(--slate-950);
        }

        #main-content {
            position: relative;
            width: 100%;
            height: calc(100% - 3rem);
            overflow: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            z-index: 1;
            will-change: scroll-position;
        }

        #chart-container {
            position: relative;
            min-width: 1400px;
            display: block;
            contain: layout;
        }

        /* --- Sticky Â∏ÉÂ±Ä --- */
        #sticky-header-row {
            position: sticky;
            top: 0;
            z-index: 4000;
            /* [Fix] Raise above labels (which are 2000+3000) */
            display: flex;
            height: 2.5rem;
            border-bottom: 1px solid var(--slate-700);
            background-color: var(--slate-900);
        }

        #header-corner {
            position: sticky;
            left: 0;
            z-index: 4100;
            /* [Fix] Topmost corner */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
        }

        #header-body {
            flex: 1;
            display: flex;
            background-color: var(--slate-900);
            position: relative;
        }

        #chart-body-row {
            display: flex;
            position: relative;
        }

        .sticky-ticks {
            position: sticky;
            left: 0;
            z-index: 3900;
            /* [Fix] High enough but below header */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
        }

        #render-area {
            flex: 1;
            position: relative;
            background-color: var(--slate-900);
            overflow: hidden;
        }

        /* --- Crosshair (ËçßÂÖâÁ∫ø) --- */
        #crosshair-line {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 50, 50, 1);
            box-shadow: 0 0 20px rgba(255, 50, 50, 1), 0 0 40px rgba(255, 50, 50, 0.8), 0 0 6px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1000;
        }

        #crosshair-label {
            display: none;
            position: absolute;
            left: 0.5rem;
            transform: translateY(-50%);
            background: rgba(220, 50, 50, 0.95);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1001;
            font-family: monospace;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Block Styles --- */
        .era-block-fragment {
            position: absolute;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            z-index: 10;
            box-sizing: border-box;
            transition: transform 0.1s ease, opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), filter 0.4s ease;
        }

        .no-border-left {
            border-left: none !important;
        }

        .no-border-right {
            border-right: none !important;
        }

        /* [Fix] Removed conflicting internal hover styles. Rely on SHARED_CSS_STYLES from index.html */

        /* --- Focus Mode --- */
        body.mode-focus .era-block-fragment:not(.is-focused) {
            opacity: 0.08 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
            border-color: transparent !important;
        }

        body.mode-focus .era-block-fragment.is-focused {
            opacity: 1 !important;
            filter: none !important;
            /* [Fix] Do not raise Z-Index above context limit. Just rely on labels-layer being higher. */
            z-index: 50 !important;
            /* [Fix] ÁßªÈô§ÁôΩËâ≤ËæπÊ°Ü */
            box-shadow: none !important;
            transform: none;
        }

        /* --- Dots Focus Mode --- */
        body.mode-focus .era-dot:not(.is-focused) {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
        }

        body.mode-focus .era-dot.is-focused {
            opacity: 1 !important;
            filter: none !important;
            transform: scale(1.3);
            /* [Fix] ÁßªÈô§ÁôΩËâ≤ËæπÊ°Ü */
            box-shadow: none;
        }

        .era-dimmed {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none;
        }

        /* --- Labels --- */
        .era-label {
            position: absolute;
            z-index: 60;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            transform: translate(-50%, -50%);
            line-height: 1.1;
            text-shadow: -1px -1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
            transition: opacity 0.4s, filter 0.4s, transform 0.3s;
        }

        body.mode-focus .era-label:not(.is-focused) {
            opacity: 0.1 !important;
            filter: blur(1px) grayscale(50%) !important;
            z-index: 60;
        }

        /* [Fix] Label È´ò‰∫Æ */
        body.mode-focus .era-label.is-focused {
            opacity: 1 !important;
            filter: none !important;
            z-index: 9000 !important;
            /* Context ÂÜÖÁΩÆÈ°∂ */
            transform: translate(-50%, -50%) scale(1.1);
            /* [Fix] Á°Æ‰øùÊó†ÁôΩËâ≤ËæπÊ°Ü */
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        /* [Fix] Progress Bar Style Override */
        .bar-container div {
            min-width: 4px;
            /* Èò≤Ê≠¢ËøáÁ™Ñ‰∏çÂèØËßÅ */
            height: 100% !important;
            top: 0 !important;
            bottom: 0;
        }

        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 1px;
        }

        .label-wrap {
            white-space: normal !important;
            word-break: break-word;
            line-height: 1.2 !important;
        }

        .label-tier-1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-weight: 400;
            letter-spacing: 2px;
            z-index: 70;
        }

        .label-tier-2 {
            font-family: 'Noto Serif SC', serif;
            font-weight: 900;
            z-index: 65;
        }

        .label-tier-3 {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            z-index: 60;
        }

        /* --- Panel & Modals --- */
        /* Editor Panel (Replaces Tailwind classes) */
        #editor-panel {
            position: fixed;
            top: 3rem;
            bottom: 0;
            width: 100%;
            z-index: 400;
            display: flex;
            flex-direction: column;
            background-color: rgba(15, 23, 42, 0.95);
            /* slate-900/95 */
            backdrop-filter: blur(12px);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (min-width: 640px) {
            #editor-panel {
                width: 24rem;
            }
        }

        .panel-right {
            right: 0;
            border-left: 1px solid var(--slate-700);
            transform: translateX(100%);
        }

        .panel-left {
            left: 0;
            border-right: 1px solid var(--slate-700);
            transform: translateX(-100%);
        }

        .panel-open {
            transform: translateX(0) !important;
        }

        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--slate-700);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.5);
        }

        .panel-title {
            font-weight: bold;
            color: var(--blue-400);
        }

        .panel-close-btn {
            color: var(--slate-400);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border: none;
        }

        .panel-close-btn:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .jump-btn {
            display: none;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            background-color: var(--blue-600);
            color: white;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            border: 1px solid rgba(96, 165, 250, 0.5);
            cursor: pointer;
        }

        .jump-btn:hover {
            background-color: var(--blue-500);
        }

        .jump-btn.active-btn {
            display: flex;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        /* Selection Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 9999;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--slate-900);
            border: 1px solid var(--slate-700);
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 24rem;
            overflow: hidden;
        }

        .modal-header {
            padding: 0.75rem;
            border-bottom: 1px solid var(--slate-800);
            background-color: rgba(30, 41, 59, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-400);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .modal-close {
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            color: var(--slate-500);
            cursor: pointer;
            border: none;
            background: transparent;
        }

        .modal-close:hover {
            color: white;
            background-color: var(--slate-700);
        }

        /* --- JS Dynamic Elements Utilities --- */
        .header-col-label {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(51, 65, 85, 0.3);
            /* slate-700/30 */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 2px;
            font-size: 10px;
            cursor: help;
            color: var(--slate-400);
            line-height: 1.25;
            word-break: break-word;
            white-space: normal;
        }

        .header-col-label:hover,
        .header-col-label.active-header {
            color: var(--blue-400);
            background: rgba(255, 255, 255, 0.1);
            z-index: 50;
        }


        .timeline-tick-label {
            position: absolute;
            width: 100%;
            text-align: center;
            /* [Fix] Â±Ö‰∏≠ÂØπÈΩê */
            padding: 0 0.25rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            /* [Fix] Â±Ö‰∏≠ÂØπÈΩê */
            line-height: 1;
            font-size: 11px;
            /* [Fix] Â≠óÂè∑Á®çÂ§ß */
            font-weight: bold;
            /* [Fix] Âä†Á≤ó */
            color: var(--slate-400);
            /* [Fix] Á®ç‰∫Æ‰∏ÄÁÇπ */
            font-family: monospace;
            height: 0;
        }

        .suzerain-tag {
            margin-top: 0.5rem;
            font-size: 11px;
            color: var(--amber-300);
            border: 1px solid rgba(245, 158, 11, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-block;
            line-height: 1.6;
        }

        /* Modal Animation (Êõø‰ª£ Tailwind animate-in fade-in zoom-in) */
        .modal-content {
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Details Gap */
        .details-gap {
            margin-top: 1rem;
        }

        /* Detail Panel Elements */
        .regime-card {
            padding: 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .regime-card-title {
            font-size: 1.875rem;
            font-weight: 900;
            position: relative;
            z-index: 10;
            font-family: serif;
            margin: 0;
        }

        .regime-info-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0.9;
            font-size: 0.75rem;
            z-index: 10;
            position: relative;
            font-family: monospace;
        }

        .info-badge {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0 0.25rem;
            border-radius: 0.25rem;
        }

        .section-box {
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--slate-700);
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--slate-700);
            padding-bottom: 0.5rem;
        }

        .region-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 1.5rem;
            padding: 0 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            transition: background 0.2s;
            font-size: 10px;
            color: var(--slate-300);
        }

        .region-row:hover {
            background-color: rgba(51, 65, 85, 0.3);
        }

        .region-row.active-row {
            background-color: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .region-name {
            width: 5rem;
            text-align: right;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .region-name.active-name {
            color: var(--blue-300);
        }

        .bar-container {
            flex: 1;
            height: 0.5rem;
            background-color: rgba(51, 65, 85, 0.5);
            border-radius: 0.25rem;
            position: relative;
            overflow: hidden;
        }

        .time-text {
            width: 6rem;
            font-family: monospace;
            font-size: 9px;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Search Results */
        #search-results {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--slate-800);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            max-height: 300px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            width: 240px;
        }

        .search-item {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--slate-700);
            transition: background 0.15s;
            color: var(--slate-300);
            font-size: 0.75rem;
        }

        .search-item:hover {
            background: var(--slate-700);
        }
    </style>
</head>

<body class="pano-body">

    <div id="editor-panel" class="panel-right">
        <div class="panel-header">
            <h2 class="panel-title">üìú ÊîøÊùÉËØ¶ÊÉÖ</h2>

            <div style="display:flex; gap:0.5rem; align-items:center;">
                <button id="btn-jump-map-header" class="jump-btn">
                    <span>üó∫Ô∏è</span> Êü•ÁúãÂéÜÂè≤Âú∞Âõæ
                </button>
                <button id="btn-close-panel" class="panel-close-btn">‚úï</button>
            </div>
        </div>
        <div class="custom-scrollbar" id="editor-content" style="padding:1.25rem; overflow-y:auto; flex:1;"></div>
    </div>

    <div id="selection-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ËØ∑ÈÄâÊã©ÊîøÊùÉ</span>
                <button id="btn-close-modal" class="modal-close">‚úï</button>
            </div>
            <div id="selection-list" class="custom-scrollbar"
                style="padding:0.5rem; max-height:60vh; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="chart-container">
            <div id="sticky-header-row">
                <div id="header-corner">
                    <button id="btn-flip-cols" title="ÁøªËΩ¨Âú∞Âå∫Âàó"
                        style="width:100%; height:100%; border:none; background:transparent; color:var(--slate-500); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; transition:color 0.2s;">
                        ‚áÑ
                    </button>
                </div>
                <div id="header-body"></div>
            </div>
            <div id="chart-body-row">
                <div id="ticks-layer" class="sticky-ticks">
                    <div id="crosshair-label"></div>
                </div>
                <div id="render-area">
                    <div id="crosshair-line"></div>
                    <svg id="connections-layer" width="100%" height="100%"></svg>
                    <div id="blocks-layer" style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:10;">
                    </div>
                    <div id="labels-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:2000; pointer-events:none;">
                    </div>
                    <div id="grid-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:0; pointer-events:none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ‰ªéÁà∂Á∫ßËé∑ÂèñÂπ¥‰ªΩÈÖçÁΩÆÔºåÂ¶ÇÊûúÁà∂Á∫ß‰∏çÂèØÁî®Âàô‰ΩøÁî®Êú¨Âú∞ÈªòËÆ§ÂÄº
        const TIME_CONFIG = window.parent?.GLOBAL_CONFIG?.TIME || {
            minYear: -2100, // Ê≥®ÊÑè: GLOBAL_CONFIG Áî®Â§ßÂÜô key, ËøôÈáå fallback Áî®Â§ßÂÜô
            maxYear: 2025
        };

        // [New] Logger Bridge: Forward logs to parent console
        if (window.parent && window.parent.console) {
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            console.log = function (...args) {
                originalLog.apply(console, args);
                try { window.parent.console.log("[Pano]", ...args); } catch (e) { }
            };
            console.warn = function (...args) {
                originalWarn.apply(console, args);
                try { window.parent.console.warn("[Pano]", ...args); } catch (e) { }
            };
            console.error = function (...args) {
                originalError.apply(console, args);
                try { window.parent.console.error("[Pano]", ...args); } catch (e) { }
            };
            window.onerror = function (msg, source, line, col, error) {
                try { window.parent.console.error(`[Pano] Uncaught: ${msg} @ ${line}`); } catch (e) { }
            };
        }

        const APP_CONFIG = {
            minYear: TIME_CONFIG.MIN_YEAR || -2100,
            maxYear: TIME_CONFIG.MAX_YEAR || 2025
        };

        // Historical Perspectives Configuration
        const PERSPECTIVES = {
            default: {
                name: "ÈªòËÆ§Â∏ÉÂ±Ä",
                isDefault: true
            },

            songLiaoJin: {
                name: "ÂÆãËæΩÈáëÊó∂Êúü",
                coreRegimes: [
                    "ÂåóÂÆã|C5100",
                    "ÂçóÂÆã|R5110",
                    "ËæΩ|Q5700",
                    "Èáë|Q5710"
                ],
                weights: {
                    intraRegime: 100,    // Same regime regions
                    interRegime: 30,     // Different core regime regions
                    background: 0.1      // Background regions
                }
            }
        };

        // --- New Label System Modules (v2.0 Refactor) ---

        /**
         * Á©∫Èó¥Á¥¢ÂºïÁ±ª - ‰ΩøÁî® Dynamic Grid (Spatial Hash) ‰ºòÂåñÁ¢∞ÊíûÊ£ÄÊµã
         * Áõ∏ÊØî QuadTreeÔºåGrid Êõ¥ÁÆÄÂçï‰∏îÂú®Áâ©‰ΩìÂàÜÂ∏ÉÂùáÂåÄÊó∂ÊÄßËÉΩÊûÅ‰Ω≥
         */
        class SpatialIndex {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map(); // key: "x_y", value: [items]
                this.items = []; // keep track of all items
            }

            _getKey(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx}_${gy}`;
            }

            _getKeysForRect(rect) {
                const keys = [];
                const startX = Math.floor(rect.x / this.cellSize);
                const endX = Math.floor((rect.x + rect.w) / this.cellSize);
                const startY = Math.floor(rect.y / this.cellSize);
                const endY = Math.floor((rect.y + rect.h) / this.cellSize);

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        keys.push(`${x}_${y}`);
                    }
                }
                return keys;
            }

            insert(item) {
                // item must have {x, y, w, h}
                if (!item._sid) item._sid = Math.random().toString(36).substr(2, 9);

                this.items.push(item);
                const keys = this._getKeysForRect(item);
                keys.forEach(k => {
                    if (!this.grid.has(k)) this.grid.set(k, []);
                    this.grid.get(k).push(item);
                });
            }

            // ËøîÂõûÊâÄÊúâ‰∏é rect ÈáçÂè†ÁöÑ items
            query(rect) {
                const keys = this._getKeysForRect(rect);
                const candidates = new Set();

                // 1. Gather candidates
                keys.forEach(k => {
                    const cellItems = this.grid.get(k);
                    if (cellItems) {
                        for (let i = 0; i < cellItems.length; i++) {
                            candidates.add(cellItems[i]);
                        }
                    }
                });

                // 2. Precise check
                const result = [];
                candidates.forEach(item => {
                    if (this._intersects(rect, item)) {
                        result.push(item);
                    }
                });
                return result;
            }

            _intersects(a, b) {
                return a.x < b.x + b.w &&
                    a.x + a.w > b.x &&
                    a.y < b.y + b.h &&
                    a.y + a.h > b.y;
            }

            clear() {
                this.grid.clear();
                this.items = [];
            }
        }

        /**
         * LabelSystem - Ë¥üË¥£Êñ∞ÁöÑÊ†áÁ≠æÂ∏ÉÂ±ÄËÆ°ÁÆóÈÄªËæë
         */
        const LabelSystem = {
            index: null, // SpatialIndex instance

            init() {
                // ÂçïÂÖÉÊ†ºÂ§ßÂ∞èËÆæ‰∏∫ 128pxÔºåÈÄÇÂêàÂ∏∏ËßÑÊ†áÁ≠æÂ∞∫ÂØ∏
                this.index = new SpatialIndex(128);
            },

            /**
             * ‰∏∫Âçï‰∏™ÊîøÊùÉÁîüÊàêÊ†áÁ≠æÂÄôÈÄâÊñπÊ°à
             * @param {Object} group ÊîøÊùÉÁªÑ
             * @param {Object} pos Âü∫Á°Ä‰ΩçÁΩÆ‰ø°ÊÅØ {x, y, w, h, fullW, ...}
             * @param {Number} colWidth ÂàóÂÆΩ
             */
            generateCandidates(group, pos, colWidth) {
                const tier = parseInt(group.explicitTier) || 3;
                const txt = group.name;
                const len = txt.length;

                // Âü∫Á°ÄÂ∞∫ÂØ∏ÈôêÂà∂
                let minFS = 9, maxFS = 16;
                if (tier === 1) { minFS = 20; maxFS = 60; }
                else if (tier === 2) { minFS = 12; maxFS = 28; }

                // ËßÜËßâÂåÖÂõ¥Áõí (Visual Box)
                const boxW = (tier === 1 || pos.colSpan >= 2) ? pos.fullW : pos.w;
                const boxH = pos.h * Core.state.zoom; // Assume zoom access or pass in

                const candidates = [];
                const paddingFactor = 0.9;

                // ËæÖÂä©ÂáΩÊï∞: ÂàõÂª∫Â∏ÉÂ±ÄÊñπÊ°à
                const addLayout = (type, fsInput, scoreMult = 1.0) => {
                    let fs = Math.min(Math.max(fsInput, minFS), maxFS);
                    let w = 0, h = 0;

                    if (type === 'H') {
                        w = fs * len; h = fs;
                    } else if (type === 'V') {
                        w = fs; h = fs * len;
                    } else if (type === 'Wrap') {
                        let cols = Math.ceil(Math.sqrt(len));
                        if (len >= 6) cols = Math.ceil(len / 2);
                        let rows = Math.ceil(len / cols);
                        w = fs * cols; h = fs * rows * 1.1;
                    }

                    // Ê£ÄÊü•ÊòØÂê¶ËÉΩÂú®‰∏çÂÅö‰ªª‰ΩïÂÅèÁßªÁöÑÊÉÖÂÜµ‰∏ãÊîæÂÖ• box (soft constraint)
                    // const fits = w <= boxW * 1.2 && h <= boxH * 1.2;

                    candidates.push({
                        type, fs, w, h,
                        scoreMult
                    });
                };

                // 1. Horizontal (Default)
                let hFS = Math.min(boxW * paddingFactor / len, boxH * paddingFactor);
                // Tier 3 ÂøÖÈ°ªËÉΩÁúãÊ∏ÖÊâçÊúâÊÑè‰πâÔºåÂ§™Â∞èÂ∞±‰∏çÊòæÁ§∫ÊñáÂ≠ó
                if (hFS >= minFS) {
                    addLayout('H', hFS, 1.2);
                    if (hFS * 0.85 >= minFS) addLayout('H', hFS * 0.85, 1.1);
                }

                // 2. Vertical
                // ÂÅèÂ•ΩÂûÇÁõ¥ÁöÑÊù°‰ª∂ÔºöÁ™ÑÈ´òÂûãÂå∫Âüü
                const ratio = boxH / boxW;
                const preferVertical = ratio > 2.0;

                let vFS = Math.min(boxW * paddingFactor, boxH * paddingFactor / len);
                if (vFS >= minFS) {
                    addLayout('V', vFS, preferVertical ? 1.5 : 1.0);
                    if (vFS * 0.85 >= minFS) addLayout('V', vFS * 0.85, preferVertical ? 1.4 : 0.9);
                }

                // 3. Wrap (‰ªÖÂØπËæÉÈïøÊñáÊú¨)
                if (len >= 4) {
                    let cols = Math.ceil(Math.sqrt(len));
                    if (len >= 6) cols = Math.ceil(len / 2);
                    let wBase = boxW * paddingFactor / cols;
                    let hBase = boxH * paddingFactor / (Math.ceil(len / cols));
                    let wrapFS = Math.min(wBase, hBase);
                    if (wrapFS >= minFS) {
                        addLayout('Wrap', wrapFS, 0.9);
                        if (wrapFS * 0.85 >= minFS) addLayout('Wrap', wrapFS * 0.85, 0.85);
                    }
                }

                // Â¶ÇÊûúÊ≤°ÊúâÂêàÊ≥ïÁöÑÔºåÂº∫Âà∂Â°û‰∏Ä‰∏™ÊúÄÂ∞èÁöÑ H ‰æõ fallback (score Âæà‰Ωé)
                if (candidates.length === 0) {
                    candidates.push({ type: 'H', fs: minFS, w: minFS * len, h: minFS, scoreMult: 0.1 });
                }

                candidates.sort((a, b) => (b.fs * b.scoreMult) - (a.fs * a.scoreMult));
                return candidates;
            },

            /**
             * ËÆ°ÁÆóÊúÄÁªàÂ∏ÉÂ±Ä
             */
            computeAll(regimeGroups, regionIndexMap, colWidth, zoom) {
                if (!this.index) this.init();
                this.index.clear();

                const processed = [];

                // 1. Calculate ideal centers from visual slices logic
                const allItems = [];
                regimeGroups.forEach(g => {
                    const positions = Core.logic.calculateLabelPositions(g, regionIndexMap, colWidth);
                    positions.forEach(p => {
                        allItems.push({ group: g, pos: p });
                    });
                });

                // 2. Sort by Tier (1 -> 2 -> 3) then Area
                // ËøôÊ†∑È´ò‰ºòÂÖàÁ∫ßÁöÑÂÖàÂç†Âùë
                allItems.sort((a, b) => {
                    const tA = parseInt(a.group.explicitTier) || 3;
                    const tB = parseInt(b.group.explicitTier) || 3;
                    if (tA !== tB) return tA - tB; // Tier 1 < Tier 3? No, we prioritize Tier 1.
                    // Tier 1 is highest priority. So tA < tB means a comes first.
                    return b.pos.area - a.pos.area;
                });

                const results = [];

                // 3. Placement Loop
                allItems.forEach(item => {
                    const { group, pos } = item;
                    const tier = parseInt(group.explicitTier) || 3;

                    // Ëé∑ÂèñÂÄôÈÄâÂ∏ÉÂ±Ä (Â≠óÂè∑/ÊñπÂêë)
                    const layouts = this.generateCandidates(group, pos, colWidth);

                    let bestPlacement = null;
                    let bestScore = -Infinity;

                    // ÂÆö‰πâÂ∞ùËØïÁöÑ‰ΩçÁΩÆÂÅèÁßªÈáè (Áõ∏ÂØπ‰∏≠ÂøÉÁÇπ)
                    // Tier 1 Â∞ùËØïÊõ¥Â§ö‰ΩçÁΩÆ
                    let offsets = [{ x: 0, y: 0 }];

                    // ‰ªÖÂú®Â≠óÂè∑ËæÉÂ∞èÊó∂Â∞ùËØïÂæÆË∞ÉÔºåÂ§ßÂ≠óÂè∑ËøòÊòØÂ±Ö‰∏≠Â•Ω
                    const boxH = pos.h * zoom;

                    // Â¶ÇÊûúÈ´òÂ∫¶Ë∂≥Â§üÔºåÂÖÅËÆ∏‰∏ä‰∏ãÊµÆÂä®
                    if (boxH > 40 || tier <= 2) {
                        offsets.push({ x: 0, y: -boxH * 0.25 });
                        offsets.push({ x: 0, y: boxH * 0.25 });
                    }
                    if (tier >= 3) {
                        // Tier 3 È¢ùÂ§ñÂ∞ùËØï
                        offsets.push({ x: 0, y: -boxH * 0.4 });
                        offsets.push({ x: 0, y: boxH * 0.4 });
                    }

                    // ÈÅçÂéÜÊâÄÊúâ Â∏ÉÂ±Ä x ‰ΩçÁΩÆ ÁªÑÂêà
                    for (let layout of layouts) {
                        for (let off of offsets) {
                            // ËÆ°ÁÆóÁªùÂØπÂùêÊ†á
                            // pos.x/y ÊòØÁâ©ÁêÜ‰∏≠ÂøÉÁÇπ
                            const boxY = (pos.y - APP_CONFIG.minYear) * zoom;
                            const centerX = pos.x + off.x;
                            const centerY = boxY + off.y;

                            const w = layout.w;
                            const h = layout.h;

                            // Áâ©ÁêÜÁ¢∞ÊíûÁÆ± (Êî∂Áº© 15%)
                            // ËøôÊ†∑ËßÜËßâ‰∏äÊñáÂ≠óÂèØËÉΩËΩªÂæÆÊé•Ëß¶Ôºå‰ΩÜ‰∏ç‰ºöÈáçÂè†
                            const hitW = w * 0.85;
                            const hitH = h * 0.85;

                            const rect = {
                                x: centerX - hitW / 2,
                                y: centerY - hitH / 2,
                                w: hitW,
                                h: hitH
                            };

                            // Á¢∞ÊíûÊ£ÄÊµã
                            const conflicts = this.index.query(rect);

                            // ËØÑÂàÜÈÄªËæë
                            // 1. Âü∫Á°ÄÂàÜ: Â≠óÂè∑Â§ßÂ∞è * Á±ªÂûãÂÅèÂ•Ω
                            let score = layout.fs * layout.scoreMult;

                            // 2. ÂÅèÁßªÊÉ©ÁΩö (Ë∂äËøúÂàÜË∂ä‰Ωé)
                            if (off.y !== 0) score *= 0.9;

                            // 3. Á¢∞ÊíûÊÉ©ÁΩö
                            if (conflicts.length > 0) {
                                // ‰∏•ÈáçÁ¢∞ÊíûÁõ¥Êé• pass
                                // Êú™Êù•ÂèØÈÄâÔºöÂÖÅËÆ∏ Tier 1 Ë¶ÜÁõñ Tier 3 (ÈÄöËøáÊ£ÄÊü• conflicts ÂÜÖ items ÁöÑ tier)
                                continue;
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestPlacement = {
                                    layout,
                                    x: centerX,
                                    y: centerY,
                                    rect
                                };
                            }
                        }
                        // Â¶ÇÊûúÂú®ÂΩìÂâç fontsize ÊâæÂà∞‰∫ÜÊó†Á¢∞Êíû‰ΩçÁΩÆÔºåÈÄöÂ∏∏Â∞±ÊòØÊúÄ‰ºòËß£‰πã‰∏Ä
                        if (bestPlacement && bestScore > 10) break;
                    }

                    if (bestPlacement) {
                        // Ê≥®ÂÜåÁ¢∞ÊíûÁÆ±ÔºåÊê∫Â∏¶ metadata
                        bestPlacement.rect.tier = tier;
                        this.index.insert(bestPlacement.rect);
                        results.push({
                            group,
                            ...bestPlacement
                        });
                    } else {
                        // Failed to place label -> Dot fallback
                        results.push({
                            group,
                            failed: true,
                            x: pos.x,
                            y: (pos.y - APP_CONFIG.minYear) * zoom
                        });
                    }
                });

                return results;
            }
        };


        const Core = {
            state: { regions: [], regionIndexMap: {}, regimeGroups: [], zoom: 1.5, rawData: [], features: { connections: true }, focusedGroupId: null, lastClickedGeoCode: null, layoutCache: {}, intraColumnCache: {}, isFlipped: false },

            init: function () {
                // [Fix] Á¶ÅÁî®ÊµèËßàÂô®ÊªöÂä®ÊÅ¢Â§ç
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }

                // [Fix] ËÆ∞ÂΩïÂàùÂßãÂåñÊó∂Èó¥ÔºåÁî®‰∫éÊã¶Êà™ÂàùÂßãÈò∂ÊÆµÁöÑÈîôËØØÊªöÂä®Êåá‰ª§
                this._initTime = Date.now();

                // [New] Âä†ËΩΩÂ∏ÉÂ±ÄÁ≠ñÁï•ÔºöIndexedDB (‰ºòÂÖà) -> layout.json (ÈôçÁ∫ß)
                this.state.layoutData = null;

                // Á≠ñÁï• 3: ÈùôÊÄÅÊñá‰ª∂ÂÖúÂ∫ï
                const loadFromStatic = () => {
                    console.warn("üîª [Layout] Fallback to Static JSON");
                    fetch('layout.json?t=' + Date.now())
                        .then(response => response.json())
                        .then(json => applyLayout(json, 'Static'))
                        .catch(err => console.error("‚ùå Failed to load layout.json:", err));
                };

                // Á≠ñÁï• 2: LocalStorage ÈïúÂÉèÂÖúÂ∫ï
                const loadFromMirror = () => {
                    console.warn("üîª [Layout] Fallback to Mirror");
                    try {
                        const raw = localStorage.getItem('layout_mirror');
                        if (raw) {
                            const data = JSON.parse(raw);
                            applyLayout(data, 'Mirror');
                        } else {
                            loadFromStatic();
                        }
                    } catch (e) {
                        console.warn("Mirror load failed:", e);
                        loadFromStatic();
                    }
                };

                const applyLayout = (json, source) => {
                    console.log(`üìú Layout loaded from [${source}]`);
                    // Â¶ÇÊûúÊù•Ëá™ DBÔºåÈ°∫ÊâãÊõ¥Êñ∞‰∏Ä‰ªΩÂà∞ Mirror (‰Ωú‰∏∫‰∏ãÊ¨°ÁöÑÂø´ÈÄüÂÖúÂ∫ï)
                    if (source === 'IndexedDB') {
                        try {
                            localStorage.setItem('layout_mirror', JSON.stringify(json));
                            console.log("üíæ Synced to Mirror");
                        } catch (e) {
                            console.warn("‚ö†Ô∏è Mirror Sync Skipped (Quota Exceeded?)");
                        }
                    }

                    this.state.layoutData = json;
                    if (this.state.rawData && this.state.rawData.length > 0) {
                        this.updateLayout();
                    }
                };

                // Á≠ñÁï• 1: Â∞ùËØïËØªÂèñ IndexedDB (Êõ¥Êñ∞ÁâàÊú¨Âè∑Ëá≥ 3 ‰ª•ÂåπÈÖç LayoutOptimizer)
                try {
                    const req = indexedDB.open("EastAsiaHistoryDB", 4);
                    req.onerror = () => { console.warn("DB Open Failed"); loadFromMirror(); };

                    // [Fix] Ensure layouts store exists even if Panorama opens DB first
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains("layouts")) {
                            db.createObjectStore("layouts", { keyPath: "id" });
                            console.log("[DB] Created 'layouts' store during upgrade");
                        }
                    };

                    req.onsuccess = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains("layouts")) {
                            console.warn("DB Store 'layouts' missing");
                            loadFromMirror();
                            return;
                        }
                        const tx = db.transaction(["layouts"], "readonly");
                        const store = tx.objectStore("layouts");
                        const getReq = store.get("current");

                        getReq.onsuccess = () => {
                            if (getReq.result && getReq.result.data) {
                                applyLayout(getReq.result.data, 'IndexedDB');
                            } else {
                                console.warn("DB Data Empty");
                                loadFromMirror();
                            }
                        };
                        getReq.onerror = () => { console.warn("DB Get Failed"); loadFromMirror(); };
                    };
                } catch (e) {
                    console.error("DB Exception:", e);
                    loadFromMirror();
                }

                window.addEventListener('message', (e) => {
                    // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÂÆâÂÖ®ÈòÄ
                    if (!e.data || typeof e.data !== 'object') return;

                    const { type, payload = {} } = e.data;

                    // Debug
                    if (type === 'CMD_RESET') console.log("üìú ÂÖ®ÊôØÈ°µÊî∂Âà∞Â§ç‰ΩçÊåá‰ª§!");

                    // 2. ÂàùÂßãÂåñÊï∞ÊçÆ‰∏éÊ†∑ÂºèÊ≥®ÂÖ•
                    if (type === 'INIT_DATA') {
                        const { data, sharedCSS } = payload;

                        // [ÂÖ≥ÈîÆ‰øÆÂ§ç] Ê≥®ÂÖ•Áà∂Á∫ßÂèëÊù•ÁöÑ CSS (Ëß£ÂÜ≥ texture-V/J ËôöÁ∫øÂíåÁΩëÊ†º‰∏çÊòæÁ§∫ÁöÑÈóÆÈ¢ò)
                        if (sharedCSS) {
                            const styleEl = document.getElementById('dynamic-styles');
                            if (styleEl) styleEl.innerHTML = sharedCSS;
                        }

                        // Â§ÑÁêÜÊ†∏ÂøÉÊï∞ÊçÆ
                        if (data) {
                            this.processData(data);
                        } else {
                            console.warn("Panorama: INIT_DATA received but data is empty");
                        }
                    }

                    // 3. Áº©ÊîæÊéßÂà∂
                    if (type === 'CMD_ZOOM_IN') {
                        this.state.zoom = Math.min(this.state.zoom + 0.5, 10);
                        this.updateLayout(); // ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÂπ∂Ê∏≤Êüì
                    }
                    if (type === 'CMD_ZOOM_OUT') {
                        this.state.zoom = Math.max(this.state.zoom - 0.5, 0.5);
                        this.updateLayout(); // ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÂπ∂Ê∏≤Êüì
                    }

                    // 4. ÂÖ®ÊôØÂ§ç‰ΩçÈÄªËæë
                    if (type === 'CMD_RESET' || type === 'CMD_ZOOM_RESET') {
                        // Á°Æ‰øù Core Â∑≤Âä†ËΩΩ
                        if (this.resetView) {
                            this.resetView();
                        }
                    }

                    // 5. [ÂäüËÉΩ] ÂàáÊç¢ÁâπÊÄß (Â¶ÇÔºöÊòæÁ§∫/ÈöêËóèÁ∫ΩÂ∏¶ËøûÊé•)
                    if (type === 'CMD_TOGGLE_FEATURE') {
                        // payload ‰πüÊòØÂ≠óÁ¨¶‰∏≤Ôºå‰æãÂ¶Ç 'connections'
                        this.toggleFeature(payload);
                    }

                    // 6. ÊêúÁ¥¢ÁªìÊûúË∑≥ËΩ¨
                    if (type === 'CMD_SEARCH_RESULT') {
                        if (payload.target === 'panorama') {
                            this.handleJump(payload.params);
                        }
                    }

                    // 7. Áõ¥Êé•Ë∑≥ËΩ¨Êåá‰ª§
                    if (type === 'CMD_JUMP') {
                        this.handleJump(payload);
                    }

                    // 8. ÂêåÊ≠•ÊªöÂä®Êåá‰ª§ [Fix] Êã¶Êà™ÂàùÂßãÂåñÈò∂ÊÆµÁöÑÁé∞‰ª£Âπ¥‰ªΩ
                    if (type === 'CMD_SCROLL_TO_YEAR') {
                        const timeSinceInit = Date.now() - this._initTime;
                        // Â¶ÇÊûúÂú®ÂàùÂßãÂåñÂêé3ÁßíÂÜÖÔºå‰∏îÂπ¥‰ªΩ > 0ÔºàÁé∞‰ª£ÔºâÔºåÂàôÂøΩÁï•ÔºàÂº∫Âà∂‰øùÊåÅÂú®Â§èÊúùÔºâ
                        if (timeSinceInit < 3000 && payload > 0) {
                            console.log(`[Panorama] Êã¶Êà™ÂàùÂßãÊªöÂä®Êåá‰ª§Ôºö${payload}Ôºå‰øùÊåÅÂú®Â§èÊúù`);
                            return;
                        }
                        if (window.scrollToYear) window.scrollToYear(payload);
                    }
                });

                // Notify parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'CHILD_READY', payload: { source: 'panorama' } }, '*');
                }

                // Bind UI Events
                this.bindEvents();
            },

            // --- [‰øÆÂ§ç] ÂÖ®ÊôØÈ°µ‰∏ìÁî®Â§ç‰ΩçÂáΩÊï∞ (ÂÆâÂÖ®Áâà) ---
            resetView: function () {
                console.log("üîÑ [Panorama] ÊâßË°åÂÖ®ÊôØÂ§ç‰Ωç...");

                // 1. ÈáçÁΩÆÊ†∏ÂøÉÊï∞ÊçÆ
                this.state.zoom = 1.5;
                this.state.lastClickedGeoCode = null;

                // 2. [ÂÆâÂÖ®‰øÆÂ§ç] Êõ¥Êñ∞ÊªëÂùó (ÂÖàÊ£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®)
                // ‰Ω†ÁöÑ‰ª£Á†ÅÈáåÂÖ∂ÂÆûÊ≤°Êúâ id="zoom-slider"ÔºåËøô‰πãÂâçÂØºËá¥‰∫ÜÊä•Èîô
                const zSlider = document.getElementById('zoom-slider');
                if (zSlider) {
                    zSlider.value = 1.5;
                }

                // 3. Ê∏ÖÁêÜËÅöÁÑ¶Áä∂ÊÄÅ
                this.ui.clearFocus();
                this.ui.closePanel();

                // 4. [ÂÆâÂÖ®‰øÆÂ§ç] ÈöêËóèÂºπÁ™ó (ÂÖàÊ£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®)
                const selModal = document.getElementById('selection-modal');
                if (selModal) selModal.classList.add('hidden');

                const searchRes = document.getElementById('search-results');
                if (searchRes) searchRes.style.display = 'none';

                const searchInp = document.getElementById('search-input');
                if (searchInp) searchInp.value = '';

                // ÁßªÈô§È´ò‰∫ÆÁ±ª
                document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));

                // 5. Á´ãÂç≥ÈáçÁªò
                this.updateLayout();

                // 6. [ÂÆâÂÖ®‰øÆÂ§ç] ÊªöÂä®ÂΩíÈõ∂
                const main = document.getElementById('main-content');
                if (main) {
                    main.style.scrollBehavior = 'auto'; // Á¶ÅÁî®Âπ≥ÊªëÊªöÂä®Èò≤Ê≠¢ÂÜ≤Á™Å
                    main.scrollTop = 0;
                    main.scrollLeft = 0;

                    // Âª∂Êó∂ÊÅ¢Â§çÂπ≥ÊªëÊªöÂä®ÔºåÂπ∂ÂÜçÊ¨°Á°Æ‰øù main Â≠òÂú®
                    setTimeout(() => {
                        const m = document.getElementById('main-content');
                        if (m) m.style.scrollBehavior = 'smooth';
                    }, 500);
                }

                console.log("‚úÖ ÂÖ®ÊôØËßÜÂõæÂ∑≤ÊÅ¢Â§ç (Zoom: 1.5)");
            },

            bindEvents: function () {
                const safeBind = (id, event, handler) => { const el = document.getElementById(id); if (el) el.addEventListener(event, handler); };
                safeBind('btn-connections', 'click', () => this.toggleFeature('connections'));
                safeBind('btn-close-panel', 'click', () => this.ui.closePanel());
                safeBind('btn-close-modal', 'click', () => document.getElementById('selection-modal').classList.add('hidden'));
                safeBind('btn-flip-cols', 'click', () => {
                    this.state.isFlipped = !this.state.isFlipped;
                    this.updateLayout();
                    // ÂèØÈÄâÔºöÁªôÊåâÈíÆÂ¢ûÂä†ÊøÄÊ¥ªÁä∂ÊÄÅÊ†∑Âºè
                    const btn = document.getElementById('btn-flip-cols');
                    if (btn) btn.style.color = this.state.isFlipped ? 'var(--blue-400)' : 'var(--slate-500)';
                });
                safeBind('quick-nav', 'change', (e) => {
                    const y = parseInt(e.target.value);
                    if (!isNaN(y)) {
                        const targetY = (y - APP_CONFIG.minYear) * this.state.zoom;
                        document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                    }
                });

                // [UX] ÁÇπÂáªÈù¢Êùø header ‰ªªÊÑè‰ΩçÁΩÆÂÖ≥Èó≠Èù¢Êùø
                const panelHeader = document.querySelector('#editor-panel .panel-header');
                if (panelHeader) {
                    panelHeader.addEventListener('click', (e) => {
                        // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÊåâÈíÆÊàñÂÖ∂Â≠êÂÖÉÁ¥†ÔºåÂøΩÁï•
                        if (e.target.closest('button') || e.target.closest('.jump-btn')) return;
                        this.ui.closePanel();
                    });
                }

                const searchInput = document.getElementById('search-input');
                const handleSearch = (val) => {
                    const term = val.trim().toLowerCase();
                    document.querySelectorAll('.era-block-fragment').forEach(b => {
                        if (b.dataset.name) b.classList.toggle('era-dimmed', term !== "" && !b.dataset.name.toLowerCase().includes(term));
                    });
                    this.ui.populateSearchResults(term);
                };
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => handleSearch(e.target.value));
                    searchInput.addEventListener('focus', (e) => { if (e.target.value.trim().length > 0) handleSearch(e.target.value); });
                }

                const zSlide = document.getElementById('zoom-slider');
                if (zSlide) zSlide.addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    requestAnimationFrame(() => this.render.drawAll());
                });

                // Add Interaction for render area
                const renderArea = document.getElementById('render-area');
                if (renderArea) {
                    const crosshairLine = document.getElementById('crosshair-line');
                    // [‰øÆÊîπ] ÁßªÈô§Â§ñÈÉ®ÁöÑ const crosshairLabel = ...

                    renderArea.addEventListener('mousemove', function (e) {
                        const rect = renderArea.getBoundingClientRect();
                        const y = e.clientY - rect.top;

                        // 1. Crosshair Line & Label
                        if (crosshairLine) { crosshairLine.style.display = 'block'; crosshairLine.style.top = y + 'px'; }
                        const crosshairLabel = document.getElementById('crosshair-label'); // Dynamic get
                        const year = Math.floor((y / Core.state.zoom) + APP_CONFIG.minYear);
                        if (crosshairLabel) { crosshairLabel.style.display = 'block'; crosshairLabel.style.top = y + 'px'; crosshairLabel.innerText = year; }


                        // [Fix] Dynamically calculate column metrics to avoid ReferenceError
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const cols = headerBody.children;
                            const colCount = cols.length;

                            if (colCount > 0) {
                                // Get actual width of first column
                                const colW = cols[0].getBoundingClientRect().width;
                                const mouseX = e.clientX - rect.left;
                                const colIdx = Math.floor(mouseX / colW);

                                if (cols.length > colIdx && colIdx >= 0) {
                                    const old = headerBody.querySelector('.active-header');
                                    const target = cols[colIdx];
                                    if (old !== target) {
                                        if (old) old.classList.remove('active-header');
                                        if (target) target.classList.add('active-header');
                                    }
                                }
                            }
                        }
                    });

                    renderArea.addEventListener('mouseleave', function () {
                        if (crosshairLine) crosshairLine.style.display = 'none';
                        const crosshairLabel = document.getElementById('crosshair-label');
                        if (crosshairLabel) crosshairLabel.style.display = 'none';

                        // Clear header highlight
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const old = headerBody.querySelector('.active-header');
                            if (old) old.classList.remove('active-header');
                        }
                    });
                }
            },

            processData: function (rows) {
                if (!rows || rows.length === 0) {
                    console.error("Panorama received empty data");
                    return;
                }

                // 1. Âª∫Á´ã Code -> Name ÂÖ®Â±ÄÊü•ÊâæË°® (Áî®‰∫éËß£ÊûêÂÆó‰∏ªÂõΩ‰ª£Á†Å)
                const codeToNameMap = {};
                rows.forEach(r => {
                    const code = r.regime_code;
                    const name = r.regime_name || r.name;
                    if (code && name) codeToNameMap[code] = name;
                });

                const uniqueRegs = {};
                const groups = {};
                const rawList = [];

                rows.forEach((r, i) => {
                    const geoCode = r.geo_code || r.geo;
                    const geoName = r.geo_name || r.region || "Êú™Áü•";

                    if (!geoCode) return;
                    if (!uniqueRegs[geoCode]) uniqueRegs[geoCode] = geoName;

                    const regimeName = r.regime_name || r.name || "Êú™Áü•ÊîøÊùÉ";
                    // [Fix] Fallback ÈÄªËæë‰∏é LayoutOptimizer Áªü‰∏ÄÔºöÂ¶ÇÊûúÊ≤°Êúâ CodeÔºå‰ΩøÁî® Name ‰ª£ÊõøÔºåËÄå‰∏çÊòØ "C11"
                    const regimeCode = r.regime_code || regimeName;
                    // [Fix] ‰ΩøÁî® name + code ‰Ωú‰∏∫ÂîØ‰∏ÄÊ†áËØÜÔºåÈò≤Ê≠¢ÂêåÂêç‰∏çÂêåÊîøÊùÉË¢´ÈîôËØØÂêàÂπ∂
                    // ‰æãÂ¶ÇÔºöÊàòÂõΩÁß¶(R1150) Âíå Áß¶ÊúùÁß¶(C2100) ÂøÖÈ°ªÂàÜÂºÄ
                    const key = regimeName + '|' + regimeCode;

                    // ÂàùÂßãÂåñ Group
                    if (!groups[key]) {
                        groups[key] = {
                            id: key,
                            groupId: 'g-' + this.logic.simpleHash(key),
                            name: regimeName,  // ÊòæÁ§∫ÂêçÁß∞‰ªçÁÑ∂ÊòØ regimeName
                            regimeCode: regimeCode,
                            minStart: 9999, maxEnd: -9999,
                            explicitTier: parseInt(r.regime_tier || r.level || 3),
                            fragments: [],
                            visualSlices: [],
                            globalMinCol: 9999, globalMaxCol: -9999,
                            // Group Á∫ßÂà´ÁöÑÂÆó‰∏ª‰ø°ÊÅØ‰ªÖ‰ΩúÂèÇËÄÉÔºàÂèñÂá∫Áé∞ËøáÁöÑ‰ªª‰Ωï‰∏Ä‰∏™Ôºâ
                            suzerain: null
                        };
                    }

                    let start = parseInt(r.start_year || r.year_start);
                    let end = (r.end_year === 'present' || r.year_end === 'present') ? TIME_CONFIG.MAX_YEAR : parseInt(r.end_year || r.year_end);
                    if (isNaN(start)) start = TIME_CONFIG.DEFAULT_START || -200;
                    if (isNaN(end)) end = TIME_CONFIG.MAX_YEAR;

                    // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„Äë‰∏∫ÂΩìÂâçËøô‰∏ÄË°åÔºàFragmentÔºâËß£ÊûêÂÆó‰∏ªÂõΩÂêçÁß∞
                    let rawSuzCode = r.suzerain_code || r.suzerain;
                    let resolvedSuzName = null;

                    if (rawSuzCode && rawSuzCode !== 'null') {
                        if (r.suzerain_type === 'V|J' && rawSuzCode.includes('|')) {
                            // ÂèåÈáçÂÖ≥Á≥ªÔºöÂàÜÂà´ÁøªËØë
                            const parts = rawSuzCode.split('|');
                            const name1 = codeToNameMap[parts[0]] || parts[0];
                            const name2 = codeToNameMap[parts[1]] || parts[1];
                            resolvedSuzName = `${name1}|${name2}`;
                        } else {
                            // ÂçïÈáçÂÖ≥Á≥ª
                            resolvedSuzName = codeToNameMap[rawSuzCode] || rawSuzCode;
                        }
                    } else {
                        // ÊòæÂºèÊ†áËÆ∞‰∏∫Á©∫ÔºåÁ°Æ‰øùËØ¶ÊÉÖÈ°µËÉΩËØÜÂà´Âá∫"Êó†"
                        rawSuzCode = null;
                    }

                    // ÊûÑÂª∫ Fragment
                    const frag = {
                        id: i, name: key, start: start, end: end,
                        regimeCode: r.regime_code, geoCode: geoCode,
                        explicitTier: groups[key].explicitTier,

                        // Á°Æ‰øùÂ≠òÂÖ•Ëß£ÊûêÂêéÁöÑÊï∞ÊçÆ
                        suzerain: rawSuzCode,
                        suzerainName: resolvedSuzName,
                        suzerainType: r.suzerain_type,
                        desc: r.desc,
                        group: groups[key] // [Fix] Link back to group for easy access
                    };

                    groups[key].fragments.push(frag);
                    groups[key].minStart = Math.min(groups[key].minStart, start);
                    groups[key].maxEnd = Math.max(groups[key].maxEnd, end);
                    groups[key].globalMinYear = Math.min(groups[key].globalMinYear, start);
                    groups[key].globalMaxYear = Math.max(groups[key].globalMaxYear, end);

                    rawList.push(frag);
                });

                this.state.rawRegions = Object.entries(uniqueRegs).map(([k, v]) => ({ id: k, label: v }));
                this.state.regimeGroups = Object.values(groups);
                this.state.rawData = rawList;

                this.updateLayout();
            },

            updateLayout: function () {
                // [New] Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÊ£ÄÊü• (‰ªÖËøêË°å‰∏ÄÊ¨°)
                // Â¶ÇÊûúÂèëÁé∞ CSV ‰∏≠ÁöÑÊîøÊùÉÂú® Layout ÁºìÂ≠ò‰∏≠‰∏çÂ≠òÂú®ÔºåÊèêÁ§∫Áî®Êà∑Êõ¥Êñ∞
                if (this.state.layoutData && this.state.layoutData.layout && !this.state.hasCheckedConsistency) {
                    this.state.hasCheckedConsistency = true;
                    let missingCount = 0;

                    // ÊûÑÂª∫Âø´ÈÄüÊü•ÊâæË°®: region -> Set(regimeNames)
                    // ‰∏∫‰∫ÜÊÄßËÉΩÔºå‰∏çÈÅçÂéÜÊâÄÊúâÂπ¥‰ªΩÔºåÂè™Ê†πÊçÆ names Â≠óÊÆµ (Â¶ÇÊûú v8 json Êèê‰æõ‰∫Ü)
                    // v8 json root has "names" which is region map. Not regime map.
                    // We have to iterate the layout structure roughly or check rawData.

                    // ÈááÁî®ÈááÊ†∑Ê£ÄÊü•Á≠ñÁï•ÔºöÈÅçÂéÜ CSV Êï∞ÊçÆÔºåÁúãÁúãÊòØÂê¶ËÉΩÂú® Layout ‰∏≠ÊâæÂà∞ÂØπÂ∫îÁöÑ‚Äú‰ΩçÁΩÆÊßΩ‚Äù
                    // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåËØ¥ÊòéÊòØÊñ∞ÊîøÊùÉ
                    const layout = this.state.layoutData.layout;

                    for (const frag of this.state.rawData) {
                        const rid = frag.geoCode;
                        const rname = frag.group.id; // [Fix] Check ID (Name|Code) against Layout Slots
                        // Ê£ÄÊü•ËØ•Âú∞Âå∫ÊòØÂê¶ÊúâÂ∏ÉÂ±ÄÊï∞ÊçÆ
                        if (!layout[rid]) { missingCount++; break; }

                        // Ê£ÄÊü•ËØ•ÊîøÊùÉÁöÑËµ∑ÂßãÂπ¥‰ªΩÊòØÂê¶Êúâ‰ΩçÁΩÆ
                        // (Âè™Êü•Ëµ∑ÂßãÂπ¥ÔºåÂÅáËÆæÂ¶ÇÊûúËµ∑ÂßãÂπ¥ÊúâÔºåÂêéÈù¢ÈÉΩÊúâÔºõÂ¶ÇÊûúËµ∑ÂßãÂπ¥Ê≤°ÊúâÔºåÂ∞±ÊòØÊñ∞ÁöÑ)
                        const yKey = String(Math.max(frag.start, APP_CONFIG.minYear));
                        const slots = layout[rid][yKey];

                        if (!slots || !slots.includes(rname)) {
                            // double check with a few years later to avoid edge case
                            missingCount++;
                            // Âè™Ë¶ÅÂèëÁé∞‰∏Ä‰∏™Á°ÆÂÆöÁöÑÁº∫Â§±ÔºåÂ∞±‰∏≠Êñ≠Ê£ÄÊü•ÔºåÈÅøÂÖçÂºπÁ™óÂ§öÊ¨°ÊàñÊÄßËÉΩÊçüËÄó
                            break;
                        }
                    }

                    if (missingCount > 0) {
                        // Âª∂Êó∂ÂºπÂá∫Ôºå‰ª•ÂÖçÈòªÊñ≠È¶ñÂ±èÊ∏≤Êüì
                        setTimeout(() => {
                            if (confirm("‚ö†Ô∏è Êï∞ÊçÆÊõ¥Êñ∞ÊèêÁ§∫\n\nÊ£ÄÊµãÂà∞ CSV ‰∏≠Â≠òÂú®Êñ∞ÊîøÊùÉÔºå‰ΩÜÂΩìÂâçÂ∏ÉÂ±ÄÁºìÂ≠ò‰∏≠Êú™ÂåÖÂê´ÂÖ∂‰ΩçÁΩÆ‰ø°ÊÅØ„ÄÇ\nËøôÂèØËÉΩÂØºËá¥ÊòæÁ§∫Èîô‰π±„ÄÇ\n\nÊòØÂê¶Á´ãÂç≥Ë∑≥ËΩ¨Âà∞‰ºòÂåñÂô®ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÔºü")) {
                                window.open('LayoutOptimizer.html?autorun=true', '_blank');
                            }
                        }, 1000);
                    }
                }

                this.state.regions = this.logic.applyFixedLayout(this.state.rawRegions);
                this.state.regionIndexMap = this.state.regions.reduce((acc, r, i) => { acc[r.id] = i; return acc; }, {});

                this.logic.calculateGroupCenters(this.state.regimeGroups, this.state.regionIndexMap);
                this.render.drawAll();

                // [Fix] ÂàùÂßãÂä†ËΩΩÊó∂ÊªöÂä®Âà∞È°∂ÈÉ®ÔºàÊúÄÊó©Êó∂Èó¥Ôºâ
                if (!this.state.hasInitialScrolled) {
                    this.state.hasInitialScrolled = true;
                    // ‰ΩøÁî®ËæÉÈïøÁöÑ setTimeout Á°Æ‰øùË¶ÜÁõñÂÖ∂‰ªñÊªöÂä®ÂëΩ‰ª§
                    setTimeout(() => {
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.scrollTop = 0;
                            mainContent.scrollLeft = 0;
                        }
                    }, 500);
                }
            },

            getStyle: function (group, frag) {
                const regimeCode = group.regimeCode;
                const name = group.name;
                const suzerainCode = (frag && frag.suzerain) ? frag.suzerain : group.suzerain;
                const suzerainType = (frag && frag.suzerainType) ? frag.suzerainType : group.suzerainType;

                if (window.parent && window.parent.GlobalUtils) {
                    try {
                        return window.parent.GlobalUtils.getStyle(regimeCode, name, suzerainCode, suzerainType);
                    } catch (e) {
                        console.warn("Call parent GlobalUtils.getStyle failed", e);
                    }
                }
                return { bg: '#666', border: '#444', className: 'texture-N', isDashed: false };
            },

            handleJump: function (payload) {
                if (payload.year) {
                    const targetY = (parseInt(payload.year) - APP_CONFIG.minYear) * this.state.zoom;
                    document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                }
                if (payload.regime) {
                    const target = this.state.regimeGroups.find(g => g.name.includes(payload.regime));
                    if (target) setTimeout(() => this.ui.jumpToRegime(target), 300);
                }
            },

            logic: {
                // [New] Perspective-Based Layout Optimization

                // Extract core regions from perspective configuration
                extractCoreRegions: function (perspective) {
                    const coreRegions = new Set();

                    Core.state.regimeGroups.forEach(group => {
                        if (perspective.coreRegimes.includes(group.id)) {
                            group.fragments.forEach(frag => {
                                coreRegions.add(frag.geoCode);
                            });
                        }
                    });

                    console.log(`[${perspective.name}] Ê†∏ÂøÉÂå∫Âüü: ${coreRegions.size} Âàó`, Array.from(coreRegions));
                    return coreRegions;
                },

                // Check if two regions belong to the same core regime
                belongToSameRegime: function (regionA, regionB, coreRegimes) {
                    for (let regimeId of coreRegimes) {
                        const group = Core.state.regimeGroups.find(g => g.id === regimeId);
                        if (!group) continue;

                        const regionsInRegime = new Set(group.fragments.map(f => f.geoCode));
                        if (regionsInRegime.has(regionA) && regionsInRegime.has(regionB)) {
                            return true;
                        }
                    }
                    return false;
                },

                // Build weighted affinity matrix for perspective
                buildWeightedMatrix: function (perspective, baseMatrix) {
                    if (perspective.isDefault) {
                        // Default perspective: use base matrix as-is
                        return baseMatrix;
                    }

                    const coreRegions = this.extractCoreRegions(perspective);
                    const n = Core.state.rawRegions.length;
                    const matrix = Array(n).fill(0).map((_, i) => baseMatrix[i].slice());

                    // Apply weights
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const rA = Core.state.rawRegions[i].id;
                            const rB = Core.state.rawRegions[j].id;

                            const bothCore = coreRegions.has(rA) && coreRegions.has(rB);
                            const bothBg = !coreRegions.has(rA) && !coreRegions.has(rB);

                            if (bothCore) {
                                const sameRegime = this.belongToSameRegime(rA, rB, perspective.coreRegimes);
                                matrix[i][j] *= sameRegime
                                    ? perspective.weights.intraRegime
                                    : perspective.weights.interRegime;
                            } else if (bothBg) {
                                matrix[i][j] *= perspective.weights.background;
                            } else {
                                matrix[i][j] *= perspective.weights.background;
                            }
                        }
                    }

                    return matrix;
                },

                getRegimeTier: function (t) { return parseInt(t) || 3; },
                simpleHash: function (str) { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); },

                calculateGroupCenters: function (groups, regionIndexMap) {
                    groups.forEach(g => {
                        let totalCol = 0, count = 0;
                        g.fragments.forEach(f => {
                            const idx = regionIndexMap[f.geoCode];
                            if (idx !== undefined) {
                                totalCol += idx; count++;
                                g.globalMinCol = Math.min(g.globalMinCol, idx);
                                g.globalMaxCol = Math.max(g.globalMaxCol, idx);
                            }
                        });
                        g.centerCol = count > 0 ? (totalCol / count) : 0;
                        g.globalDuration = g.globalMaxYear - g.globalMinYear;
                    });
                },

                applyFixedLayout: function (rawRegions) {
                    let sorted = [];
                    if (Core.state.layoutData && Core.state.layoutData.colOrder) {
                        const orderMap = {};
                        Core.state.layoutData.colOrder.forEach((id, i) => orderMap[id] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = orderMap[a.id] !== undefined ? orderMap[a.id] : 9999;
                            const rB = orderMap[b.id] !== undefined ? orderMap[b.id] : 9999;
                            return rA - rB;
                        });
                    } else {
                        // Fallback (Original fixed order)
                        const FIXED_ORDER = ['550', '530', '520', '510', '540', '440', '410', '420', '430', '330', '350', '340', '260', '270', '310', '250', '240', '320', '220', '210', '230', '190', '150', '130', '140', '160', '120', '110', '180', '170', '610', '620', '740', '730', '720', '710', '820', '810', '840', '830', '850', '910', '920', '930', '940', '950', '960'];
                        const rankMap = {}; FIXED_ORDER.forEach((c, i) => rankMap[c] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = rankMap[a.id] !== undefined ? rankMap[a.id] : 9999;
                            const rB = rankMap[b.id] !== undefined ? rankMap[b.id] : 9999;
                            return rA - rB;
                        });
                    }

                    if (Core.state.isFlipped) {
                        sorted.reverse();
                    }
                    return sorted;
                },

                sliceFragmentsByRegion: function (fragments, colIdx, allGroups, regionIndexMap, layoutCache) {
                    if (!fragments || fragments.length === 0) return [];
                    const slices = [];

                    // 1. Ëé∑ÂèñÂΩìÂâçÂàóÂØπÂ∫îÁöÑ Region ID
                    // fragments ‰∏≠ÁöÑ geoCode Â∫îËØ•ÈÉΩÊòØÂêå‰∏Ä‰∏™Ôºå‰ΩÜ‰∏∫‰∫Ü‰øùÈô©Âéª Core.state.regions Êü•
                    const regionObj = Core.state.regions[colIdx];
                    if (!regionObj) return [];
                    const regionId = regionObj.id;

                    // 2. Ê£ÄÊü•ÊòØÂê¶ÊúâÈ¢ÑËÆ°ÁÆóÁöÑ layout Êï∞ÊçÆ
                    const hasLayout = Core.state.layoutData && Core.state.layoutData.layout && Core.state.layoutData.layout[regionId];
                    const layoutMap = hasLayout ? Core.state.layoutData.layout[regionId] : null;

                    // Â¶ÇÊûúÊ≤°ÊúâÂ∏ÉÂ±ÄÊï∞ÊçÆÔºåÁõ¥Êé•ËøîÂõûÂÖ®ÂÆΩ (Fallback)
                    if (!layoutMap) {
                        fragments.forEach(f => {
                            const newFrag = Object.assign({}, f);
                            newFrag.displayStart = f.start;
                            newFrag.displayEnd = f.end;
                            newFrag.leftPct = 0;
                            newFrag.widthPct = 100;
                            newFrag.group.visualSlices.push({
                                cIdx: colIdx,
                                start: f.start, end: f.end,
                                left: 0, w: 1, dur: f.end - f.start
                            });
                            slices.push(newFrag);
                        });
                        return slices;
                    }

                    // 3. Âü∫‰∫é layout.json ÂàáÂâ≤Êó∂ÊÆµ
                    fragments.forEach(frag => {
                        const regimeName = frag.group.name;
                        const regimeCode = frag.group.regimeCode || regimeName; // [Fix] Ëé∑Âèñ Code

                        // [Fix] ÊûÑÈÄ†ÁõÆÊ†á IDÔºåÂøÖÈ°ªÂåπÈÖç LayoutOptimizer ÁöÑ 'Name|Code' Ê†ºÂºè
                        const targetID = regimeName + "|" + regimeCode;

                        const start = Math.max(frag.start, APP_CONFIG.minYear);
                        const end = Math.min(frag.end, APP_CONFIG.maxYear);
                        if (start >= end) return;

                        let currStart = start;
                        let currLeft = -1;
                        let currWidth = -1;

                        for (let y = start; y < end; y++) {
                            const yearKey = String(y);
                            const slots = layoutMap[yearKey] || [];

                            // [Fix] Êü•ÊâæÈÄªËæëÂçáÁ∫ßÔºö‰ºòÂÖàÊü•Êñ∞IDÔºåÊü•‰∏çÂà∞ÂÜçÊü•ÊóßID(ÂÖºÂÆπ)
                            let slotIdx = slots.indexOf(targetID);
                            if (slotIdx === -1) slotIdx = slots.indexOf(regimeName);
                            let totalSlots = slots.length;

                            let left = 0, width = 100;

                            if (slotIdx !== -1 && totalSlots > 0) {
                                width = 100 / totalSlots;
                                if (Core.state.isFlipped) {
                                    left = (totalSlots - 1 - slotIdx) * width;
                                } else {
                                    left = slotIdx * width;
                                }
                            } else {
                                // Â¶ÇÊûú layout ÈáåÊ≤°ÊâæÂà∞ËØ•ÊîøÊùÉ (ÂèØËÉΩÊòØÊï∞ÊçÆ‰∏ç‰∏ÄËá¥)Ôºå
                                // Á≠ñÁï• A: ÈöêËóè (width=0)
                                // Á≠ñÁï• B: ÂÖ®ÂÆΩÊòæÁ§∫ (width=100) Âπ∂ÁΩÆÈ°∂
                                // ËøôÈáåÈááÁî®Á≠ñÁï• B ‰ª•ÂÖçÊîøÊùÉÊ∂àÂ§±
                                width = 100; left = 0;
                            }

                            // Áä∂ÊÄÅÂèòÊõ¥Ê£ÄÊµã
                            // [Fix] ‰ΩøÁî® epsilon ÊØîËæÉÊµÆÁÇπÊï∞
                            const isChanged = Math.abs(left - currLeft) > 0.01 || Math.abs(width - currWidth) > 0.01;

                            if (currLeft !== -1 && isChanged) {
                                // ÁªìÊùü‰∏ä‰∏ÄÊÆµ
                                pushSlice(slices, frag, currStart, y, currLeft, currWidth, colIdx);
                                currStart = y;
                            }

                            if (currLeft === -1 || isChanged) {
                                currLeft = left;
                                currWidth = width;
                            }
                        }

                        // ÁªìÊùüÊúÄÂêé‰∏ÄÊÆµ
                        if (currLeft !== -1) {
                            pushSlice(slices, frag, currStart, end, currLeft, currWidth, colIdx);
                        }
                    });

                    function pushSlice(outArr, originalFrag, s, e, l, w, cIdx) {
                        if (s >= e) return;
                        const newFrag = Object.assign({}, originalFrag);
                        newFrag.displayStart = s;
                        newFrag.displayEnd = e;
                        newFrag.leftPct = l;
                        newFrag.widthPct = w;

                        // Êõ¥Êñ∞ Group ÁªüËÆ°‰ø°ÊÅØ
                        newFrag.group.visualSlices.push({
                            cIdx: cIdx,
                            start: s, end: e,
                            left: l / 100, w: w / 100,
                            dur: e - s
                        });

                        outArr.push(newFrag);
                    }

                    return slices;
                },

                calculateLabelPositions: function (group, regionIndexMap, colWidth) {
                    const frags = group.visualSlices;
                    if (!frags || frags.length === 0) return [];

                    frags.sort((a, b) => a.cIdx - b.cIdx || a.start - b.start);

                    const clusters = [];
                    const processed = new Set();

                    frags.forEach((f, i) => {
                        if (processed.has(i)) return;
                        const currentCluster = [f];
                        processed.add(i);

                        let queue = [f];
                        while (queue.length > 0) {
                            let curr = queue.shift();
                            for (let j = 0; j < frags.length; j++) {
                                if (processed.has(j)) continue;
                                const cand = frags[j];
                                const sameCol = (cand.cIdx === curr.cIdx);
                                const timeTouch = (cand.start <= curr.end + 5) && (cand.end >= curr.start - 5);
                                const neighborCol = Math.abs(cand.cIdx - curr.cIdx) === 1;
                                const timeOverlap = (cand.start < curr.end) && (cand.end > curr.start);

                                if ((sameCol && timeTouch) || (neighborCol && timeOverlap)) {
                                    currentCluster.push(cand);
                                    processed.add(j);
                                    queue.push(cand);
                                }
                            }
                        }
                        clusters.push(currentCluster);
                    });

                    const results = clusters.map(cluster => {
                        let totalArea = 0;
                        let weightedX = 0;
                        let weightedY = 0;
                        let minTime = 9999, maxTime = -9999;
                        let minC = 9999, maxC = -9999;

                        let maxSliceArea = -1;
                        let bestSlice = null;

                        cluster.forEach(f => {
                            const h = f.dur;
                            const wPct = f.w;
                            const area = h * wPct;

                            const physCenterX = (f.cIdx + f.left + (f.w / 2)) * colWidth;
                            const physCenterY = (f.start + f.end) / 2;

                            weightedX += physCenterX * area;
                            weightedY += physCenterY * area;
                            totalArea += area;

                            minTime = Math.min(minTime, f.start);
                            maxTime = Math.max(maxTime, f.end);
                            minC = Math.min(minC, f.cIdx);
                            maxC = Math.max(maxC, f.cIdx);

                            if (area > maxSliceArea) {
                                maxSliceArea = area;
                                bestSlice = { x: physCenterX, y: physCenterY, w: f.w * colWidth, h: h };
                            }
                        });

                        if (totalArea === 0) return null;

                        const finalX = weightedX / totalArea;
                        const finalY = weightedY / totalArea;
                        const fullHeight = maxTime - minTime;
                        const effectiveWidthPx = (totalArea / Math.max(fullHeight, 1)) * colWidth;
                        const boundingWidthPx = (maxC - minC + 1) * colWidth;
                        const colSpan = maxC - minC + 1;

                        return {
                            x: finalX,
                            y: finalY,
                            bestSlice: bestSlice,
                            w: effectiveWidthPx,
                            fullW: boundingWidthPx,
                            colSpan: colSpan,
                            h: fullHeight,
                            area: totalArea
                        };
                    }).filter(r => r !== null);

                    if (group.explicitTier == 1) {
                        results.sort((a, b) => b.area - a.area);
                        return [results[0]];
                    }

                    return results.filter(r => r.area > 5);
                }
            },

            render: {
                drawAll: function () {
                    // ÊÅ¢Â§ç‰∏•Ê†ºÁ¢∞ÊíûÊ£ÄÊµãÔºå‰∏ç‰ΩøÁî® Monkey Patch
                    collisionMgr.reset();

                    Core.state.regimeGroups.forEach(g => g.visualSlices = []);

                    let container = document.getElementById('chart-container');
                    if (!container) return;

                    let headerBody = document.getElementById('header-body');
                    let ticksLayer = document.getElementById('ticks-layer');
                    let renderArea = document.getElementById('render-area');

                    headerBody.innerHTML = '';
                    ticksLayer.innerHTML = '<div id="crosshair-label"></div>';
                    document.getElementById('blocks-layer').innerHTML = '';
                    document.getElementById('labels-layer').innerHTML = '';
                    document.getElementById('connections-layer').innerHTML = '';

                    if (!Core.state.regions || Core.state.regions.length === 0) return;

                    let totalHeight = (APP_CONFIG.maxYear - APP_CONFIG.minYear) * Core.state.zoom + 100;
                    let colCount = Core.state.regions.length;

                    ticksLayer.style.height = totalHeight + 'px';
                    renderArea.style.height = totalHeight + 'px';

                    Core.state.regions.forEach((r, i) => {
                        let el = document.createElement('div');
                        el.className = 'header-col-label';
                        el.style.left = (i / colCount) * 100 + '%'; el.style.width = (1 / colCount) * 100 + '%'; el.innerText = r.label;
                        headerBody.appendChild(el);
                    });

                    let tickFrag = document.createDocumentFragment();
                    for (let y = APP_CONFIG.minYear; y <= APP_CONFIG.maxYear; y += 100) {
                        let top = (y - APP_CONFIG.minYear) * Core.state.zoom;
                        if (top < 0) continue;
                        let el = document.createElement('div'); el.className = 'timeline-tick-label';
                        el.style.top = top + 'px'; el.innerText = y; tickFrag.appendChild(el);
                    }
                    ticksLayer.appendChild(tickFrag);

                    Core.render.setupInteractions(renderArea, colCount);

                    let fragsByRegion = {};
                    Core.state.regimeGroups.forEach(group => {
                        let style = Core.getStyle(group);
                        let groupId = group.groupId;
                        group.fragments.forEach(f => {
                            if (!fragsByRegion[f.geoCode]) fragsByRegion[f.geoCode] = [];
                            let fragStyle = style;
                            if (f.suzerain) fragStyle = Core.getStyle(group, f);
                            fragsByRegion[f.geoCode].push(Object.assign({}, f, { style: fragStyle, groupName: group.name, groupId: groupId, group: group }));
                        });
                    });

                    let allRenderSlices = [];
                    Core.state.regions.forEach((region, colIdx) => {
                        let fragments = fragsByRegion[region.id];
                        if (fragments) {
                            let slices = Core.logic.sliceFragmentsByRegion(fragments, colIdx, Core.state.regimeGroups, Core.state.regionIndexMap, Core.state.layoutCache);
                            slices.forEach(s => { s.colIdx = colIdx; allRenderSlices.push(s); });
                        }
                    });

                    allRenderSlices.sort((a, b) => {
                        if (a.groupId !== b.groupId) return a.groupId.localeCompare(b.groupId);
                        if (Math.abs(a.displayStart - b.displayStart) > 0.1) return a.displayStart - b.displayStart;
                        return a.colIdx - b.colIdx;
                    });

                    let mergedSlices = [];
                    if (allRenderSlices.length > 0) {
                        let currentMerge = allRenderSlices[0];
                        currentMerge.colspan = 1;
                        currentMerge.startCol = currentMerge.colIdx;
                        // [Fix] Á¥ØÂä†ÂÆûÈôÖÂÆΩÂ∫¶Ôºà‰ª•"ÂàóÂÆΩÁôæÂàÜÊØîÂçï‰Ωç"ËÆ°ÁÆóÔºâ
                        // ‰æãÂ¶ÇÔºö100% ÂÆΩÂ∫¶ = 1.0 ‰∏™ÂàóÂÆΩÂçï‰ΩçÔºå50% ÂÆΩÂ∫¶ = 0.5 ‰∏™ÂàóÂÆΩÂçï‰Ωç
                        currentMerge.totalWidthUnits = currentMerge.widthPct / 100;

                        for (let i = 1; i < allRenderSlices.length; i++) {
                            let next = allRenderSlices[i];
                            let prev = currentMerge;

                            // [Fix] ÂêàÂπ∂Êù°‰ª∂Ôºö
                            // 1. ÂêåÊîøÊùÉ„ÄÅÁõ∏ÈÇªÂàó„ÄÅÊó∂Èó¥ÂØπÈΩê
                            // 2. ËæπÁºòÂØπÈΩêÔºöprev ÂøÖÈ°ªÂç†Êª°Âè≥ËæπÁºòÔºånext ÂøÖÈ°ª‰ªéÂ∑¶ËæπÁºòÂºÄÂßã
                            // 3. [NEW] ‰∏çËÉΩÊòØÁã¨Âç†Êï¥ÂàóÁöÑÊÉÖÂÜµÔºàÁã¨Âç†ÊîøÊùÉÂèØËÉΩÂè™ÊòØÁ¢∞Â∑ßÂêåÂêçÔºå‰∏çÂ∫îÂêàÂπ∂Ôºâ
                            let basicMatch = next.groupId === prev.groupId &&
                                next.colIdx === (prev.startCol + prev.colspan) &&
                                Math.abs(next.displayStart - prev.displayStart) < 0.1 &&
                                Math.abs(next.displayEnd - prev.displayEnd) < 0.1;

                            // prev ÂøÖÈ°ªÂç†ÊçÆËØ•ÂàóÁöÑÊúÄÂè≥‰æßÔºàÁã¨Âç†ÊàñÂè≥ËæπÁºòÂØπÈΩêÔºâ
                            let prevRightEdge = (prev.leftPct + prev.widthPct) >= 95;
                            // next ÂøÖÈ°ª‰ªéÂ∑¶ËæπÁºòÂºÄÂßã
                            let nextLeftEdge = next.leftPct <= 5;

                            // [Fix] Á¶ÅÊ≠¢ÂêàÂπ∂Áã¨Âç†Êï¥ÂàóÁöÑÊÉÖÂÜµ
                            // Â¶ÇÊûúprevÊàñnextÁã¨Âç†Êï¥ÂàóÔºàwidthPct >= 95ÔºâÔºå‰∏çÂêàÂπ∂
                            let prevIsFullWidth = prev.widthPct >= 95;
                            let nextIsFullWidth = next.widthPct >= 95;
                            let canMerge = !prevIsFullWidth && !nextIsFullWidth;

                            let isSame = basicMatch && prevRightEdge && nextLeftEdge && canMerge;
                            if (isSame) {
                                currentMerge.colspan++;
                                // [Fix] Á¥ØÂä† next ÁöÑÂÆûÈôÖÂÆΩÂ∫¶
                                currentMerge.totalWidthUnits += next.widthPct / 100;
                            }
                            else {
                                mergedSlices.push(currentMerge);
                                currentMerge = next;
                                currentMerge.colspan = 1;
                                currentMerge.startCol = currentMerge.colIdx;
                                currentMerge.totalWidthUnits = currentMerge.widthPct / 100;
                            }
                        }
                        mergedSlices.push(currentMerge);
                    }

                    let blocksFrag = document.createDocumentFragment();
                    mergedSlices.forEach(slice => {
                        let top = (slice.displayStart - APP_CONFIG.minYear) * Core.state.zoom;
                        let h = Math.max((slice.displayEnd - slice.displayStart) * Core.state.zoom, 1);
                        let el = document.createElement('div');

                        el.className = 'era-block-fragment ' + slice.style.className + ' ' + slice.groupId;
                        el.style.backgroundColor = slice.style.bg;
                        if (slice.style.pattern) el.style.setProperty('--pat-color', slice.style.pattern);

                        if (slice.style.className.includes('texture-V') || slice.style.className.includes('texture-VJ')) {
                            el.style.borderStyle = 'dashed'; el.style.borderColor = slice.style.border; el.style.borderWidth = '2px';
                            el.style.zIndex = parseInt(el.style.zIndex || 10) + 1;
                        } else {
                            el.style.border = '1px solid rgba(0,0,0,0.1)';
                        }

                        let isLeft = slice.startCol === 0;
                        let isRight = (slice.startCol + slice.colspan) === colCount;
                        let checkNeighbor = (c) => allRenderSlices.some(o => o.colIdx === c && o.groupId === slice.groupId && Math.max(slice.displayStart, o.displayStart) < Math.min(slice.displayEnd, o.displayEnd));
                        let hasL = checkNeighbor(slice.startCol - 1);
                        let hasR = checkNeighbor(slice.startCol + slice.colspan);

                        if (hasL || (slice.colspan > 1 && !isLeft)) el.classList.add('no-border-left');
                        if (hasR || (slice.colspan > 1 && !isRight)) el.classList.add('no-border-right');

                        let colWidthPct = 100 / colCount;
                        // [Fix] ‰ΩøÁî®Á¥ØÂä†ÁöÑÂÆûÈôÖÂÆΩÂ∫¶ÔºåËÄåÈùû colspan * widthPct
                        let totalWidthPct = slice.totalWidthUnits * colWidthPct;
                        let totalLeftPct = (slice.startCol * colWidthPct) + ((slice.leftPct / 100) * colWidthPct);

                        el.style.left = totalLeftPct + '%';

                        if ((hasL || hasR || slice.colspan > 1) && slice.widthPct >= 95) {
                            el.style.width = `calc(${totalWidthPct}% + 1px)`;
                            if (hasL || (!isLeft && slice.colspan > 1)) el.style.marginLeft = '-1px';
                        } else {
                            el.style.width = totalWidthPct + '%';
                        }

                        el.style.top = top + 'px'; el.style.height = h + 'px';
                        // [Fix] ÊâÄÊúâËâ≤Âùó‰ΩøÁî®Áªü‰∏ÄÁöÑ z-indexÔºå‰∏ç‰ºö‰∫íÁõ∏Ë¶ÜÁõñ
                        el.style.zIndex = 10;
                        el.__data__ = { group: slice.group, style: slice.style, fragment: slice };

                        el.onmouseenter = () => {
                            if (!Core.state.focusedGroupId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.add('group-hovered'));
                                if (Core.state.features.connections) Core.render.drawConnections(slice.group, '#fff');
                                // [New] Highlight Header based on this block's region
                                if (slice.geoCode) Core.ui.highlightHeader(slice.geoCode);
                            }
                        };
                        el.onmouseleave = () => {
                            if (!Core.state.focusedGroupId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.remove('group-hovered'));
                                document.getElementById('connections-layer').innerHTML = '';
                                // [New] Clear Header Highlight
                                Core.ui.clearHeaderHighlight();
                            }
                        };

                        blocksFrag.appendChild(el);
                    });
                    document.getElementById('blocks-layer').appendChild(blocksFrag);

                    Core.render.drawLabels(colCount);
                },

                setupInteractions: function (renderArea, colCount) {
                    renderArea.onclick = (e) => {
                        if (e.target.closest('#selection-modal')) return;
                        let clickedBlock = e.target.closest('.era-block-fragment');
                        if (clickedBlock && clickedBlock.__data__) {
                            e.stopPropagation();
                            let d = clickedBlock.__data__;
                            Core.state.lastClickedGeoCode = d.fragment.geoCode;
                            Core.ui.setFocus(d.group.groupId);
                            Core.ui.showDetails(d.group, d.style);
                            return;
                        }
                        if (!e.target.closest('.era-label')) Core.ui.clearFocus();
                    };
                },

                // --- ÈáçÊûÑÁâà v2.0Ôºö‰ΩøÁî® LabelSystem ËøõË°åÊ∏≤Êüì ---
                drawLabels: function (colCount) {
                    let labelsFrag = document.createDocumentFragment();
                    let renderArea = document.getElementById('render-area');

                    // 1. Ê∏ÖÁêÜÊóßÊ†áÁ≠æ
                    if (renderArea) {
                        const oldItems = renderArea.querySelectorAll('.era-label, .era-dot');
                        oldItems.forEach(el => el.remove());
                    }

                    let colWidthPx = renderArea.scrollWidth / colCount;
                    if (!colWidthPx || colWidthPx < 10) colWidthPx = 100;

                    // 2. Ë∞ÉÁî® LabelSystem ËÆ°ÁÆóÊâÄÊúâ‰ΩçÁΩÆ
                    const results = LabelSystem.computeAll(
                        Core.state.regimeGroups,
                        Core.state.regionIndexMap,
                        colWidthPx,
                        Core.state.zoom
                    );

                    // 3. Ê∏≤ÊüìÁªìÊûú
                    results.forEach(item => {
                        const { group, x, y } = item;

                        // A. ÊàêÂäüÊîæÁΩÆÊñáÂ≠óÊ†áÁ≠æ
                        if (!item.failed) {
                            const { layout } = item;
                            const tier = parseInt(group.explicitTier) || 3;

                            let label = document.createElement('div');
                            let layoutClass = '';
                            if (layout.type === 'V') layoutClass = 'vertical-text';
                            if (layout.type === 'Wrap') layoutClass = 'label-wrap';

                            label.className = `era-label label-tier-${tier} ${group.groupId} ${layoutClass}`;
                            label.innerText = group.name;

                            // Â±Ö‰∏≠ÂÆö‰Ωç
                            label.style.left = x + 'px';
                            label.style.top = y + 'px';

                            // ÂÆΩÂ∫¶Â§ÑÁêÜ (Wrap ÈúÄË¶ÅÂõ∫ÂÆöÂÆΩÔºåH/V Ëá™Âä®)
                            const finalW = (layout.type === 'Wrap') ? layout.w : 'auto';
                            label.style.width = (typeof finalW === 'number') ? (finalW + 'px') : finalW;

                            label.style.fontSize = layout.fs + 'px';
                            label.style.lineHeight = '1'; // Á¥ßÂáëË°åÈ´ò

                            if (layout.type === 'H') label.style.whiteSpace = 'nowrap';
                            if (Core.state.focusedGroupId === group.groupId) label.classList.add('is-focused');

                            labelsFrag.appendChild(label);
                        }
                        // B. ÊîæÁΩÆÂ§±Ë¥• -> ÈôçÁ∫ß‰∏∫Â∞èÂúÜÁÇπ
                        else {
                            let dotSize = 4;
                            // Â¶ÇÊûúÊòØ Tier 1/2 Â§±Ë¥•ÔºåÂúÜÁÇπÁ®çÂæÆÂ§ß‰∏ÄÁÇπ
                            const tier = parseInt(group.explicitTier) || 3;
                            if (tier <= 2) dotSize = 6;

                            let dot = document.createElement('div');
                            dot.className = `era-dot ${group.groupId}`;
                            dot.style.cssText = `
                                position: absolute;
                                border-radius: 50%;
                                background: rgba(255,255,255,0.4);
                                cursor: help;
                                z-index: 3000;
                                transition: all 0.2s;
                                pointer-events: auto;
                            `;
                            dot.style.left = (x - dotSize / 2) + 'px';
                            dot.style.top = (y - dotSize / 2) + 'px';
                            dot.style.width = dotSize + 'px';
                            dot.style.height = dotSize + 'px';
                            dot.title = group.name; // Èº†Ê†áÊÇ¨ÂÅúÊòæÁ§∫ÂêçÂ≠ó

                            dot.onmouseenter = () => {
                                dot.style.background = 'white';
                                dot.style.transform = 'scale(1.5)';
                                dot.style.boxShadow = '0 0 5px rgba(255,255,255,0.8)';
                            };
                            dot.onmouseleave = () => {
                                dot.style.background = 'rgba(255,255,255,0.4)';
                                dot.style.transform = 'scale(1)';
                                dot.style.boxShadow = 'none';
                            };
                            dot.onclick = (e) => {
                                e.stopPropagation();
                                Core.ui.setFocus(group.groupId);
                                Core.ui.showDetails(group, Core.getStyle(group));
                            };
                            labelsFrag.appendChild(dot);
                        }
                    });

                    // 4. ÊåÇËΩΩ DOM
                    const labelLayer = document.getElementById('labels-layer');
                    if (labelLayer) {
                        labelLayer.innerHTML = ''; // Ensure clear
                        labelLayer.appendChild(labelsFrag);
                    } else {
                        renderArea.appendChild(labelsFrag);
                    }
                },

                drawConnections: function (group, color) {
                    let svg = document.getElementById('connections-layer');
                    svg.innerHTML = '';
                    let rect = document.getElementById('render-area').getBoundingClientRect();
                    let colW = rect.width / Core.state.regions.length;
                    let points = [];
                    group.fragments.forEach(f => {
                        let idx = Core.state.regionIndexMap[f.geoCode]; if (idx === undefined) return;
                        let top = (f.start - APP_CONFIG.minYear) * Core.state.zoom;
                        let xOffset = f.left + (f.w / 2);
                        if (isNaN(xOffset)) xOffset = 0.5;
                        points.push({ x: (idx + xOffset) * colW, y: top + (f.end - f.start) * Core.state.zoom / 2 });
                    });
                    if (points.length < 2) return;
                    points.sort((a, b) => a.x - b.x);
                    let d = "M " + points[0].x + " " + points[0].y;
                    for (let i = 1; i < points.length; i++) { let p1 = points[i - 1], p2 = points[i]; let mx = (p1.x + p2.x) / 2; d += " C " + mx + " " + p1.y + ", " + mx + " " + p2.y + ", " + p2.x + " " + p2.y; }
                    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", d); path.setAttribute("class", "connection-path"); path.setAttribute("stroke", color);
                    svg.appendChild(path);
                }
            },

            ui: {
                // [New] Highlight Header based on Region Code
                highlightHeader: function (geoCode) {
                    if (!geoCode) return;
                    const idx = Core.state.regionIndexMap[geoCode];
                    if (idx !== undefined) {
                        const headerBody = document.getElementById('header-body');
                        if (headerBody && headerBody.children[idx]) {
                            const target = headerBody.children[idx];
                            const old = headerBody.querySelector('.active-header');
                            if (old && old !== target) old.classList.remove('active-header');
                            target.classList.add('active-header');
                        }
                    }
                },
                clearHeaderHighlight: function () {
                    const headerBody = document.getElementById('header-body');
                    if (headerBody) {
                        const old = headerBody.querySelector('.active-header');
                        if (old) old.classList.remove('active-header');
                    }
                },

                closePanel: function () {
                    document.getElementById('editor-panel').classList.remove('panel-open');
                    Core.ui.clearFocus();
                },
                setFocus: function (groupId) {
                    if (Core.state.focusedGroupId === groupId) { Core.ui.clearFocus(); return; }
                    Core.state.focusedGroupId = groupId;
                    document.body.classList.add('mode-focus');
                    document.querySelectorAll('.group-hovered').forEach(el => el.classList.remove('group-hovered'));
                    document.querySelectorAll('.is-focused').forEach(el => el.classList.remove('is-focused'));
                    document.querySelectorAll('.' + groupId).forEach(el => el.classList.add('is-focused'));

                    const group = Core.state.regimeGroups.find(g => g.groupId === groupId);
                    if (group) Core.render.drawConnections(group, '#fff');

                    // [Fix] Remove clone logic. CSS z-index (2500) is sufficient now that header is 4000.
                    // This fixes the "floating ghost label" bug on scroll.
                },
                clearFocus: function () {
                    Core.state.focusedGroupId = null;
                    document.body.classList.remove('mode-focus');

                    // Restore original styles
                    document.querySelectorAll('.is-focused').forEach(el => {
                        el.classList.remove('is-focused');
                    });
                    document.getElementById('connections-layer').innerHTML = '';
                },
                showDetails: function (group, style) {
                    const panel = document.getElementById('editor-panel');
                    if (!panel) return;

                    panel.classList.remove('panel-right', 'panel-left');
                    const totalCols = Core.state.regions.length;
                    const centerRatio = (group.centerCol || 0) / totalCols;
                    panel.classList.add(centerRatio > 0.5 ? 'panel-left' : 'panel-right');
                    requestAnimationFrame(() => panel.classList.add('panel-open'));

                    // 1. ÈÅçÂéÜÊâÄÊúâÁâáÊÆµÔºåÊî∂ÈõÜËØ•ÊîøÊùÉÂéÜÂè≤‰∏äÊâÄÊúâÁöÑÂÆó‰∏ªÂÖ≥Á≥ª
                    const uniqueSuzerains = new Set();

                    group.fragments.forEach(f => {
                        if (!f.suzerain) {
                            uniqueSuzerains.add("Êó†");
                        }
                        else if (f.suzerainName) {
                            let txt = f.suzerainName;

                            // ÊÉÖÂÜµ A: V|J ÂèåÈáçÂÖ≥Á≥ª
                            if (f.suzerainType === 'V|J' && txt.includes('|')) {
                                const parts = txt.split('|');
                                const nameV = parts[0];
                                const nameJ = parts[1] || parts[0];
                                txt = `${nameJ} (ÁæÅÁ∏ª) & ${nameV} (Ëó©Â±û)`;
                            }
                            // ÊÉÖÂÜµ B: Âçï‰∏ÄÂÖ≥Á≥ª
                            else if (f.suzerainType) {
                                const typeMap = { 'V': 'Ëó©Â±û', 'J': 'ÁæÅÁ∏ª' };
                                const typeName = typeMap[f.suzerainType] || f.suzerainType;
                                txt = `${txt} (${typeName})`;
                            }

                            uniqueSuzerains.add(txt);
                        }
                    });

                    // 2. ÁîüÊàê HTML (‰øùÊåÅÂéüÈÄªËæë‰∏çÂèò)
                    let suzerainHtml = '';
                    const hasOverlay = Array.from(uniqueSuzerains).some(s => s !== "Êó†");

                    if (hasOverlay) {
                        const list = Array.from(uniqueSuzerains).join(' <span style="color:var(--slate-500)">/</span> ');
                        suzerainHtml = `<div class="suzerain-tag">ÂÆó‰∏ª: ${list}</div>`;
                    }

                    const f0 = group.fragments[0];
                    const typeMap = { 'C': '‰∏≠Âéü', 'Q': 'ÂæÅÊúç', 'R': 'Ââ≤ÊçÆ', 'N': 'ÈÉ®Êóè', 'F': 'ËæπÁñÜ', 'T': 'ËøáÊ∏°', 'V': 'Ëó©Â±û' };
                    const typeLabel = typeMap[group.regimeCode.charAt(0)] || 'Êú™Áü•';

                    let originLabel = f0.geoCode;
                    const originRegion = Core.state.rawRegions.find(r => r.id == f0.geoCode);
                    if (originRegion) originLabel = originRegion.label;

                    let detailHtml = '';
                    const fragsByGeo = {};
                    group.fragments.forEach(f => {
                        if (!fragsByGeo[f.geoCode]) fragsByGeo[f.geoCode] = [];
                        fragsByGeo[f.geoCode].push(f);
                    });

                    const sortedGeoCodes = Object.keys(fragsByGeo).sort((a, b) =>
                        (Core.state.regionIndexMap[a] || 0) - (Core.state.regionIndexMap[b] || 0)
                    );

                    const totalDur = Math.max(group.maxEnd - group.minStart, 1);

                    sortedGeoCodes.forEach(geoCode => {
                        const frags = fragsByGeo[geoCode];
                        frags.sort((a, b) => a.start - b.start);

                        let barsHtml = '';
                        let timeTexts = [];

                        // ‰ΩøÁî®Á¥¢Âºï i Êù•Â¢ûÂä† z-index
                        frags.forEach((f, i) => {
                            const left = ((f.start - group.minStart) / totalDur) * 100;
                            const width = ((f.end - f.start) / totalDur) * 100;
                            // [Fix] Use inline styles instead of Tailwind classes
                            barsHtml += `<div style="position:absolute; top:0; left:${left}%; width:${width}%; height:100%; background:${style.bg || '#888'}; opacity:0.9; border-radius:1px; min-width:3px; z-index:${10 + i};"></div>`;
                            timeTexts.push(`${f.start}~${f.end}`);
                        });

                        const regionName = Core.state.rawRegions.find(r => r.id == geoCode)?.label || geoCode;
                        const isCurrent = Core.state.lastClickedGeoCode == geoCode;

                        const rowClass = isCurrent ? 'active-row' : '';
                        const nameClass = isCurrent ? 'active-name' : '';
                        const icon = isCurrent ? 'üëâ ' : '';
                        const timeStr = timeTexts.join(', ');

                        detailHtml += `<div class="region-row ${rowClass}">
                            <div class="region-name ${nameClass}" title="${regionName}">${icon}${regionName}</div>
                            <div class="bar-container">${barsHtml}</div>
                            <div class="time-text" title="${timeStr}">${timeStr}</div>
                        </div>`;
                    });

                    // --- [Êñ∞Â¢ûÈÄªËæë] Â§ÑÁêÜÊ†áÈ¢òÊ†èÊåâÈíÆ ---
                    const targetGeo = Core.state.lastClickedGeoCode || (sortedGeoCodes.length > 0 ? sortedGeoCodes[0] : null);

                    // ÊûÑÂª∫Ë∑≥ËΩ¨ÂèÇÊï∞ÂØπË±°
                    const jumpPayload = {
                        target: 'map',
                        params: {
                            region: targetGeo,
                            year: group.minStart + 1,
                            regime: group.name
                        }
                    };

                    // Ëé∑ÂèñÂπ∂ÊøÄÊ¥ªÊ†áÈ¢òÊ†èÊåâÈíÆ
                    const jumpBtn = document.getElementById('btn-jump-map-header');
                    if (jumpBtn) {
                        jumpBtn.classList.add('active-btn'); // ÊòæÁ§∫ (CSS Controlled)
                        // ÁßªÈô§ÊóßÁõëÂê¨Âô® (ÈÄöËøáÂÖãÈöÜËäÇÁÇπÊõøÊç¢)
                        const newBtn = jumpBtn.cloneNode(true);
                        jumpBtn.parentNode.replaceChild(newBtn, jumpBtn);

                        // ÁªëÂÆöÊñ∞‰∫ã‰ª∂
                        newBtn.onclick = () => {
                            window.parent.postMessage({ type: "REQUEST_SWITCH", payload: jumpPayload }, "*");
                        };
                    }

                    // --- [Êõ¥Êñ∞Ê∏≤Êüì] ÁßªÈô§ÂÜÖÂÆπÂå∫ÁöÑÂ§ßÊåâÈíÆ ---
                    document.getElementById('editor-content').innerHTML = `
                        <div class="regime-card" style="background: ${style.bg}; color: ${style.text};">
                            <h3 class="regime-card-title">${group.name}</h3>
                            
                            <div class="regime-info-row">
                                <span class="info-badge" title="Regime Code">Code: ${group.regimeCode}</span>
                                <span class="info-badge" title="Tier Level">Tier: ${group.explicitTier}</span>
                                <span class="info-badge" title="ÊîøÊùÉÁ±ªÂûã">Type: ${typeLabel}</span>
                                <span class="info-badge" title="Ëµ∑Ê∫êÂå∫Âüü">Origin: ${originLabel}</span>
                            </div>

                            ${suzerainHtml}
                        </div>
                        
                        <div class="section-box details-gap">
                             <h4 class="section-title">ÁªüËæñÂå∫Âüü (${sortedGeoCodes.length})</h4>
                             <div class="custom-scrollbar" style="max-height:300px; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">${detailHtml}</div>
                        </div>
                    `;
                },
                populateSearchResults: function (term) {
                    const container = document.getElementById('search-results');
                    if (!term || term.length < 1) { container.style.display = 'none'; return; }

                    const seen = new Set();
                    const results = Core.state.regimeGroups.filter(g => {
                        if (g.name.toLowerCase().includes(term) && !seen.has(g.name)) { seen.add(g.name); return true; }
                        return false;
                    }).slice(0, 10);

                    if (results.length === 0) { container.style.display = 'none'; return; }

                    container.innerHTML = '';
                    results.forEach(g => {
                        const div = document.createElement('div');
                        div.className = 'search-item';
                        div.innerHTML = `<span>${g.name}</span> <span style="font-size:9px; color:var(--slate-500); margin-left:0.5rem">(${g.minStart})</span>`;
                        div.onclick = () => {
                            this.jumpToRegime(g);
                            document.getElementById('search-input').value = '';
                            container.style.display = 'none';
                            document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));
                        };
                        container.appendChild(div);
                    });
                    container.style.display = 'block';
                },
                jumpToRegime: function (group) {
                    const targetY = (group.minStart - APP_CONFIG.minYear) * Core.state.zoom;
                    const renderArea = document.getElementById('render-area');
                    const colWidth = renderArea.scrollWidth / Core.state.regions.length;
                    const targetX = (group.centerCol + 0.5) * colWidth;

                    document.getElementById('main-content').scrollTo({ top: targetY - 100, left: targetX - window.innerWidth / 2, behavior: 'smooth' });
                    setTimeout(() => {
                        Core.ui.setFocus(group.groupId);
                        Core.ui.showDetails(group, Core.getStyle(group));
                    }, 500);
                }
            },

            toggleFeature: function (f) {
                this.state.features[f] = !this.state.features[f];
                document.getElementById('btn-' + f).classList.toggle('active');
                if (f === 'connections') this.render.drawAll();
            }
        };

        const collisionMgr = { rects: [], add: function (x, y, w, h, tier) { const n = { l: x + 1, t: y + 1, r: x + w - 1, b: y + h - 1 }; if (tier <= 1) { this.rects.push(n); return true; } for (let r of this.rects) if (n.l < r.r && n.r > r.l && n.t < r.b && n.b > r.t) return false; this.rects.push(n); return true; }, reset: function () { this.rects = [] } };

        document.addEventListener('DOMContentLoaded', () => Core.init());
        // [Sync] Êö¥Èú≤ÁªôÁà∂Á∫ßÁöÑÂêåÊ≠• API
        window.getCenterYear = function () {
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return 2025;
            const zoom = Core.state.zoom || 1.5;
            // ËÆ°ÁÆó‰∏≠ÂøÉÁÇπÂØπÂ∫îÁöÑÂπ¥‰ªΩÔºö APP_CONFIG.minYear + (scrollTop + clientH/2) / zoom
            const midPx = el.scrollTop + (el.clientHeight / 2);
            const year = APP_CONFIG.minYear + (midPx / zoom);
            return Math.round(year);
        };

        window.scrollToYear = function (year) {
            if (typeof year !== 'number' || isNaN(year)) return;
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return;

            const zoom = Core.state.zoom || 1.5;
            const targetPx = (year - APP_CONFIG.minYear) * zoom;
            const centerOffset = el.clientHeight / 2;
            el.scrollTo({ top: targetPx - centerOffset, behavior: 'auto' }); // auto Êõ¥Âø´Ôºåsmooth ÂèØËÉΩÊúâÂª∂Ëøü
        };
    </script>
</body>

</html>