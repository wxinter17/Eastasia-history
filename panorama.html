<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸œäºšå†å²å…¨æ™¯ (v11.03)</title>

    <!-- ğŸ”‘ å…¨å±€ç‰ˆæœ¬æ§åˆ¶ -->
    <script>
        window.APP_VERSION = '2026.01.05.001';
    </script>

    <!-- [Unified CSS] Native Style (Merged) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@500;700;900&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <style id="dynamic-styles"></style>

    <style>
        /* =========================================
           EastAsia History - Standard Styles (v1.0)
           Replaces Tailwind CSS with native CSS
           ========================================= */

        :root {
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --slate-950: #020617;

            --blue-300: #93c5fd;
            --blue-400: #60a5fa;
            --blue-500: #3b82f6;
            --blue-600: #2563eb;

            --amber-300: #fcd34d;
            --amber-500: #f59e0b;
        }

        /* --- åŸºç¡€è®¾ç½® --- */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: var(--slate-900);
            color: var(--slate-300);
            font-family: 'Inter', -apple-system, sans-serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .pano-body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
            background: var(--slate-950);
        }

        #main-content {
            position: relative;
            width: 100%;
            height: calc(100% - 3rem);
            overflow: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            z-index: 1;
            will-change: scroll-position;
        }

        #chart-container {
            position: relative;
            min-width: 1400px;
            display: block;
            contain: layout;
        }

        /* --- Sticky å¸ƒå±€ --- */
        #sticky-header-row {
            position: sticky;
            top: 0;
            z-index: 4000;
            /* [Fix] Raise above labels (which are 2000+3000) */
            display: flex;
            height: 2.5rem;
            border-bottom: 1px solid var(--slate-700);
            background-color: var(--slate-900);
        }

        #header-corner {
            position: sticky;
            left: 0;
            z-index: 4100;
            /* [Fix] Topmost corner */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
        }

        #header-body {
            flex: 1;
            display: flex;
            background-color: var(--slate-900);
            position: relative;
        }

        #chart-body-row {
            display: flex;
            position: relative;
        }

        .sticky-ticks {
            position: sticky;
            left: 0;
            z-index: 3900;
            /* [Fix] High enough but below header */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
        }

        #render-area {
            flex: 1;
            position: relative;
            background-color: var(--slate-900);
            overflow: hidden;
        }

        /* --- Crosshair (è§å…‰çº¿) --- */
        #crosshair-line {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 50, 50, 1);
            box-shadow: 0 0 20px rgba(255, 50, 50, 1), 0 0 40px rgba(255, 50, 50, 0.8), 0 0 6px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1000;
        }

        #crosshair-label {
            display: none;
            position: absolute;
            left: 0.5rem;
            transform: translateY(-50%);
            background: rgba(220, 50, 50, 0.95);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1001;
            font-family: monospace;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Block Styles --- */
        .era-block-fragment {
            position: absolute;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            z-index: 10;
            box-sizing: border-box;
            transition: transform 0.1s ease, opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), filter 0.4s ease;
        }

        .no-border-left {
            border-left: none !important;
        }

        .no-border-right {
            border-right: none !important;
        }

        /* [Fix] Removed conflicting internal hover styles. Rely on SHARED_CSS_STYLES from index.html */

        /* --- Focus Mode --- */
        body.mode-focus .era-block-fragment:not(.is-focused) {
            opacity: 0.08 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
            border-color: transparent !important;
        }

        body.mode-focus .era-block-fragment.is-focused {
            opacity: 1 !important;
            filter: none !important;
            /* [Fix] Do not raise Z-Index above context limit. Just rely on labels-layer being higher. */
            z-index: 50 !important;
            /* [Fix] ç§»é™¤ç™½è‰²è¾¹æ¡† */
            box-shadow: none !important;
            transform: none;
        }

        /* --- Dots Focus Mode --- */
        body.mode-focus .era-dot:not(.is-focused) {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
        }

        body.mode-focus .era-dot.is-focused {
            opacity: 1 !important;
            filter: none !important;
            transform: scale(1.3);
            /* [Fix] ç§»é™¤ç™½è‰²è¾¹æ¡† */
            box-shadow: none;
        }

        .era-dimmed {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none;
        }

        /* --- Labels --- */
        .era-label {
            position: absolute;
            z-index: 60;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            transform: translate(-50%, -50%);
            line-height: 1.1;
            text-shadow: -1px -1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
            transition: opacity 0.4s, filter 0.4s, transform 0.3s;
        }

        body.mode-focus .era-label:not(.is-focused) {
            opacity: 0.1 !important;
            filter: blur(1px) grayscale(50%) !important;
            z-index: 60;
        }

        /* [Fix] Label é«˜äº® */
        body.mode-focus .era-label.is-focused {
            opacity: 1 !important;
            filter: none !important;
            z-index: 9000 !important;
            /* Context å†…ç½®é¡¶ */
            transform: translate(-50%, -50%) scale(1.1);
            /* [Fix] ç¡®ä¿æ— ç™½è‰²è¾¹æ¡† */
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        /* [Fix] Progress Bar Style Override */
        .bar-container div {
            min-width: 4px;
            /* é˜²æ­¢è¿‡çª„ä¸å¯è§ */
            height: 100% !important;
            top: 0 !important;
            bottom: 0;
        }

        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 1px;
        }

        .label-wrap {
            white-space: normal !important;
            word-break: break-word;
            line-height: 1.2 !important;
        }

        .label-tier-1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-weight: 400;
            letter-spacing: 2px;
            z-index: 70;
        }

        .label-tier-2 {
            font-family: 'Noto Serif SC', serif;
            font-weight: 900;
            z-index: 65;
        }

        .label-tier-3 {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            z-index: 60;
        }

        /* --- Panel & Modals --- */
        /* Editor Panel (Replaces Tailwind classes) */
        #editor-panel {
            position: fixed;
            top: 3rem;
            bottom: 0;
            width: 100%;
            z-index: 400;
            display: flex;
            flex-direction: column;
            background-color: rgba(15, 23, 42, 0.95);
            /* slate-900/95 */
            backdrop-filter: blur(12px);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (min-width: 640px) {
            #editor-panel {
                width: 24rem;
            }
        }

        .panel-right {
            right: 0;
            border-left: 1px solid var(--slate-700);
            transform: translateX(100%);
        }

        .panel-left {
            left: 0;
            border-right: 1px solid var(--slate-700);
            transform: translateX(-100%);
        }

        .panel-open {
            transform: translateX(0) !important;
        }

        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--slate-700);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.5);
        }

        .panel-title {
            font-weight: bold;
            color: var(--blue-400);
        }

        .panel-close-btn {
            color: var(--slate-400);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border: none;
        }

        .panel-close-btn:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .jump-btn {
            display: none;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            background-color: var(--blue-600);
            color: white;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            border: 1px solid rgba(96, 165, 250, 0.5);
            cursor: pointer;
        }

        .jump-btn:hover {
            background-color: var(--blue-500);
        }

        .jump-btn.active-btn {
            display: flex;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        /* Selection Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 9999;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--slate-900);
            border: 1px solid var(--slate-700);
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 24rem;
            overflow: hidden;
        }

        .modal-header {
            padding: 0.75rem;
            border-bottom: 1px solid var(--slate-800);
            background-color: rgba(30, 41, 59, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-400);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .modal-close {
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            color: var(--slate-500);
            cursor: pointer;
            border: none;
            background: transparent;
        }

        .modal-close:hover {
            color: white;
            background-color: var(--slate-700);
        }

        /* --- JS Dynamic Elements Utilities --- */
        .header-col-label {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(51, 65, 85, 0.3);
            /* slate-700/30 */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 2px;
            font-size: 10px;
            cursor: help;
            color: var(--slate-400);
            line-height: 1.25;
            word-break: break-word;
            white-space: normal;
        }

        .header-col-label:hover,
        .header-col-label.active-header {
            color: var(--blue-400);
            background: rgba(255, 255, 255, 0.1);
            z-index: 50;
        }


        .timeline-tick-label {
            position: absolute;
            width: 100%;
            text-align: center;
            /* [Fix] å±…ä¸­å¯¹é½ */
            padding: 0 0.25rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            /* [Fix] å±…ä¸­å¯¹é½ */
            line-height: 1;
            font-size: 11px;
            /* [Fix] å­—å·ç¨å¤§ */
            font-weight: bold;
            /* [Fix] åŠ ç²— */
            color: var(--slate-400);
            /* [Fix] ç¨äº®ä¸€ç‚¹ */
            font-family: monospace;
            height: 0;
        }

        .suzerain-tag {
            margin-top: 0.5rem;
            font-size: 11px;
            color: var(--amber-300);
            border: 1px solid rgba(245, 158, 11, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-block;
            line-height: 1.6;
        }

        /* Modal Animation (æ›¿ä»£ Tailwind animate-in fade-in zoom-in) */
        .modal-content {
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Details Gap */
        .details-gap {
            margin-top: 1rem;
        }

        /* Detail Panel Elements */
        .regime-card {
            padding: 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .regime-card-title {
            font-size: 1.875rem;
            font-weight: 900;
            position: relative;
            z-index: 10;
            font-family: serif;
            margin: 0;
        }

        .regime-info-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0.9;
            font-size: 0.75rem;
            z-index: 10;
            position: relative;
            font-family: monospace;
        }

        .info-badge {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0 0.25rem;
            border-radius: 0.25rem;
        }

        .section-box {
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--slate-700);
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--slate-700);
            padding-bottom: 0.5rem;
        }

        .region-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 1.5rem;
            padding: 0 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            transition: background 0.2s;
            font-size: 10px;
            color: var(--slate-300);
        }

        .region-row:hover {
            background-color: rgba(51, 65, 85, 0.3);
        }

        .region-row.active-row {
            background-color: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .region-name {
            width: 5rem;
            text-align: right;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .region-name.active-name {
            color: var(--blue-300);
        }

        .bar-container {
            flex: 1;
            height: 0.5rem;
            background-color: rgba(51, 65, 85, 0.5);
            border-radius: 0.25rem;
            position: relative;
            overflow: hidden;
        }

        .time-text {
            width: 6rem;
            font-family: monospace;
            font-size: 9px;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Search Results */
        #search-results {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--slate-800);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            max-height: 300px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            width: 240px;
        }

        .search-item {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--slate-700);
            transition: background 0.15s;
            color: var(--slate-300);
            font-size: 0.75rem;
        }

        .search-item:hover {
            background: var(--slate-700);
        }
    </style>
</head>

<body class="pano-body">

    <div id="editor-panel" class="panel-right">
        <div class="panel-header">
            <h2 class="panel-title">ğŸ“œ æ”¿æƒè¯¦æƒ…</h2>

            <div style="display:flex; gap:0.5rem; align-items:center;">
                <button id="btn-jump-map-header" class="jump-btn">
                    <span>ğŸ—ºï¸</span> æŸ¥çœ‹å†å²åœ°å›¾
                </button>
                <button id="btn-close-panel" class="panel-close-btn">âœ•</button>
            </div>
        </div>
        <div class="custom-scrollbar" id="editor-content" style="padding:1.25rem; overflow-y:auto; flex:1;"></div>
    </div>

    <div id="selection-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">è¯·é€‰æ‹©æ”¿æƒ</span>
                <button id="btn-close-modal" class="modal-close">âœ•</button>
            </div>
            <div id="selection-list" class="custom-scrollbar"
                style="padding:0.5rem; max-height:60vh; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="chart-container">
            <div id="sticky-header-row">
                <div id="header-corner">
                    <button id="btn-flip-cols" title="ç¿»è½¬åœ°åŒºåˆ—"
                        style="width:100%; height:100%; border:none; background:transparent; color:var(--slate-500); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; transition:color 0.2s;">
                        â‡„
                    </button>
                </div>
                <div id="header-body"></div>
            </div>
            <div id="chart-body-row">
                <div id="ticks-layer" class="sticky-ticks">
                    <div id="crosshair-label"></div>
                </div>
                <div id="render-area">
                    <div id="crosshair-line"></div>
                    <svg id="connections-layer" width="100%" height="100%"></svg>
                    <div id="blocks-layer" style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:10;">
                    </div>
                    <div id="labels-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:2000; pointer-events:none;">
                    </div>
                    <div id="grid-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:0; pointer-events:none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ä»çˆ¶çº§è·å–å¹´ä»½é…ç½®ï¼Œå¦‚æœçˆ¶çº§ä¸å¯ç”¨åˆ™ä½¿ç”¨æœ¬åœ°é»˜è®¤å€¼
        const TIME_CONFIG = window.parent?.GLOBAL_CONFIG?.TIME || {
            minYear: -2100, // æ³¨æ„: GLOBAL_CONFIG ç”¨å¤§å†™ key, è¿™é‡Œ fallback ç”¨å¤§å†™
            maxYear: 2025
        };

        // [New] Logger Bridge: Forward logs to parent console
        if (window.parent && window.parent.console) {
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            console.log = function (...args) {
                originalLog.apply(console, args);
                try { window.parent.console.log("[Pano]", ...args); } catch (e) { }
            };
            console.warn = function (...args) {
                originalWarn.apply(console, args);
                try { window.parent.console.warn("[Pano]", ...args); } catch (e) { }
            };
            console.error = function (...args) {
                originalError.apply(console, args);
                try { window.parent.console.error("[Pano]", ...args); } catch (e) { }
            };
            window.onerror = function (msg, source, line, col, error) {
                try { window.parent.console.error(`[Pano] Uncaught: ${msg} @ ${line}`); } catch (e) { }
            };
        }

        const APP_CONFIG = {
            minYear: TIME_CONFIG.MIN_YEAR || -2100,
            maxYear: TIME_CONFIG.MAX_YEAR || 2025
        };

        // Historical Perspectives Configuration
        const PERSPECTIVES = {
            default: {
                name: "é»˜è®¤å¸ƒå±€",
                isDefault: true
            },

            songLiaoJin: {
                name: "å®‹è¾½é‡‘æ—¶æœŸ",
                coreRegimes: [
                    "åŒ—å®‹|C5100",
                    "å—å®‹|R5110",
                    "è¾½|Q5700",
                    "é‡‘|Q5710"
                ],
                weights: {
                    intraRegime: 100,    // Same regime regions
                    interRegime: 30,     // Different core regime regions
                    background: 0.1      // Background regions
                }
            }
        };

        // --- New Label System Modules (v2.0 Refactor) ---

        /**
         * ç©ºé—´ç´¢å¼•ç±» - ä½¿ç”¨ Dynamic Grid (Spatial Hash) ä¼˜åŒ–ç¢°æ’æ£€æµ‹
         * ç›¸æ¯” QuadTreeï¼ŒGrid æ›´ç®€å•ä¸”åœ¨ç‰©ä½“åˆ†å¸ƒå‡åŒ€æ—¶æ€§èƒ½æä½³
         */
        class SpatialIndex {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map(); // key: "x_y", value: [items]
                this.items = []; // keep track of all items
            }

            _getKey(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx}_${gy}`;
            }

            _getKeysForRect(rect) {
                const keys = [];
                const startX = Math.floor(rect.x / this.cellSize);
                const endX = Math.floor((rect.x + rect.w) / this.cellSize);
                const startY = Math.floor(rect.y / this.cellSize);
                const endY = Math.floor((rect.y + rect.h) / this.cellSize);

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        keys.push(`${x}_${y}`);
                    }
                }
                return keys;
            }

            insert(item) {
                // item must have {x, y, w, h}
                if (!item._sid) item._sid = Math.random().toString(36).substr(2, 9);

                this.items.push(item);
                const keys = this._getKeysForRect(item);
                keys.forEach(k => {
                    if (!this.grid.has(k)) this.grid.set(k, []);
                    this.grid.get(k).push(item);
                });
            }

            // è¿”å›æ‰€æœ‰ä¸ rect é‡å çš„ items
            query(rect) {
                const keys = this._getKeysForRect(rect);
                const candidates = new Set();

                // 1. Gather candidates
                keys.forEach(k => {
                    const cellItems = this.grid.get(k);
                    if (cellItems) {
                        for (let i = 0; i < cellItems.length; i++) {
                            candidates.add(cellItems[i]);
                        }
                    }
                });

                // 2. Precise check
                const result = [];
                candidates.forEach(item => {
                    if (this._intersects(rect, item)) {
                        result.push(item);
                    }
                });
                return result;
            }

            _intersects(a, b) {
                return a.x < b.x + b.w &&
                    a.x + a.w > b.x &&
                    a.y < b.y + b.h &&
                    a.y + a.h > b.y;
            }

            clear() {
                this.grid.clear();
                this.items = [];
            }
        }

        /**
         * LabelSystem - è´Ÿè´£æ–°çš„æ ‡ç­¾å¸ƒå±€è®¡ç®—é€»è¾‘
         */
        const LabelSystem = {
            index: null, // SpatialIndex instance

            init() {
                // å•å…ƒæ ¼å¤§å°è®¾ä¸º 128pxï¼Œé€‚åˆå¸¸è§„æ ‡ç­¾å°ºå¯¸
                this.index = new SpatialIndex(128);
            },

            /**
             * ä¸ºå•ä¸ªæ”¿æƒç”Ÿæˆæ ‡ç­¾å€™é€‰æ–¹æ¡ˆ
             * @param {Object} group æ”¿æƒç»„
             * @param {Object} pos åŸºç¡€ä½ç½®ä¿¡æ¯ {x, y, w, h, fullW, ...}
             * @param {Number} colWidth åˆ—å®½
             */
            generateCandidates(group, pos, colWidth) {
                const tier = parseInt(group.explicitTier) || 3;
                const txt = group.name;
                const len = txt.length;

                // åŸºç¡€å°ºå¯¸é™åˆ¶
                let minFS = 9, maxFS = 16;
                if (tier === 1) { minFS = 20; maxFS = 60; }
                else if (tier === 2) { minFS = 12; maxFS = 28; }

                // è§†è§‰åŒ…å›´ç›’ (Visual Box)
                const boxW = (tier === 1 || pos.colSpan >= 2) ? pos.fullW : pos.w;
                const boxH = pos.h * Core.state.zoom; // Assume zoom access or pass in

                const candidates = [];
                const paddingFactor = 0.9;

                // è¾…åŠ©å‡½æ•°: åˆ›å»ºå¸ƒå±€æ–¹æ¡ˆ
                const addLayout = (type, fsInput, scoreMult = 1.0) => {
                    let fs = Math.min(Math.max(fsInput, minFS), maxFS);
                    let w = 0, h = 0;

                    if (type === 'H') {
                        w = fs * len; h = fs;
                    } else if (type === 'V') {
                        w = fs; h = fs * len;
                    } else if (type === 'Wrap') {
                        let cols = Math.ceil(Math.sqrt(len));
                        if (len >= 6) cols = Math.ceil(len / 2);
                        let rows = Math.ceil(len / cols);
                        w = fs * cols; h = fs * rows * 1.1;
                    }

                    // æ£€æŸ¥æ˜¯å¦èƒ½åœ¨ä¸åšä»»ä½•åç§»çš„æƒ…å†µä¸‹æ”¾å…¥ box (soft constraint)
                    // const fits = w <= boxW * 1.2 && h <= boxH * 1.2;

                    candidates.push({
                        type, fs, w, h,
                        scoreMult
                    });
                };

                // 1. Horizontal (Default)
                let hFS = Math.min(boxW * paddingFactor / len, boxH * paddingFactor);
                // Tier 3 å¿…é¡»èƒ½çœ‹æ¸…æ‰æœ‰æ„ä¹‰ï¼Œå¤ªå°å°±ä¸æ˜¾ç¤ºæ–‡å­—
                if (hFS >= minFS) {
                    addLayout('H', hFS, 1.2);
                    if (hFS * 0.85 >= minFS) addLayout('H', hFS * 0.85, 1.1);
                }

                // 2. Vertical
                // åå¥½å‚ç›´çš„æ¡ä»¶ï¼šçª„é«˜å‹åŒºåŸŸ
                const ratio = boxH / boxW;
                const preferVertical = ratio > 2.0;

                let vFS = Math.min(boxW * paddingFactor, boxH * paddingFactor / len);
                if (vFS >= minFS) {
                    addLayout('V', vFS, preferVertical ? 1.5 : 1.0);
                    if (vFS * 0.85 >= minFS) addLayout('V', vFS * 0.85, preferVertical ? 1.4 : 0.9);
                }

                // 3. Wrap (ä»…å¯¹è¾ƒé•¿æ–‡æœ¬)
                if (len >= 4) {
                    let cols = Math.ceil(Math.sqrt(len));
                    if (len >= 6) cols = Math.ceil(len / 2);
                    let wBase = boxW * paddingFactor / cols;
                    let hBase = boxH * paddingFactor / (Math.ceil(len / cols));
                    let wrapFS = Math.min(wBase, hBase);
                    if (wrapFS >= minFS) {
                        addLayout('Wrap', wrapFS, 0.9);
                        if (wrapFS * 0.85 >= minFS) addLayout('Wrap', wrapFS * 0.85, 0.85);
                    }
                }

                // å¦‚æœæ²¡æœ‰åˆæ³•çš„ï¼Œå¼ºåˆ¶å¡ä¸€ä¸ªæœ€å°çš„ H ä¾› fallback (score å¾ˆä½)
                if (candidates.length === 0) {
                    candidates.push({ type: 'H', fs: minFS, w: minFS * len, h: minFS, scoreMult: 0.1 });
                }

                candidates.sort((a, b) => (b.fs * b.scoreMult) - (a.fs * a.scoreMult));
                return candidates;
            },

            /**
             * è®¡ç®—æœ€ç»ˆå¸ƒå±€
             */
            computeAll(regimeGroups, regionIndexMap, colWidth, zoom) {
                if (!this.index) this.init();
                this.index.clear();

                const processed = [];

                // 1. Calculate ideal centers from visual slices logic
                const allItems = [];
                regimeGroups.forEach(g => {
                    const positions = Core.logic.calculateLabelPositions(g, regionIndexMap, colWidth);
                    positions.forEach(p => {
                        allItems.push({ group: g, pos: p });
                    });
                });

                // 2. Sort by Tier (1 -> 2 -> 3) then Area
                // è¿™æ ·é«˜ä¼˜å…ˆçº§çš„å…ˆå å‘
                allItems.sort((a, b) => {
                    const tA = parseInt(a.group.explicitTier) || 3;
                    const tB = parseInt(b.group.explicitTier) || 3;
                    if (tA !== tB) return tA - tB; // Tier 1 < Tier 3? No, we prioritize Tier 1.
                    // Tier 1 is highest priority. So tA < tB means a comes first.
                    return b.pos.area - a.pos.area;
                });

                const results = [];

                // 3. Placement Loop
                allItems.forEach(item => {
                    const { group, pos } = item;
                    const tier = parseInt(group.explicitTier) || 3;

                    // è·å–å€™é€‰å¸ƒå±€ (å­—å·/æ–¹å‘)
                    const layouts = this.generateCandidates(group, pos, colWidth);

                    let bestPlacement = null;
                    let bestScore = -Infinity;

                    // å®šä¹‰å°è¯•çš„ä½ç½®åç§»é‡ (ç›¸å¯¹ä¸­å¿ƒç‚¹)
                    // Tier 1 å°è¯•æ›´å¤šä½ç½®
                    let offsets = [{ x: 0, y: 0 }];

                    // ä»…åœ¨å­—å·è¾ƒå°æ—¶å°è¯•å¾®è°ƒï¼Œå¤§å­—å·è¿˜æ˜¯å±…ä¸­å¥½
                    const boxH = pos.h * zoom;

                    // å¦‚æœé«˜åº¦è¶³å¤Ÿï¼Œå…è®¸ä¸Šä¸‹æµ®åŠ¨
                    if (boxH > 40 || tier <= 2) {
                        offsets.push({ x: 0, y: -boxH * 0.25 });
                        offsets.push({ x: 0, y: boxH * 0.25 });
                    }
                    if (tier >= 3) {
                        // Tier 3 é¢å¤–å°è¯•
                        offsets.push({ x: 0, y: -boxH * 0.4 });
                        offsets.push({ x: 0, y: boxH * 0.4 });
                    }

                    // éå†æ‰€æœ‰ å¸ƒå±€ x ä½ç½® ç»„åˆ
                    for (let layout of layouts) {
                        for (let off of offsets) {
                            // è®¡ç®—ç»å¯¹åæ ‡
                            // pos.x/y æ˜¯ç‰©ç†ä¸­å¿ƒç‚¹
                            const boxY = (pos.y - APP_CONFIG.minYear) * zoom;
                            const centerX = pos.x + off.x;
                            const centerY = boxY + off.y;

                            const w = layout.w;
                            const h = layout.h;

                            // ç‰©ç†ç¢°æ’ç®± (æ”¶ç¼© 15%)
                            // è¿™æ ·è§†è§‰ä¸Šæ–‡å­—å¯èƒ½è½»å¾®æ¥è§¦ï¼Œä½†ä¸ä¼šé‡å 
                            const hitW = w * 0.85;
                            const hitH = h * 0.85;

                            const rect = {
                                x: centerX - hitW / 2,
                                y: centerY - hitH / 2,
                                w: hitW,
                                h: hitH
                            };

                            // ç¢°æ’æ£€æµ‹
                            const conflicts = this.index.query(rect);

                            // è¯„åˆ†é€»è¾‘
                            // 1. åŸºç¡€åˆ†: å­—å·å¤§å° * ç±»å‹åå¥½
                            let score = layout.fs * layout.scoreMult;

                            // 2. åç§»æƒ©ç½š (è¶Šè¿œåˆ†è¶Šä½)
                            if (off.y !== 0) score *= 0.9;

                            // 3. ç¢°æ’æƒ©ç½š
                            if (conflicts.length > 0) {
                                // ä¸¥é‡ç¢°æ’ç›´æ¥ pass
                                // æœªæ¥å¯é€‰ï¼šå…è®¸ Tier 1 è¦†ç›– Tier 3 (é€šè¿‡æ£€æŸ¥ conflicts å†… items çš„ tier)
                                continue;
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestPlacement = {
                                    layout,
                                    x: centerX,
                                    y: centerY,
                                    rect
                                };
                            }
                        }
                        // å¦‚æœåœ¨å½“å‰ fontsize æ‰¾åˆ°äº†æ— ç¢°æ’ä½ç½®ï¼Œé€šå¸¸å°±æ˜¯æœ€ä¼˜è§£ä¹‹ä¸€
                        if (bestPlacement && bestScore > 10) break;
                    }

                    if (bestPlacement) {
                        // æ³¨å†Œç¢°æ’ç®±ï¼Œæºå¸¦ metadata
                        bestPlacement.rect.tier = tier;
                        this.index.insert(bestPlacement.rect);
                        results.push({
                            group,
                            ...bestPlacement
                        });
                    } else {
                        // Failed to place label -> Dot fallback
                        results.push({
                            group,
                            failed: true,
                            x: pos.x,
                            y: (pos.y - APP_CONFIG.minYear) * zoom
                        });
                    }
                });

                return results;
            }
        };


        const Core = {
            state: { regions: [], regionIndexMap: {}, regimeGroups: [], zoom: 1.5, rawData: [], features: { connections: true }, focusedGroupId: null, lastClickedGeoCode: null, layoutCache: {}, intraColumnCache: {}, isFlipped: false },

            init: function () {
                // [Fix] ç¦ç”¨æµè§ˆå™¨æ»šåŠ¨æ¢å¤
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }

                // [Fix] è®°å½•åˆå§‹åŒ–æ—¶é—´ï¼Œç”¨äºæ‹¦æˆªåˆå§‹é˜¶æ®µçš„é”™è¯¯æ»šåŠ¨æŒ‡ä»¤
                this._initTime = Date.now();

                // [v10] æ–°å¸ƒå±€åŠ è½½ç­–ç•¥ï¼šIndexedDB + Static (ç‰ˆæœ¬å·æ§åˆ¶)
                this.state.layoutData = null;
                this.state.layoutSource = null;

                const isDevelopment = () => {
                    const host = location.hostname;
                    return host === 'localhost' || host === '127.0.0.1' ||
                        host.startsWith('192.168.') || location.protocol === 'file:';
                };

                // åº”ç”¨å¸ƒå±€å¹¶è§¦å‘æ›´æ–°
                const applyLayout = (json, source) => {
                    console.log(`ğŸ“œ Layout loaded from [${source}]` + (json.version ? ` v${json.version}` : ''));
                    this.state.layoutData = json;
                    this.state.layoutSource = source;
                    if (this.state.rawData && this.state.rawData.length > 0) {
                        this.updateLayout();
                        // [v10] å¼‚æ­¥æ‰§è¡Œä¸€è‡´æ€§æ£€æµ‹
                        setTimeout(() => this.checkLayoutConsistency(), 100);
                    }
                };

                // ä¿å­˜å¸ƒå±€åˆ° IndexedDB
                const saveToIndexedDB = (layoutData) => {
                    try {
                        const req = indexedDB.open("EastAsiaHistoryDB", 5);
                        req.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains("layouts")) {
                                db.createObjectStore("layouts", { keyPath: "id" });
                            }
                        };
                        req.onsuccess = (e) => {
                            const db = e.target.result;
                            const tx = db.transaction(["layouts"], "readwrite");
                            const store = tx.objectStore("layouts");
                            store.put({ id: "current", data: layoutData });
                            console.log(`ğŸ’¾ Layout saved to IndexedDB (v${layoutData.version || 'unknown'})`);
                        };
                    } catch (e) {
                        console.warn("Failed to save to IndexedDB:", e);
                    }
                };

                // [v10] åŠ è½½ Static å¸ƒå±€
                const loadStatic = () => {
                    return fetch('layout.json?t=' + Date.now())
                        .then(response => {
                            if (!response.ok) throw new Error('Network response was not ok');
                            return response.json();
                        });
                };

                // [v10] ä¸»åŠ è½½é€»è¾‘ï¼šå…ˆè·å– Staticï¼Œå†ä¸ DB æ¯”è¾ƒç‰ˆæœ¬
                const loadLayout = async () => {
                    let staticLayout = null;
                    let dbLayout = null;

                    // Step 1: å°è¯•åŠ è½½ Static
                    try {
                        staticLayout = await loadStatic();
                        console.log(`ğŸ“¦ Static layout loaded (v${staticLayout.version || 'unknown'})`);
                    } catch (e) {
                        console.error("âŒ Failed to load layout.json:", e);
                        if (isDevelopment()) {
                            alert("CSV/Layout åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æºï¼");
                        }
                    }

                    // Step 2: å°è¯•è¯»å– IndexedDB
                    try {
                        dbLayout = await new Promise((resolve, reject) => {
                            const req = indexedDB.open("EastAsiaHistoryDB", 5);
                            req.onerror = () => reject(new Error("DB Open Failed"));
                            req.onupgradeneeded = (e) => {
                                const db = e.target.result;
                                if (!db.objectStoreNames.contains("layouts")) {
                                    db.createObjectStore("layouts", { keyPath: "id" });
                                    console.log("[DB] Created 'layouts' store during upgrade");
                                }
                            };
                            req.onsuccess = (e) => {
                                const db = e.target.result;
                                if (!db.objectStoreNames.contains("layouts")) {
                                    resolve(null);
                                    return;
                                }
                                const tx = db.transaction(["layouts"], "readonly");
                                const store = tx.objectStore("layouts");
                                const getReq = store.get("current");
                                getReq.onsuccess = () => resolve(getReq.result?.data || null);
                                getReq.onerror = () => resolve(null);
                            };
                        });
                        if (dbLayout) {
                            console.log(`ğŸ“‚ DB layout found (v${dbLayout.version || 'unknown'})`);
                        }
                    } catch (e) {
                        console.warn("DB read failed:", e);
                    }

                    // Step 3: ç‰ˆæœ¬æ¯”è¾ƒå†³ç­–
                    const staticVersion = staticLayout?.version || "0";
                    const dbVersion = dbLayout?.version || "0";

                    if (!dbLayout) {
                        // DB ä¸ºç©ºï¼Œä½¿ç”¨ Static å¹¶åˆå§‹åŒ– DB
                        if (staticLayout) {
                            applyLayout(staticLayout, 'Static');
                            saveToIndexedDB(staticLayout);
                            console.log("ğŸ”„ Initialized DB from Static");
                        } else {
                            console.error("âŒ No layout available!");
                        }
                    } else if (staticVersion > dbVersion) {
                        // Static ç‰ˆæœ¬æ›´æ–°ï¼Œè¦†ç›– DB
                        applyLayout(staticLayout, 'Static');
                        saveToIndexedDB(staticLayout);
                        console.log(`ğŸ”„ Updated DB from Static (${dbVersion} â†’ ${staticVersion})`);
                    } else {
                        // DB ç‰ˆæœ¬ >= Staticï¼Œä½¿ç”¨ DB
                        applyLayout(dbLayout, 'IndexedDB');
                    }
                };

                // æ‰§è¡ŒåŠ è½½
                loadLayout();

                window.addEventListener('message', (e) => {
                    // ã€å…³é”®ä¿®å¤ã€‘å®‰å…¨é˜€
                    if (!e.data || typeof e.data !== 'object') return;

                    const { type, payload = {} } = e.data;

                    // Debug
                    if (type === 'CMD_RESET') console.log("ğŸ“œ å…¨æ™¯é¡µæ”¶åˆ°å¤ä½æŒ‡ä»¤!");

                    // 2. åˆå§‹åŒ–æ•°æ®ä¸æ ·å¼æ³¨å…¥
                    if (type === 'INIT_DATA') {
                        const { data, sharedCSS } = payload;

                        // [å…³é”®ä¿®å¤] æ³¨å…¥çˆ¶çº§å‘æ¥çš„ CSS (è§£å†³ texture-V/J è™šçº¿å’Œç½‘æ ¼ä¸æ˜¾ç¤ºçš„é—®é¢˜)
                        if (sharedCSS) {
                            const styleEl = document.getElementById('dynamic-styles');
                            if (styleEl) styleEl.innerHTML = sharedCSS;
                        }

                        // å¤„ç†æ ¸å¿ƒæ•°æ®
                        if (data) {
                            this.processData(data);
                        } else {
                            console.warn("Panorama: INIT_DATA received but data is empty");
                        }
                    }

                    // 3. ç¼©æ”¾æ§åˆ¶
                    if (type === 'CMD_ZOOM_IN') {
                        this.state.zoom = Math.min(this.state.zoom + 0.5, 10);
                        this.updateLayout(); // é‡æ–°è®¡ç®—å¸ƒå±€å¹¶æ¸²æŸ“
                    }
                    if (type === 'CMD_ZOOM_OUT') {
                        this.state.zoom = Math.max(this.state.zoom - 0.5, 0.5);
                        this.updateLayout(); // é‡æ–°è®¡ç®—å¸ƒå±€å¹¶æ¸²æŸ“
                    }

                    // 4. å…¨æ™¯å¤ä½é€»è¾‘
                    if (type === 'CMD_RESET' || type === 'CMD_ZOOM_RESET') {
                        // ç¡®ä¿ Core å·²åŠ è½½
                        if (this.resetView) {
                            this.resetView();
                        }
                    }

                    // 5. [åŠŸèƒ½] åˆ‡æ¢ç‰¹æ€§ (å¦‚ï¼šæ˜¾ç¤º/éšè—çº½å¸¦è¿æ¥)
                    if (type === 'CMD_TOGGLE_FEATURE') {
                        // payload ä¹Ÿæ˜¯å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ 'connections'
                        this.toggleFeature(payload);
                    }

                    // 6. æœç´¢ç»“æœè·³è½¬
                    if (type === 'CMD_SEARCH_RESULT') {
                        if (payload.target === 'panorama') {
                            this.handleJump(payload.params);
                        }
                    }

                    // 7. ç›´æ¥è·³è½¬æŒ‡ä»¤
                    if (type === 'CMD_JUMP') {
                        this.handleJump(payload);
                    }

                    // 8. åŒæ­¥æ»šåŠ¨æŒ‡ä»¤ [Fix] æ‹¦æˆªåˆå§‹åŒ–é˜¶æ®µçš„ç°ä»£å¹´ä»½
                    if (type === 'CMD_SCROLL_TO_YEAR') {
                        const timeSinceInit = Date.now() - this._initTime;
                        // å¦‚æœåœ¨åˆå§‹åŒ–å3ç§’å†…ï¼Œä¸”å¹´ä»½ > 0ï¼ˆç°ä»£ï¼‰ï¼Œåˆ™å¿½ç•¥ï¼ˆå¼ºåˆ¶ä¿æŒåœ¨å¤æœï¼‰
                        if (timeSinceInit < 3000 && payload > 0) {
                            console.log(`[Panorama] æ‹¦æˆªåˆå§‹æ»šåŠ¨æŒ‡ä»¤ï¼š${payload}ï¼Œä¿æŒåœ¨å¤æœ`);
                            return;
                        }
                        if (window.scrollToYear) window.scrollToYear(payload);
                    }

                    // === 9. å…¨å±€çŠ¶æ€åŒæ­¥ï¼ˆå•å‘æ•°æ®æµï¼šçˆ¶â†’å­ï¼‰ ===
                    if (type === 'STATE_SYNC') {
                        // æ¥æ”¶çˆ¶é¡µé¢çš„å…¨å±€çŠ¶æ€ï¼Œæ›´æ–°æœ¬åœ°è§†å›¾
                        const appState = payload;

                        // 1. åŒæ­¥å¹´ä»½ï¼ˆä½¿ç”¨å…¨æ™¯çš„æ»šåŠ¨æ–¹æ³•ï¼‰
                        // 1. åŒæ­¥å¹´ä»½ï¼ˆä½¿ç”¨å…¨æ™¯çš„æ»šåŠ¨æ–¹æ³•ï¼‰
                        if (appState.year !== undefined && window.scrollToYear) {
                            // [Fix] User Priority: ç”¨æˆ·æ­£åœ¨äº¤äº’æ—¶ï¼Œå¿½ç•¥å¤–éƒ¨åŒæ­¥ä»¥é˜²æ­¢å†²çª (ä¸ map.html è¡Œä¸ºä¸€è‡´)
                            if (this._userScrolling) {
                                // console.log('User interacting, skip sync');
                            } else {
                                window.scrollToYear(appState.year);
                            }
                        }

                        // 2. åŒæ­¥é€‰ä¸­çš„æ”¿æƒï¼ˆå¦‚æœæœ‰é«˜äº®æ–¹æ³•ï¼‰
                        if (appState.selectedRegime !== undefined) {
                            if (appState.selectedRegime) {
                                // å…¨æ™¯è§†å›¾çš„æ”¿æƒé«˜äº®é€»è¾‘ï¼ˆå¦‚æœæœ‰ï¼‰
                                console.log('[Panorama] Selected regime:', appState.selectedRegime);
                            } else {
                                // æ¸…é™¤é€‰ä¸­
                                console.log('[Panorama] Clear regime selection');
                            }
                        }

                        // 3. åŒæ­¥é”å®šçŠ¶æ€
                        if (appState.locked !== undefined) {
                            console.log('[Panorama] Regime locked:', appState.locked);
                        }

                        // è°ƒè¯•æ—¥å¿—
                        console.log('[Panorama] STATE_SYNC received:', {
                            year: appState.year,
                            selectedRegime: appState.selectedRegime,
                            locked: appState.locked
                        });
                    }
                });

                // Notify parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'CHILD_READY', payload: { source: 'panorama' } }, window.location.origin);
                }

                // Bind UI Events
                this.bindEvents();
                this._setupScrollSync(); // è®¾ç½®æ»šåŠ¨-çŠ¶æ€åŒæ­¥
            },

            // === [å•å‘æ•°æ®æµ] æ·»åŠ æ»šåŠ¨ç›‘å¬ï¼ŒåŒæ­¥å¹´ä»½åˆ°å…¨å±€çŠ¶æ€ ===
            _setupScrollSync: function () {
                const mainContent = document.getElementById('main-content');
                if (!mainContent) return;

                let scrollTimer = null;
                let isProgrammaticScroll = false;
                let userScrollEndTimer = null;
                this._userScrolling = false;

                mainContent.addEventListener('scroll', () => {
                    if (isProgrammaticScroll) return;

                    // æ ‡è®°ç”¨æˆ·æ­£åœ¨æ»šåŠ¨
                    this._userScrolling = true;
                    clearTimeout(userScrollEndTimer);
                    userScrollEndTimer = setTimeout(() => {
                        this._userScrolling = false;
                    }, 400); // ç¨å¾®é•¿äºæ›´æ–°é¢‘ç‡

                    // èŠ‚æµï¼šæ»šåŠ¨åœæ­¢300msåæ‰æ›´æ–°çŠ¶æ€ï¼ˆé¿å…é«˜é¢‘postMessageï¼‰
                    clearTimeout(scrollTimer);
                    scrollTimer = setTimeout(() => {
                        // [Fix] åˆå§‹åŒ–é˜¶æ®µï¼ˆå‰2ç§’ï¼‰ä¸å‘é€æ»šåŠ¨çŠ¶æ€æ›´æ–°ï¼Œé˜²æ­¢è¦†ç›–URLæŒ‡å®šçš„å¹´ä»½
                        const timeSinceInit = Date.now() - (Core._initTime || Date.now());
                        if (timeSinceInit < 2000) {
                            console.log('[Panorama] åˆå§‹åŒ–é˜¶æ®µï¼Œè·³è¿‡æ»šåŠ¨çŠ¶æ€åŒæ­¥');
                            return;
                        }

                        const centerYear = window.getCenterYear ? window.getCenterYear() : null;
                        if (centerYear !== null && window.parent && window.parent !== window) {
                            window.parent.postMessage({
                                type: 'STATE_UPDATE_REQUEST',
                                payload: { year: Math.round(centerYear) }
                            }, window.location.origin);
                        }
                    }, 300);
                }, { passive: true });

                // å½“æ¥æ”¶åˆ° STATE_SYNC æ—¶ï¼Œæ ‡è®°ä¸ºç¨‹åºåŒ–æ»šåŠ¨
                const originalScrollToYear = window.scrollToYear;
                window.scrollToYear = function (year) {
                    isProgrammaticScroll = true;
                    originalScrollToYear(year);
                    setTimeout(() => { isProgrammaticScroll = false; }, 500);
                };
            },

            // --- [ä¿®å¤] å…¨æ™¯é¡µä¸“ç”¨å¤ä½å‡½æ•° (å®‰å…¨ç‰ˆ) ---
            resetView: function () {
                console.log("ğŸ”„ [Panorama] æ‰§è¡Œå…¨æ™¯å¤ä½...");

                // 1. é‡ç½®æ ¸å¿ƒæ•°æ®
                this.state.zoom = 1.5;
                this.state.lastClickedGeoCode = null;

                // 2. [å®‰å…¨ä¿®å¤] æ›´æ–°æ»‘å— (å…ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨)
                // ä½ çš„ä»£ç é‡Œå…¶å®æ²¡æœ‰ id="zoom-slider"ï¼Œè¿™ä¹‹å‰å¯¼è‡´äº†æŠ¥é”™
                const zSlider = document.getElementById('zoom-slider');
                if (zSlider) {
                    zSlider.value = 1.5;
                }

                // 3. æ¸…ç†èšç„¦çŠ¶æ€
                this.ui.clearFocus();
                this.ui.closePanel();

                // 4. [å®‰å…¨ä¿®å¤] éšè—å¼¹çª— (å…ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨)
                const selModal = document.getElementById('selection-modal');
                if (selModal) selModal.classList.add('hidden');

                const searchRes = document.getElementById('search-results');
                if (searchRes) searchRes.style.display = 'none';

                const searchInp = document.getElementById('search-input');
                if (searchInp) searchInp.value = '';

                // ç§»é™¤é«˜äº®ç±»
                document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));

                // 5. ç«‹å³é‡ç»˜
                this.updateLayout();

                // 6. [å®‰å…¨ä¿®å¤] æ»šåŠ¨å½’é›¶
                const main = document.getElementById('main-content');
                if (main) {
                    main.style.scrollBehavior = 'auto'; // ç¦ç”¨å¹³æ»‘æ»šåŠ¨é˜²æ­¢å†²çª
                    main.scrollTop = 0;
                    main.scrollLeft = 0;

                    // å»¶æ—¶æ¢å¤å¹³æ»‘æ»šåŠ¨ï¼Œå¹¶å†æ¬¡ç¡®ä¿ main å­˜åœ¨
                    setTimeout(() => {
                        const m = document.getElementById('main-content');
                        if (m) m.style.scrollBehavior = 'smooth';
                    }, 500);
                }

                console.log("âœ… å…¨æ™¯è§†å›¾å·²æ¢å¤ (Zoom: 1.5)");
            },

            // [v10] æ–°ä¸€è‡´æ€§æ£€æµ‹æ–¹æ³•
            checkLayoutConsistency: function () {
                if (!this.state.layoutData || !this.state.layoutData.layout || !this.state.rawData) {
                    return;
                }
                if (this.state.hasCheckedConsistency) return;
                this.state.hasCheckedConsistency = true;

                const layout = this.state.layoutData.layout;
                const csvRegimeMap = {}; // geoId -> Set(rcodes)
                const layoutRegimeMap = {}; // geoId -> Set(rcodes)

                // ä» CSV æå–æ”¿æƒåˆ—è¡¨
                for (const frag of this.state.rawData) {
                    const geoId = frag.geoCode;
                    // id format: Name|Code
                    const parts = frag.group.id.split('|');
                    const rcode = parts.length > 1 ? parts[1] : parts[0];
                    if (!csvRegimeMap[geoId]) csvRegimeMap[geoId] = new Set();
                    csvRegimeMap[geoId].add(rcode);
                }

                // ä»å¸ƒå±€æå–æ”¿æƒåˆ—è¡¨
                for (const geoId in layout) {
                    layoutRegimeMap[geoId] = new Set();
                    for (const year in layout[geoId]) {
                        for (const regime of layout[geoId][year]) {
                            const parts = regime.split('|');
                            const rcode = parts.length > 1 ? parts[1] : parts[0];
                            if (rcode) layoutRegimeMap[geoId].add(rcode);
                        }
                    }
                }

                // æ¯”å¯¹
                const added = {}; // æ–°å¢æ”¿æƒ (CSV æœ‰, Layout æ— )
                const removed = {}; // åˆ é™¤æ”¿æƒ (Layout æœ‰, CSV æ— )
                let totalAdded = 0;
                let totalRemoved = 0;

                for (const geoId in csvRegimeMap) {
                    const csvSet = csvRegimeMap[geoId];
                    const layoutSet = layoutRegimeMap[geoId] || new Set();

                    const addedList = [...csvSet].filter(r => !layoutSet.has(r));

                    if (addedList.length > 0) {
                        added[geoId] = addedList;
                        totalAdded += addedList.length;
                    }
                }

                // Check removed regimes
                for (const geoId in layoutRegimeMap) {
                    const layoutSet = layoutRegimeMap[geoId];
                    const csvSet = csvRegimeMap[geoId] || new Set();

                    const removedList = [...layoutSet].filter(r => !csvSet.has(r));

                    if (removedList.length > 0) {
                        removed[geoId] = removedList;
                        totalRemoved += removedList.length;
                    }
                }

                // é™é»˜å¤„ç†åˆ é™¤çš„æ”¿æƒ
                if (totalRemoved > 0) {
                    console.warn(`[Layout] å¸ƒå±€ä¸­æœ‰ ${totalRemoved} ä¸ªå·²åˆ é™¤çš„æ”¿æƒ`, removed);
                }

                // å¤„ç†æ–°å¢æ”¿æƒ
                if (totalAdded > 0) {
                    console.warn('[Layout] æ£€æµ‹åˆ°æ–°å¢æ”¿æƒ:', added);

                    const isDev = location.hostname === 'localhost' ||
                        location.hostname === '127.0.0.1' ||
                        location.hostname.startsWith('192.168.') ||
                        location.protocol === 'file:';

                    if (isDev) {
                        // å¼€å‘è€…æ¨¡å¼ï¼šå¼¹çª—æç¤º
                        setTimeout(() => {
                            const msg = `æ£€æµ‹åˆ° ${totalAdded} ä¸ªæ–°å¢æ”¿æƒæœªåœ¨å¸ƒå±€ä¸­å®šä¹‰ã€‚\n(è¯¦è§æ§åˆ¶å°)\n\næ˜¯å¦è·³è½¬åˆ° LayoutOptimizer æ›´æ–°å¸ƒå±€ï¼Ÿ`;
                            if (confirm(msg)) {
                                location.href = 'LayoutOptimizer.html';
                            }
                        }, 500); // Slight delay to ensure render happens first
                    }
                } else if (totalRemoved === 0) {
                    console.log('âœ… [Layout] ä¸€è‡´æ€§æ£€æŸ¥é€šè¿‡: CSV ä¸ å¸ƒå±€æ•°æ®å®Œå…¨åŒ¹é…');
                }
            },

            bindEvents: function () {
                const safeBind = (id, event, handler) => { const el = document.getElementById(id); if (el) el.addEventListener(event, handler); };
                safeBind('btn-connections', 'click', () => this.toggleFeature('connections'));
                safeBind('btn-close-panel', 'click', () => this.ui.closePanel());
                safeBind('btn-close-modal', 'click', () => document.getElementById('selection-modal').classList.add('hidden'));
                safeBind('btn-flip-cols', 'click', () => {
                    this.state.isFlipped = !this.state.isFlipped;
                    this.updateLayout();
                    // å¯é€‰ï¼šç»™æŒ‰é’®å¢åŠ æ¿€æ´»çŠ¶æ€æ ·å¼
                    const btn = document.getElementById('btn-flip-cols');
                    if (btn) btn.style.color = this.state.isFlipped ? 'var(--blue-400)' : 'var(--slate-500)';
                });
                safeBind('quick-nav', 'change', (e) => {
                    const y = parseInt(e.target.value);
                    if (!isNaN(y)) {
                        const targetY = (y - APP_CONFIG.minYear) * this.state.zoom;
                        document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                    }
                });

                // [UX] ç‚¹å‡»é¢æ¿ header ä»»æ„ä½ç½®å…³é—­é¢æ¿
                const panelHeader = document.querySelector('#editor-panel .panel-header');
                if (panelHeader) {
                    panelHeader.addEventListener('click', (e) => {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®æˆ–å…¶å­å…ƒç´ ï¼Œå¿½ç•¥
                        if (e.target.closest('button') || e.target.closest('.jump-btn')) return;
                        this.ui.closePanel();
                    });
                }

                const searchInput = document.getElementById('search-input');
                const handleSearch = (val) => {
                    const term = val.trim().toLowerCase();
                    document.querySelectorAll('.era-block-fragment').forEach(b => {
                        if (b.dataset.name) b.classList.toggle('era-dimmed', term !== "" && !b.dataset.name.toLowerCase().includes(term));
                    });
                    this.ui.populateSearchResults(term);
                };
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => handleSearch(e.target.value));
                    searchInput.addEventListener('focus', (e) => { if (e.target.value.trim().length > 0) handleSearch(e.target.value); });
                }

                const zSlide = document.getElementById('zoom-slider');
                if (zSlide) zSlide.addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    requestAnimationFrame(() => this.render.drawAll());
                });

                // Add Interaction for render area
                const renderArea = document.getElementById('render-area');
                if (renderArea) {
                    const crosshairLine = document.getElementById('crosshair-line');
                    // [ä¿®æ”¹] ç§»é™¤å¤–éƒ¨çš„ const crosshairLabel = ...

                    renderArea.addEventListener('mousemove', function (e) {
                        const rect = renderArea.getBoundingClientRect();
                        const y = e.clientY - rect.top;

                        // 1. Crosshair Line & Label
                        if (crosshairLine) { crosshairLine.style.display = 'block'; crosshairLine.style.top = y + 'px'; }
                        const crosshairLabel = document.getElementById('crosshair-label'); // Dynamic get
                        const year = Math.floor((y / Core.state.zoom) + APP_CONFIG.minYear);
                        if (crosshairLabel) { crosshairLabel.style.display = 'block'; crosshairLabel.style.top = y + 'px'; crosshairLabel.innerText = year; }


                        // [Fix] Dynamically calculate column metrics to avoid ReferenceError
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const cols = headerBody.children;
                            const colCount = cols.length;

                            if (colCount > 0) {
                                // Get actual width of first column
                                const colW = cols[0].getBoundingClientRect().width;
                                const mouseX = e.clientX - rect.left;
                                const colIdx = Math.floor(mouseX / colW);

                                if (cols.length > colIdx && colIdx >= 0) {
                                    const old = headerBody.querySelector('.active-header');
                                    const target = cols[colIdx];
                                    if (old !== target) {
                                        if (old) old.classList.remove('active-header');
                                        if (target) target.classList.add('active-header');
                                    }
                                }
                            }
                        }
                    });

                    renderArea.addEventListener('mouseleave', function () {
                        if (crosshairLine) crosshairLine.style.display = 'none';
                        const crosshairLabel = document.getElementById('crosshair-label');
                        if (crosshairLabel) crosshairLabel.style.display = 'none';

                        // Clear header highlight
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const old = headerBody.querySelector('.active-header');
                            if (old) old.classList.remove('active-header');
                        }
                    });
                }
            },

            processData: function (rows) {
                if (!rows || rows.length === 0) {
                    console.error("Panorama received empty data");
                    return;
                }

                // 1. å»ºç«‹ Code -> Name å…¨å±€æŸ¥æ‰¾è¡¨ (ç”¨äºè§£æå®—ä¸»å›½ä»£ç )
                const codeToNameMap = {};
                rows.forEach(r => {
                    const code = r.regime_code;
                    const name = r.regime_name || r.name;
                    if (code && name) codeToNameMap[code] = name;
                });

                const uniqueRegs = {};
                const groups = {};
                const rawList = [];

                rows.forEach((r, i) => {
                    const geoCode = r.geo_code || r.geo;
                    const geoName = r.geo_name || r.region || "æœªçŸ¥";

                    if (!geoCode) return;
                    if (!uniqueRegs[geoCode]) uniqueRegs[geoCode] = geoName;

                    const regimeName = r.regime_name || r.name || "æœªçŸ¥æ”¿æƒ";
                    // [Fix] Fallback é€»è¾‘ä¸ LayoutOptimizer ç»Ÿä¸€ï¼šå¦‚æœæ²¡æœ‰ Codeï¼Œä½¿ç”¨ Name ä»£æ›¿ï¼Œè€Œä¸æ˜¯ "C11"
                    const regimeCode = r.regime_code || regimeName;
                    // [Fix] ä½¿ç”¨ name + code ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œé˜²æ­¢åŒåä¸åŒæ”¿æƒè¢«é”™è¯¯åˆå¹¶
                    // ä¾‹å¦‚ï¼šæˆ˜å›½ç§¦(R1150) å’Œ ç§¦æœç§¦(C2100) å¿…é¡»åˆ†å¼€
                    const key = regimeName + '|' + regimeCode;

                    // åˆå§‹åŒ– Group
                    if (!groups[key]) {
                        groups[key] = {
                            id: key,
                            groupId: 'g-' + this.logic.simpleHash(key),
                            name: regimeName,  // æ˜¾ç¤ºåç§°ä»ç„¶æ˜¯ regimeName
                            regimeCode: regimeCode,
                            minStart: 9999, maxEnd: -9999,
                            explicitTier: parseInt(r.regime_tier || r.level || 3),
                            fragments: [],
                            visualSlices: [],
                            globalMinCol: 9999, globalMaxCol: -9999,
                            // Group çº§åˆ«çš„å®—ä¸»ä¿¡æ¯ä»…ä½œå‚è€ƒï¼ˆå–å‡ºç°è¿‡çš„ä»»ä½•ä¸€ä¸ªï¼‰
                            suzerain: null
                        };
                    }

                    let start = parseInt(r.start_year || r.year_start);
                    let end = (r.end_year === 'present' || r.year_end === 'present') ? TIME_CONFIG.MAX_YEAR : parseInt(r.end_year || r.year_end);
                    if (isNaN(start)) start = TIME_CONFIG.DEFAULT_START || -200;
                    if (isNaN(end)) end = TIME_CONFIG.MAX_YEAR;

                    // ã€å…³é”®ä¿®å¤ã€‘ä¸ºå½“å‰è¿™ä¸€è¡Œï¼ˆFragmentï¼‰è§£æå®—ä¸»å›½åç§°
                    let rawSuzCode = r.suzerain_code || r.suzerain;
                    let resolvedSuzName = null;

                    if (rawSuzCode && rawSuzCode !== 'null') {
                        if (r.suzerain_type === 'V|J' && rawSuzCode.includes('|')) {
                            // åŒé‡å…³ç³»ï¼šåˆ†åˆ«ç¿»è¯‘
                            const parts = rawSuzCode.split('|');
                            const name1 = codeToNameMap[parts[0]] || parts[0];
                            const name2 = codeToNameMap[parts[1]] || parts[1];
                            resolvedSuzName = `${name1}|${name2}`;
                        } else {
                            // å•é‡å…³ç³»
                            resolvedSuzName = codeToNameMap[rawSuzCode] || rawSuzCode;
                        }
                    } else {
                        // æ˜¾å¼æ ‡è®°ä¸ºç©ºï¼Œç¡®ä¿è¯¦æƒ…é¡µèƒ½è¯†åˆ«å‡º"æ— "
                        rawSuzCode = null;
                    }

                    // æ„å»º Fragment
                    const frag = {
                        id: i, name: key, start: start, end: end,
                        regimeCode: r.regime_code, geoCode: geoCode,
                        explicitTier: groups[key].explicitTier,

                        // ç¡®ä¿å­˜å…¥è§£æåçš„æ•°æ®
                        suzerain: rawSuzCode,
                        suzerainName: resolvedSuzName,
                        suzerainType: r.suzerain_type,
                        desc: r.desc,
                        group: groups[key] // [Fix] Link back to group for easy access
                    };

                    groups[key].fragments.push(frag);
                    groups[key].minStart = Math.min(groups[key].minStart, start);
                    groups[key].maxEnd = Math.max(groups[key].maxEnd, end);
                    groups[key].globalMinYear = Math.min(groups[key].globalMinYear, start);
                    groups[key].globalMaxYear = Math.max(groups[key].globalMaxYear, end);

                    rawList.push(frag);
                });

                this.state.rawRegions = Object.entries(uniqueRegs).map(([k, v]) => ({ id: k, label: v }));
                this.state.regimeGroups = Object.values(groups);
                this.state.rawData = rawList;

                this.updateLayout();
            },

            updateLayout: function () {
                // [v10] ä¸€è‡´æ€§æ£€æµ‹å·²ç§»è‡³ç‹¬ç«‹çš„ checkLayoutConsistency æ–¹æ³•

                this.state.regions = this.logic.applyFixedLayout(this.state.rawRegions);
                this.state.regionIndexMap = this.state.regions.reduce((acc, r, i) => { acc[r.id] = i; return acc; }, {});

                this.logic.calculateGroupCenters(this.state.regimeGroups, this.state.regionIndexMap);
                this.render.drawAll();

                // [Fix] åˆå§‹åŠ è½½æ—¶æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼ˆæœ€æ—©æ—¶é—´ï¼‰
                if (!this.state.hasInitialScrolled) {
                    this.state.hasInitialScrolled = true;
                    // ä½¿ç”¨è¾ƒé•¿çš„ setTimeout ç¡®ä¿è¦†ç›–å…¶ä»–æ»šåŠ¨å‘½ä»¤
                    setTimeout(() => {
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.scrollTop = 0;
                            mainContent.scrollLeft = 0;
                        }
                    }, 500);
                }
            },

            getStyle: function (group, frag) {
                const regimeCode = group.regimeCode;
                const name = group.name;
                const suzerainCode = (frag && frag.suzerain) ? frag.suzerain : group.suzerain;
                const suzerainType = (frag && frag.suzerainType) ? frag.suzerainType : group.suzerainType;

                if (window.parent && window.parent.GlobalUtils) {
                    try {
                        return window.parent.GlobalUtils.getStyle(regimeCode, name, suzerainCode, suzerainType);
                    } catch (e) {
                        console.warn("Call parent GlobalUtils.getStyle failed", e);
                    }
                }
                return { bg: '#666', border: '#444', className: 'texture-N', isDashed: false };
            },

            handleJump: function (payload) {
                if (payload.year) {
                    const targetY = (parseInt(payload.year) - APP_CONFIG.minYear) * this.state.zoom;
                    document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                }
                if (payload.regime) {
                    const target = this.state.regimeGroups.find(g => g.name.includes(payload.regime));
                    if (target) setTimeout(() => this.ui.jumpToRegime(target), 300);
                }
            },

            logic: {
                // [New] Perspective-Based Layout Optimization

                // Extract core regions from perspective configuration
                extractCoreRegions: function (perspective) {
                    const coreRegions = new Set();

                    Core.state.regimeGroups.forEach(group => {
                        if (perspective.coreRegimes.includes(group.id)) {
                            group.fragments.forEach(frag => {
                                coreRegions.add(frag.geoCode);
                            });
                        }
                    });

                    console.log(`[${perspective.name}] æ ¸å¿ƒåŒºåŸŸ: ${coreRegions.size} åˆ—`, Array.from(coreRegions));
                    return coreRegions;
                },

                // Check if two regions belong to the same core regime
                belongToSameRegime: function (regionA, regionB, coreRegimes) {
                    for (let regimeId of coreRegimes) {
                        const group = Core.state.regimeGroups.find(g => g.id === regimeId);
                        if (!group) continue;

                        const regionsInRegime = new Set(group.fragments.map(f => f.geoCode));
                        if (regionsInRegime.has(regionA) && regionsInRegime.has(regionB)) {
                            return true;
                        }
                    }
                    return false;
                },

                // Build weighted affinity matrix for perspective
                buildWeightedMatrix: function (perspective, baseMatrix) {
                    if (perspective.isDefault) {
                        // Default perspective: use base matrix as-is
                        return baseMatrix;
                    }

                    const coreRegions = this.extractCoreRegions(perspective);
                    const n = Core.state.rawRegions.length;
                    const matrix = Array(n).fill(0).map((_, i) => baseMatrix[i].slice());

                    // Apply weights
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const rA = Core.state.rawRegions[i].id;
                            const rB = Core.state.rawRegions[j].id;

                            const bothCore = coreRegions.has(rA) && coreRegions.has(rB);
                            const bothBg = !coreRegions.has(rA) && !coreRegions.has(rB);

                            if (bothCore) {
                                const sameRegime = this.belongToSameRegime(rA, rB, perspective.coreRegimes);
                                matrix[i][j] *= sameRegime
                                    ? perspective.weights.intraRegime
                                    : perspective.weights.interRegime;
                            } else if (bothBg) {
                                matrix[i][j] *= perspective.weights.background;
                            } else {
                                matrix[i][j] *= perspective.weights.background;
                            }
                        }
                    }

                    return matrix;
                },

                getRegimeTier: function (t) { return parseInt(t) || 3; },
                simpleHash: function (str) { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); },

                calculateGroupCenters: function (groups, regionIndexMap) {
                    groups.forEach(g => {
                        let totalCol = 0, count = 0;
                        g.fragments.forEach(f => {
                            const idx = regionIndexMap[f.geoCode];
                            if (idx !== undefined) {
                                totalCol += idx; count++;
                                g.globalMinCol = Math.min(g.globalMinCol, idx);
                                g.globalMaxCol = Math.max(g.globalMaxCol, idx);
                            }
                        });
                        g.centerCol = count > 0 ? (totalCol / count) : 0;
                        g.globalDuration = g.globalMaxYear - g.globalMinYear;
                    });
                },

                applyFixedLayout: function (rawRegions) {
                    let sorted = [];
                    if (Core.state.layoutData && Core.state.layoutData.colOrder) {
                        const orderMap = {};
                        Core.state.layoutData.colOrder.forEach((id, i) => orderMap[id] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = orderMap[a.id] !== undefined ? orderMap[a.id] : 9999;
                            const rB = orderMap[b.id] !== undefined ? orderMap[b.id] : 9999;
                            return rA - rB;
                        });
                    } else {
                        // Fallback (Original fixed order)
                        const FIXED_ORDER = ['550', '530', '520', '510', '540', '440', '410', '420', '430', '330', '350', '340', '260', '270', '310', '250', '240', '320', '220', '210', '230', '190', '150', '130', '140', '160', '120', '110', '180', '170', '610', '620', '740', '730', '720', '710', '820', '810', '840', '830', '850', '910', '920', '930', '940', '950', '960'];
                        const rankMap = {}; FIXED_ORDER.forEach((c, i) => rankMap[c] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = rankMap[a.id] !== undefined ? rankMap[a.id] : 9999;
                            const rB = rankMap[b.id] !== undefined ? rankMap[b.id] : 9999;
                            return rA - rB;
                        });
                    }

                    if (Core.state.isFlipped) {
                        sorted.reverse();
                    }
                    return sorted;
                },

                sliceFragmentsByRegion: function (fragments, colIdx, allGroups, regionIndexMap, layoutCache) {
                    if (!fragments || fragments.length === 0) return [];
                    const slices = [];

                    // 1. è·å–å½“å‰åˆ—å¯¹åº”çš„ Region ID
                    // fragments ä¸­çš„ geoCode åº”è¯¥éƒ½æ˜¯åŒä¸€ä¸ªï¼Œä½†ä¸ºäº†ä¿é™©å» Core.state.regions æŸ¥
                    const regionObj = Core.state.regions[colIdx];
                    if (!regionObj) return [];
                    const regionId = regionObj.id;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰é¢„è®¡ç®—çš„ layout æ•°æ®
                    const hasLayout = Core.state.layoutData && Core.state.layoutData.layout && Core.state.layoutData.layout[regionId];
                    const layoutMap = hasLayout ? Core.state.layoutData.layout[regionId] : null;

                    // å¦‚æœæ²¡æœ‰å¸ƒå±€æ•°æ®ï¼Œç›´æ¥è¿”å›å…¨å®½ (Fallback)
                    if (!layoutMap) {
                        fragments.forEach(f => {
                            const newFrag = Object.assign({}, f);
                            newFrag.displayStart = f.start;
                            newFrag.displayEnd = f.end;
                            newFrag.leftPct = 0;
                            newFrag.widthPct = 100;
                            newFrag.group.visualSlices.push({
                                cIdx: colIdx,
                                start: f.start, end: f.end,
                                left: 0, w: 1, dur: f.end - f.start
                            });
                            slices.push(newFrag);
                        });
                        return slices;
                    }

                    // 3. åŸºäº layout.json åˆ‡å‰²æ—¶æ®µ
                    fragments.forEach(frag => {
                        const regimeName = frag.group.name;
                        const regimeCode = frag.group.regimeCode || regimeName; // [Fix] è·å– Code

                        // [Fix] æ„é€ ç›®æ ‡ IDï¼Œå¿…é¡»åŒ¹é… LayoutOptimizer çš„ 'Name|Code' æ ¼å¼
                        const targetID = regimeName + "|" + regimeCode;

                        const start = Math.max(frag.start, APP_CONFIG.minYear);
                        const end = Math.min(frag.end, APP_CONFIG.maxYear);
                        if (start >= end) return;

                        let currStart = start;
                        let currLeft = -1;
                        let currWidth = -1;

                        for (let y = start; y < end; y++) {
                            const yearKey = String(y);
                            const slots = layoutMap[yearKey] || [];

                            // [Fix] æŸ¥æ‰¾é€»è¾‘å‡çº§ï¼šä¼˜å…ˆæŸ¥æ–°IDï¼ŒæŸ¥ä¸åˆ°å†æŸ¥æ—§ID(å…¼å®¹)
                            let slotIdx = slots.indexOf(targetID);
                            if (slotIdx === -1) slotIdx = slots.indexOf(regimeName);
                            let totalSlots = slots.length;

                            let left = 0, width = 100;

                            if (slotIdx !== -1 && totalSlots > 0) {
                                width = 100 / totalSlots;
                                if (Core.state.isFlipped) {
                                    left = (totalSlots - 1 - slotIdx) * width;
                                } else {
                                    left = slotIdx * width;
                                }
                            } else {
                                // [Fix] å¦‚æœ layout é‡Œæ²¡æ‰¾åˆ°è¯¥æ”¿æƒ (æ•°æ®ä¸ä¸€è‡´)
                                // æ”¹ä¸ºè¿½åŠ åˆ°åˆ—æœ«å°¾ï¼Œè€Œä¸æ˜¯å…¨å®½è¦†ç›–
                                const effectiveTotal = Math.max(totalSlots, 1) + 1; // å‡è£…å¤šä¸€ä¸ªæ§½ä½
                                width = 100 / effectiveTotal;
                                left = Core.state.isFlipped ? 0 : (effectiveTotal - 1) * width; // æ”¾æœ€å
                                // æ§åˆ¶å°è­¦å‘Šï¼ˆä»…é¦–æ¬¡ï¼‰
                                if (!this._warnedMissingLayout) this._warnedMissingLayout = new Set();
                                if (!this._warnedMissingLayout.has(targetID)) {
                                    console.warn(`[Layout] æ”¿æƒ "${regimeName}" åœ¨ Layout ä¸­æœªæ‰¾åˆ°ï¼Œå·²è¿½åŠ åˆ°åˆ—æœ«å°¾`);
                                    this._warnedMissingLayout.add(targetID);
                                }
                            }

                            // çŠ¶æ€å˜æ›´æ£€æµ‹
                            // [Fix] ä½¿ç”¨ epsilon æ¯”è¾ƒæµ®ç‚¹æ•°
                            const isChanged = Math.abs(left - currLeft) > 0.01 || Math.abs(width - currWidth) > 0.01;

                            if (currLeft !== -1 && isChanged) {
                                // ç»“æŸä¸Šä¸€æ®µ
                                pushSlice(slices, frag, currStart, y, currLeft, currWidth, colIdx);
                                currStart = y;
                            }

                            if (currLeft === -1 || isChanged) {
                                currLeft = left;
                                currWidth = width;
                            }
                        }

                        // ç»“æŸæœ€åä¸€æ®µ
                        if (currLeft !== -1) {
                            pushSlice(slices, frag, currStart, end, currLeft, currWidth, colIdx);
                        }
                    });

                    function pushSlice(outArr, originalFrag, s, e, l, w, cIdx) {
                        if (s >= e) return;
                        const newFrag = Object.assign({}, originalFrag);
                        newFrag.displayStart = s;
                        newFrag.displayEnd = e;
                        newFrag.leftPct = l;
                        newFrag.widthPct = w;

                        // æ›´æ–° Group ç»Ÿè®¡ä¿¡æ¯
                        newFrag.group.visualSlices.push({
                            cIdx: cIdx,
                            start: s, end: e,
                            left: l / 100, w: w / 100,
                            dur: e - s
                        });

                        outArr.push(newFrag);
                    }

                    return slices;
                },

                calculateLabelPositions: function (group, regionIndexMap, colWidth) {
                    const frags = group.visualSlices;
                    if (!frags || frags.length === 0) return [];

                    frags.sort((a, b) => a.cIdx - b.cIdx || a.start - b.start);

                    const clusters = [];
                    const processed = new Set();

                    frags.forEach((f, i) => {
                        if (processed.has(i)) return;
                        const currentCluster = [f];
                        processed.add(i);

                        let queue = [f];
                        while (queue.length > 0) {
                            let curr = queue.shift();
                            for (let j = 0; j < frags.length; j++) {
                                if (processed.has(j)) continue;
                                const cand = frags[j];
                                const sameCol = (cand.cIdx === curr.cIdx);
                                const timeTouch = (cand.start <= curr.end + 5) && (cand.end >= curr.start - 5);
                                const neighborCol = Math.abs(cand.cIdx - curr.cIdx) === 1;
                                const timeOverlap = (cand.start < curr.end) && (cand.end > curr.start);

                                if ((sameCol && timeTouch) || (neighborCol && timeOverlap)) {
                                    currentCluster.push(cand);
                                    processed.add(j);
                                    queue.push(cand);
                                }
                            }
                        }
                        clusters.push(currentCluster);
                    });

                    const results = clusters.map(cluster => {
                        let totalArea = 0;
                        let weightedX = 0;
                        let weightedY = 0;
                        let minTime = 9999, maxTime = -9999;
                        let minC = 9999, maxC = -9999;

                        let maxSliceArea = -1;
                        let bestSlice = null;

                        cluster.forEach(f => {
                            const h = f.dur;
                            const wPct = f.w;
                            const area = h * wPct;

                            const physCenterX = (f.cIdx + f.left + (f.w / 2)) * colWidth;
                            const physCenterY = (f.start + f.end) / 2;

                            weightedX += physCenterX * area;
                            weightedY += physCenterY * area;
                            totalArea += area;

                            minTime = Math.min(minTime, f.start);
                            maxTime = Math.max(maxTime, f.end);
                            minC = Math.min(minC, f.cIdx);
                            maxC = Math.max(maxC, f.cIdx);

                            if (area > maxSliceArea) {
                                maxSliceArea = area;
                                bestSlice = { x: physCenterX, y: physCenterY, w: f.w * colWidth, h: h };
                            }
                        });

                        if (totalArea === 0) return null;

                        const finalX = weightedX / totalArea;
                        const finalY = weightedY / totalArea;
                        const fullHeight = maxTime - minTime;
                        const effectiveWidthPx = (totalArea / Math.max(fullHeight, 1)) * colWidth;
                        const boundingWidthPx = (maxC - minC + 1) * colWidth;
                        const colSpan = maxC - minC + 1;

                        return {
                            x: finalX,
                            y: finalY,
                            bestSlice: bestSlice,
                            w: effectiveWidthPx,
                            fullW: boundingWidthPx,
                            colSpan: colSpan,
                            h: fullHeight,
                            area: totalArea
                        };
                    }).filter(r => r !== null);

                    if (group.explicitTier == 1) {
                        results.sort((a, b) => b.area - a.area);
                        return [results[0]];
                    }

                    return results.filter(r => r.area > 5);
                }
            },

            render: {
                drawAll: function () {
                    // æ¢å¤ä¸¥æ ¼ç¢°æ’æ£€æµ‹ï¼Œä¸ä½¿ç”¨ Monkey Patch
                    collisionMgr.reset();

                    Core.state.regimeGroups.forEach(g => g.visualSlices = []);

                    let container = document.getElementById('chart-container');
                    if (!container) return;

                    let headerBody = document.getElementById('header-body');
                    let ticksLayer = document.getElementById('ticks-layer');
                    let renderArea = document.getElementById('render-area');

                    headerBody.innerHTML = '';
                    ticksLayer.innerHTML = '<div id="crosshair-label"></div>';
                    document.getElementById('blocks-layer').innerHTML = '';
                    document.getElementById('labels-layer').innerHTML = '';
                    document.getElementById('connections-layer').innerHTML = '';

                    if (!Core.state.regions || Core.state.regions.length === 0) return;

                    let totalHeight = (APP_CONFIG.maxYear - APP_CONFIG.minYear) * Core.state.zoom + 100;
                    let colCount = Core.state.regions.length;

                    ticksLayer.style.height = totalHeight + 'px';
                    renderArea.style.height = totalHeight + 'px';

                    Core.state.regions.forEach((r, i) => {
                        let el = document.createElement('div');
                        el.className = 'header-col-label';
                        el.style.left = (i / colCount) * 100 + '%'; el.style.width = (1 / colCount) * 100 + '%'; el.innerText = r.label;
                        headerBody.appendChild(el);
                    });

                    let tickFrag = document.createDocumentFragment();
                    for (let y = APP_CONFIG.minYear; y <= APP_CONFIG.maxYear; y += 100) {
                        let top = (y - APP_CONFIG.minYear) * Core.state.zoom;
                        if (top < 0) continue;
                        let el = document.createElement('div'); el.className = 'timeline-tick-label';
                        el.style.top = top + 'px'; el.innerText = y; tickFrag.appendChild(el);
                    }
                    ticksLayer.appendChild(tickFrag);

                    Core.render.setupInteractions(renderArea, colCount);

                    let fragsByRegion = {};
                    Core.state.regimeGroups.forEach(group => {
                        let style = Core.getStyle(group);
                        let groupId = group.groupId;
                        group.fragments.forEach(f => {
                            if (!fragsByRegion[f.geoCode]) fragsByRegion[f.geoCode] = [];
                            let fragStyle = style;
                            if (f.suzerain) fragStyle = Core.getStyle(group, f);
                            fragsByRegion[f.geoCode].push(Object.assign({}, f, { style: fragStyle, groupName: group.name, groupId: groupId, group: group }));
                        });
                    });

                    let allRenderSlices = [];
                    Core.state.regions.forEach((region, colIdx) => {
                        let fragments = fragsByRegion[region.id];
                        if (fragments) {
                            let slices = Core.logic.sliceFragmentsByRegion(fragments, colIdx, Core.state.regimeGroups, Core.state.regionIndexMap, Core.state.layoutCache);
                            slices.forEach(s => { s.colIdx = colIdx; allRenderSlices.push(s); });
                        }
                    });

                    allRenderSlices.sort((a, b) => {
                        if (a.groupId !== b.groupId) return a.groupId.localeCompare(b.groupId);
                        if (Math.abs(a.displayStart - b.displayStart) > 0.1) return a.displayStart - b.displayStart;
                        return a.colIdx - b.colIdx;
                    });

                    let mergedSlices = [];
                    if (allRenderSlices.length > 0) {
                        let currentMerge = allRenderSlices[0];
                        currentMerge.colspan = 1;
                        currentMerge.startCol = currentMerge.colIdx;
                        // [Fix] ç´¯åŠ å®é™…å®½åº¦ï¼ˆä»¥"åˆ—å®½ç™¾åˆ†æ¯”å•ä½"è®¡ç®—ï¼‰
                        // ä¾‹å¦‚ï¼š100% å®½åº¦ = 1.0 ä¸ªåˆ—å®½å•ä½ï¼Œ50% å®½åº¦ = 0.5 ä¸ªåˆ—å®½å•ä½
                        currentMerge.totalWidthUnits = currentMerge.widthPct / 100;

                        for (let i = 1; i < allRenderSlices.length; i++) {
                            let next = allRenderSlices[i];
                            let prev = currentMerge;

                            // [Fix] åˆå¹¶æ¡ä»¶ï¼š
                            // 1. åŒæ”¿æƒã€ç›¸é‚»åˆ—ã€æ—¶é—´å¯¹é½
                            // 2. è¾¹ç¼˜å¯¹é½ï¼šprev å¿…é¡»å æ»¡å³è¾¹ç¼˜ï¼Œnext å¿…é¡»ä»å·¦è¾¹ç¼˜å¼€å§‹
                            // 3. [NEW] ä¸èƒ½æ˜¯ç‹¬å æ•´åˆ—çš„æƒ…å†µï¼ˆç‹¬å æ”¿æƒå¯èƒ½åªæ˜¯ç¢°å·§åŒåï¼Œä¸åº”åˆå¹¶ï¼‰
                            let basicMatch = next.groupId === prev.groupId &&
                                next.colIdx === (prev.startCol + prev.colspan) &&
                                Math.abs(next.displayStart - prev.displayStart) < 0.1 &&
                                Math.abs(next.displayEnd - prev.displayEnd) < 0.1;

                            // prev å¿…é¡»å æ®è¯¥åˆ—çš„æœ€å³ä¾§ï¼ˆç‹¬å æˆ–å³è¾¹ç¼˜å¯¹é½ï¼‰
                            let prevRightEdge = (prev.leftPct + prev.widthPct) >= 95;
                            // next å¿…é¡»ä»å·¦è¾¹ç¼˜å¼€å§‹
                            let nextLeftEdge = next.leftPct <= 5;

                            // [Fix] ç¦æ­¢åˆå¹¶ç‹¬å æ•´åˆ—çš„æƒ…å†µ
                            // å¦‚æœprevæˆ–nextç‹¬å æ•´åˆ—ï¼ˆwidthPct >= 95ï¼‰ï¼Œä¸åˆå¹¶
                            let prevIsFullWidth = prev.widthPct >= 95;
                            let nextIsFullWidth = next.widthPct >= 95;
                            let canMerge = !prevIsFullWidth && !nextIsFullWidth;

                            let isSame = basicMatch && prevRightEdge && nextLeftEdge && canMerge;
                            if (isSame) {
                                currentMerge.colspan++;
                                // [Fix] ç´¯åŠ  next çš„å®é™…å®½åº¦
                                currentMerge.totalWidthUnits += next.widthPct / 100;
                            }
                            else {
                                mergedSlices.push(currentMerge);
                                currentMerge = next;
                                currentMerge.colspan = 1;
                                currentMerge.startCol = currentMerge.colIdx;
                                currentMerge.totalWidthUnits = currentMerge.widthPct / 100;
                            }
                        }
                        mergedSlices.push(currentMerge);
                    }

                    let blocksFrag = document.createDocumentFragment();
                    mergedSlices.forEach(slice => {
                        let top = (slice.displayStart - APP_CONFIG.minYear) * Core.state.zoom;
                        let h = Math.max((slice.displayEnd - slice.displayStart) * Core.state.zoom, 1);
                        let el = document.createElement('div');

                        el.className = 'era-block-fragment ' + slice.style.className + ' ' + slice.groupId;
                        el.style.backgroundColor = slice.style.bg;
                        if (slice.style.pattern) el.style.setProperty('--pat-color', slice.style.pattern);

                        if (slice.style.className.includes('texture-V') || slice.style.className.includes('texture-VJ')) {
                            el.style.borderStyle = 'dashed'; el.style.borderColor = slice.style.border; el.style.borderWidth = '2px';
                            el.style.zIndex = parseInt(el.style.zIndex || 10) + 1;
                        } else {
                            el.style.border = '1px solid rgba(0,0,0,0.1)';
                        }

                        let isLeft = slice.startCol === 0;
                        let isRight = (slice.startCol + slice.colspan) === colCount;
                        let checkNeighbor = (c) => allRenderSlices.some(o => o.colIdx === c && o.groupId === slice.groupId && Math.max(slice.displayStart, o.displayStart) < Math.min(slice.displayEnd, o.displayEnd));
                        let hasL = checkNeighbor(slice.startCol - 1);
                        let hasR = checkNeighbor(slice.startCol + slice.colspan);

                        if (hasL || (slice.colspan > 1 && !isLeft)) el.classList.add('no-border-left');
                        if (hasR || (slice.colspan > 1 && !isRight)) el.classList.add('no-border-right');

                        let colWidthPct = 100 / colCount;
                        // [Fix] ä½¿ç”¨ç´¯åŠ çš„å®é™…å®½åº¦ï¼Œè€Œé colspan * widthPct
                        let totalWidthPct = slice.totalWidthUnits * colWidthPct;
                        let totalLeftPct = (slice.startCol * colWidthPct) + ((slice.leftPct / 100) * colWidthPct);

                        el.style.left = totalLeftPct + '%';

                        if ((hasL || hasR || slice.colspan > 1) && slice.widthPct >= 95) {
                            el.style.width = `calc(${totalWidthPct}% + 1px)`;
                            if (hasL || (!isLeft && slice.colspan > 1)) el.style.marginLeft = '-1px';
                        } else {
                            el.style.width = totalWidthPct + '%';
                        }

                        el.style.top = top + 'px'; el.style.height = h + 'px';
                        // [Fix] æ‰€æœ‰è‰²å—ä½¿ç”¨ç»Ÿä¸€çš„ z-indexï¼Œä¸ä¼šäº’ç›¸è¦†ç›–
                        el.style.zIndex = 10;
                        el.__data__ = { group: slice.group, style: slice.style, fragment: slice };

                        el.onmouseenter = () => {
                            if (!Core.state.focusedGroupId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.add('group-hovered'));
                                if (Core.state.features.connections) Core.render.drawConnections(slice.group, '#fff');
                                // [New] Highlight Header based on this block's region
                                if (slice.geoCode) Core.ui.highlightHeader(slice.geoCode);
                            }
                        };
                        el.onmouseleave = () => {
                            if (!Core.state.focusedGroupId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.remove('group-hovered'));
                                document.getElementById('connections-layer').innerHTML = '';
                                // [New] Clear Header Highlight
                                Core.ui.clearHeaderHighlight();
                            }
                        };

                        blocksFrag.appendChild(el);
                    });
                    document.getElementById('blocks-layer').appendChild(blocksFrag);

                    Core.render.drawLabels(colCount);
                },

                setupInteractions: function (renderArea, colCount) {
                    renderArea.onclick = (e) => {
                        if (e.target.closest('#selection-modal')) return;
                        let clickedBlock = e.target.closest('.era-block-fragment');
                        if (clickedBlock && clickedBlock.__data__) {
                            e.stopPropagation();
                            let d = clickedBlock.__data__;
                            Core.state.lastClickedGeoCode = d.fragment.geoCode;
                            Core.ui.setFocus(d.group.groupId);
                            Core.ui.showDetails(d.group, d.style);
                            return;
                        }
                        if (!e.target.closest('.era-label')) Core.ui.clearFocus();
                    };
                },

                // --- é‡æ„ç‰ˆ v2.0ï¼šä½¿ç”¨ LabelSystem è¿›è¡Œæ¸²æŸ“ ---
                drawLabels: function (colCount) {
                    let labelsFrag = document.createDocumentFragment();
                    let renderArea = document.getElementById('render-area');

                    // 1. æ¸…ç†æ—§æ ‡ç­¾
                    if (renderArea) {
                        const oldItems = renderArea.querySelectorAll('.era-label, .era-dot');
                        oldItems.forEach(el => el.remove());
                    }

                    let colWidthPx = renderArea.scrollWidth / colCount;
                    if (!colWidthPx || colWidthPx < 10) colWidthPx = 100;

                    // 2. è°ƒç”¨ LabelSystem è®¡ç®—æ‰€æœ‰ä½ç½®
                    const results = LabelSystem.computeAll(
                        Core.state.regimeGroups,
                        Core.state.regionIndexMap,
                        colWidthPx,
                        Core.state.zoom
                    );

                    // 3. æ¸²æŸ“ç»“æœ
                    results.forEach(item => {
                        const { group, x, y } = item;

                        // A. æˆåŠŸæ”¾ç½®æ–‡å­—æ ‡ç­¾
                        if (!item.failed) {
                            const { layout } = item;
                            const tier = parseInt(group.explicitTier) || 3;

                            let label = document.createElement('div');
                            let layoutClass = '';
                            if (layout.type === 'V') layoutClass = 'vertical-text';
                            if (layout.type === 'Wrap') layoutClass = 'label-wrap';

                            label.className = `era-label label-tier-${tier} ${group.groupId} ${layoutClass}`;
                            label.innerText = group.name;

                            // å±…ä¸­å®šä½
                            label.style.left = x + 'px';
                            label.style.top = y + 'px';

                            // å®½åº¦å¤„ç† (Wrap éœ€è¦å›ºå®šå®½ï¼ŒH/V è‡ªåŠ¨)
                            const finalW = (layout.type === 'Wrap') ? layout.w : 'auto';
                            label.style.width = (typeof finalW === 'number') ? (finalW + 'px') : finalW;

                            label.style.fontSize = layout.fs + 'px';
                            label.style.lineHeight = '1'; // ç´§å‡‘è¡Œé«˜

                            if (layout.type === 'H') label.style.whiteSpace = 'nowrap';
                            if (Core.state.focusedGroupId === group.groupId) label.classList.add('is-focused');

                            labelsFrag.appendChild(label);
                        }
                        // B. æ”¾ç½®å¤±è´¥ -> é™çº§ä¸ºå°åœ†ç‚¹
                        else {
                            let dotSize = 4;
                            // å¦‚æœæ˜¯ Tier 1/2 å¤±è´¥ï¼Œåœ†ç‚¹ç¨å¾®å¤§ä¸€ç‚¹
                            const tier = parseInt(group.explicitTier) || 3;
                            if (tier <= 2) dotSize = 6;

                            let dot = document.createElement('div');
                            dot.className = `era-dot ${group.groupId}`;
                            dot.style.cssText = `
                                position: absolute;
                                border-radius: 50%;
                                background: rgba(255,255,255,0.4);
                                cursor: help;
                                z-index: 3000;
                                transition: all 0.2s;
                                pointer-events: auto;
                            `;
                            dot.style.left = (x - dotSize / 2) + 'px';
                            dot.style.top = (y - dotSize / 2) + 'px';
                            dot.style.width = dotSize + 'px';
                            dot.style.height = dotSize + 'px';
                            dot.title = group.name; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºåå­—

                            dot.onmouseenter = () => {
                                dot.style.background = 'white';
                                dot.style.transform = 'scale(1.5)';
                                dot.style.boxShadow = '0 0 5px rgba(255,255,255,0.8)';
                            };
                            dot.onmouseleave = () => {
                                dot.style.background = 'rgba(255,255,255,0.4)';
                                dot.style.transform = 'scale(1)';
                                dot.style.boxShadow = 'none';
                            };
                            dot.onclick = (e) => {
                                e.stopPropagation();
                                Core.ui.setFocus(group.groupId);
                                Core.ui.showDetails(group, Core.getStyle(group));
                            };
                            labelsFrag.appendChild(dot);
                        }
                    });

                    // 4. æŒ‚è½½ DOM
                    const labelLayer = document.getElementById('labels-layer');
                    if (labelLayer) {
                        labelLayer.innerHTML = ''; // Ensure clear
                        labelLayer.appendChild(labelsFrag);
                    } else {
                        renderArea.appendChild(labelsFrag);
                    }
                },

                drawConnections: function (group, color) {
                    let svg = document.getElementById('connections-layer');
                    svg.innerHTML = '';
                    let rect = document.getElementById('render-area').getBoundingClientRect();
                    let colW = rect.width / Core.state.regions.length;
                    let points = [];
                    group.fragments.forEach(f => {
                        let idx = Core.state.regionIndexMap[f.geoCode]; if (idx === undefined) return;
                        let top = (f.start - APP_CONFIG.minYear) * Core.state.zoom;
                        let xOffset = f.left + (f.w / 2);
                        if (isNaN(xOffset)) xOffset = 0.5;
                        points.push({ x: (idx + xOffset) * colW, y: top + (f.end - f.start) * Core.state.zoom / 2 });
                    });
                    if (points.length < 2) return;
                    points.sort((a, b) => a.x - b.x);
                    let d = "M " + points[0].x + " " + points[0].y;
                    for (let i = 1; i < points.length; i++) { let p1 = points[i - 1], p2 = points[i]; let mx = (p1.x + p2.x) / 2; d += " C " + mx + " " + p1.y + ", " + mx + " " + p2.y + ", " + p2.x + " " + p2.y; }
                    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", d); path.setAttribute("class", "connection-path"); path.setAttribute("stroke", color);
                    svg.appendChild(path);
                }
            },

            ui: {
                // [New] Highlight Header based on Region Code
                highlightHeader: function (geoCode) {
                    if (!geoCode) return;
                    const idx = Core.state.regionIndexMap[geoCode];
                    if (idx !== undefined) {
                        const headerBody = document.getElementById('header-body');
                        if (headerBody && headerBody.children[idx]) {
                            const target = headerBody.children[idx];
                            const old = headerBody.querySelector('.active-header');
                            if (old && old !== target) old.classList.remove('active-header');
                            target.classList.add('active-header');
                        }
                    }
                },
                clearHeaderHighlight: function () {
                    const headerBody = document.getElementById('header-body');
                    if (headerBody) {
                        const old = headerBody.querySelector('.active-header');
                        if (old) old.classList.remove('active-header');
                    }
                },

                closePanel: function () {
                    document.getElementById('editor-panel').classList.remove('panel-open');
                    Core.ui.clearFocus();
                },
                setFocus: function (groupId) {
                    if (Core.state.focusedGroupId === groupId) { Core.ui.clearFocus(); return; }
                    Core.state.focusedGroupId = groupId;
                    document.body.classList.add('mode-focus');
                    document.querySelectorAll('.group-hovered').forEach(el => el.classList.remove('group-hovered'));
                    document.querySelectorAll('.is-focused').forEach(el => el.classList.remove('is-focused'));
                    document.querySelectorAll('.' + groupId).forEach(el => el.classList.add('is-focused'));

                    const group = Core.state.regimeGroups.find(g => g.groupId === groupId);
                    if (group) Core.render.drawConnections(group, '#fff');

                    // [Fix] Remove clone logic. CSS z-index (2500) is sufficient now that header is 4000.
                    // This fixes the "floating ghost label" bug on scroll.
                },
                clearFocus: function () {
                    Core.state.focusedGroupId = null;
                    document.body.classList.remove('mode-focus');

                    // Restore original styles
                    document.querySelectorAll('.is-focused').forEach(el => {
                        el.classList.remove('is-focused');
                    });
                    document.getElementById('connections-layer').innerHTML = '';
                },
                showDetails: function (group, style) {
                    const panel = document.getElementById('editor-panel');
                    if (!panel) return;

                    panel.classList.remove('panel-right', 'panel-left');
                    const totalCols = Core.state.regions.length;
                    const centerRatio = (group.centerCol || 0) / totalCols;
                    panel.classList.add(centerRatio > 0.5 ? 'panel-left' : 'panel-right');
                    requestAnimationFrame(() => panel.classList.add('panel-open'));

                    // 1. éå†æ‰€æœ‰ç‰‡æ®µï¼Œæ”¶é›†è¯¥æ”¿æƒå†å²ä¸Šæ‰€æœ‰çš„å®—ä¸»å…³ç³»
                    const uniqueSuzerains = new Set();

                    group.fragments.forEach(f => {
                        if (!f.suzerain) {
                            uniqueSuzerains.add("æ— ");
                        }
                        else if (f.suzerainName) {
                            let txt = f.suzerainName;

                            // æƒ…å†µ A: V|J åŒé‡å…³ç³»
                            if (f.suzerainType === 'V|J' && txt.includes('|')) {
                                const parts = txt.split('|');
                                const nameV = parts[0];
                                const nameJ = parts[1] || parts[0];
                                txt = `${nameJ} (ç¾ç¸») & ${nameV} (è—©å±)`;
                            }
                            // æƒ…å†µ B: å•ä¸€å…³ç³»
                            else if (f.suzerainType) {
                                const typeMap = { 'V': 'è—©å±', 'J': 'ç¾ç¸»' };
                                const typeName = typeMap[f.suzerainType] || f.suzerainType;
                                txt = `${txt} (${typeName})`;
                            }

                            uniqueSuzerains.add(txt);
                        }
                    });

                    // 2. ç”Ÿæˆ HTML (ä¿æŒåŸé€»è¾‘ä¸å˜)
                    let suzerainHtml = '';
                    const hasOverlay = Array.from(uniqueSuzerains).some(s => s !== "æ— ");

                    if (hasOverlay) {
                        const list = Array.from(uniqueSuzerains).join(' <span style="color:var(--slate-500)">/</span> ');
                        suzerainHtml = `<div class="suzerain-tag">å®—ä¸»: ${list}</div>`;
                    }

                    const f0 = group.fragments[0];
                    const typeMap = { 'C': 'ä¸­åŸ', 'Q': 'å¾æœ', 'R': 'å‰²æ®', 'N': 'éƒ¨æ—', 'F': 'è¾¹ç–†', 'T': 'è¿‡æ¸¡', 'V': 'è—©å±' };
                    const typeLabel = typeMap[group.regimeCode.charAt(0)] || 'æœªçŸ¥';

                    let originLabel = f0.geoCode;
                    const originRegion = Core.state.rawRegions.find(r => r.id == f0.geoCode);
                    if (originRegion) originLabel = originRegion.label;

                    let detailHtml = '';
                    const fragsByGeo = {};
                    group.fragments.forEach(f => {
                        if (!fragsByGeo[f.geoCode]) fragsByGeo[f.geoCode] = [];
                        fragsByGeo[f.geoCode].push(f);
                    });

                    const sortedGeoCodes = Object.keys(fragsByGeo).sort((a, b) =>
                        (Core.state.regionIndexMap[a] || 0) - (Core.state.regionIndexMap[b] || 0)
                    );

                    const totalDur = Math.max(group.maxEnd - group.minStart, 1);

                    sortedGeoCodes.forEach(geoCode => {
                        const frags = fragsByGeo[geoCode];
                        frags.sort((a, b) => a.start - b.start);

                        let barsHtml = '';
                        let timeTexts = [];

                        // ä½¿ç”¨ç´¢å¼• i æ¥å¢åŠ  z-index
                        frags.forEach((f, i) => {
                            const left = ((f.start - group.minStart) / totalDur) * 100;
                            const width = ((f.end - f.start) / totalDur) * 100;
                            // [Fix] Use inline styles instead of Tailwind classes
                            barsHtml += `<div style="position:absolute; top:0; left:${left}%; width:${width}%; height:100%; background:${style.bg || '#888'}; opacity:0.9; border-radius:1px; min-width:3px; z-index:${10 + i};"></div>`;
                            timeTexts.push(`${f.start}~${f.end}`);
                        });

                        const regionName = Core.state.rawRegions.find(r => r.id == geoCode)?.label || geoCode;
                        const isCurrent = Core.state.lastClickedGeoCode == geoCode;

                        const rowClass = isCurrent ? 'active-row' : '';
                        const nameClass = isCurrent ? 'active-name' : '';
                        const icon = isCurrent ? 'ğŸ‘‰ ' : '';
                        const timeStr = timeTexts.join(', ');

                        detailHtml += `<div class="region-row ${rowClass}">
                            <div class="region-name ${nameClass}" title="${regionName}">${icon}${regionName}</div>
                            <div class="bar-container">${barsHtml}</div>
                            <div class="time-text" title="${timeStr}">${timeStr}</div>
                        </div>`;
                    });

                    // --- [æ–°å¢é€»è¾‘] å¤„ç†æ ‡é¢˜æ æŒ‰é’® ---
                    const targetGeo = Core.state.lastClickedGeoCode || (sortedGeoCodes.length > 0 ? sortedGeoCodes[0] : null);

                    // æ„å»ºè·³è½¬å‚æ•°å¯¹è±¡
                    const jumpPayload = {
                        target: 'map',
                        params: {
                            region: targetGeo,
                            year: group.minStart + 1,
                            regime: group.name
                        }
                    };

                    // è·å–å¹¶æ¿€æ´»æ ‡é¢˜æ æŒ‰é’®
                    const jumpBtn = document.getElementById('btn-jump-map-header');
                    if (jumpBtn) {
                        jumpBtn.classList.add('active-btn'); // æ˜¾ç¤º (CSS Controlled)
                        // ç§»é™¤æ—§ç›‘å¬å™¨ (é€šè¿‡å…‹éš†èŠ‚ç‚¹æ›¿æ¢)
                        const newBtn = jumpBtn.cloneNode(true);
                        jumpBtn.parentNode.replaceChild(newBtn, jumpBtn);

                        // ç»‘å®šæ–°äº‹ä»¶
                        newBtn.onclick = () => {
                            window.parent.postMessage({ type: "REQUEST_SWITCH", payload: jumpPayload }, window.location.origin);
                        };
                    }

                    // --- [æ›´æ–°æ¸²æŸ“] ç§»é™¤å†…å®¹åŒºçš„å¤§æŒ‰é’® ---
                    document.getElementById('editor-content').innerHTML = `
                        <div class="regime-card" style="background: ${style.bg}; color: ${style.text};">
                            <h3 class="regime-card-title">${group.name}</h3>
                            
                            <div class="regime-info-row">
                                <span class="info-badge" title="Regime Code">Code: ${group.regimeCode}</span>
                                <span class="info-badge" title="Tier Level">Tier: ${group.explicitTier}</span>
                                <span class="info-badge" title="æ”¿æƒç±»å‹">Type: ${typeLabel}</span>
                                <span class="info-badge" title="èµ·æºåŒºåŸŸ">Origin: ${originLabel}</span>
                            </div>

                            ${suzerainHtml}
                        </div>
                        
                        <div class="section-box details-gap">
                             <h4 class="section-title">ç»Ÿè¾–åŒºåŸŸ (${sortedGeoCodes.length})</h4>
                             <div class="custom-scrollbar" style="max-height:300px; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">${detailHtml}</div>
                        </div>
                    `;
                },
                populateSearchResults: function (term) {
                    const container = document.getElementById('search-results');
                    if (!term || term.length < 1) { container.style.display = 'none'; return; }

                    const seen = new Set();
                    const results = Core.state.regimeGroups.filter(g => {
                        if (g.name.toLowerCase().includes(term) && !seen.has(g.name)) { seen.add(g.name); return true; }
                        return false;
                    }).slice(0, 10);

                    if (results.length === 0) { container.style.display = 'none'; return; }

                    container.innerHTML = '';
                    results.forEach(g => {
                        const div = document.createElement('div');
                        div.className = 'search-item';
                        div.innerHTML = `<span>${g.name}</span> <span style="font-size:9px; color:var(--slate-500); margin-left:0.5rem">(${g.minStart})</span>`;
                        div.onclick = () => {
                            this.jumpToRegime(g);
                            document.getElementById('search-input').value = '';
                            container.style.display = 'none';
                            document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));
                        };
                        container.appendChild(div);
                    });
                    container.style.display = 'block';
                },
                jumpToRegime: function (group) {
                    const targetY = (group.minStart - APP_CONFIG.minYear) * Core.state.zoom;
                    const renderArea = document.getElementById('render-area');
                    const colWidth = renderArea.scrollWidth / Core.state.regions.length;
                    const targetX = (group.centerCol + 0.5) * colWidth;

                    document.getElementById('main-content').scrollTo({ top: targetY - 100, left: targetX - window.innerWidth / 2, behavior: 'smooth' });
                    setTimeout(() => {
                        Core.ui.setFocus(group.groupId);
                        Core.ui.showDetails(group, Core.getStyle(group));
                    }, 500);
                }
            },

            toggleFeature: function (f) {
                this.state.features[f] = !this.state.features[f];
                document.getElementById('btn-' + f).classList.toggle('active');
                if (f === 'connections') this.render.drawAll();
            }
        };

        const collisionMgr = { rects: [], add: function (x, y, w, h, tier) { const n = { l: x + 1, t: y + 1, r: x + w - 1, b: y + h - 1 }; if (tier <= 1) { this.rects.push(n); return true; } for (let r of this.rects) if (n.l < r.r && n.r > r.l && n.t < r.b && n.b > r.t) return false; this.rects.push(n); return true; }, reset: function () { this.rects = [] } };

        document.addEventListener('DOMContentLoaded', () => Core.init());
        // [Sync] æš´éœ²ç»™çˆ¶çº§çš„åŒæ­¥ API
        window.getCenterYear = function () {
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return 2025;
            const zoom = Core.state.zoom || 1.5;
            // è®¡ç®—ä¸­å¿ƒç‚¹å¯¹åº”çš„å¹´ä»½ï¼š APP_CONFIG.minYear + (scrollTop + clientH/2) / zoom
            const midPx = el.scrollTop + (el.clientHeight / 2);
            const year = APP_CONFIG.minYear + (midPx / zoom);
            return Math.round(year);
        };

        window.scrollToYear = function (year) {
            if (typeof year !== 'number' || isNaN(year)) return;
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return;

            const zoom = Core.state.zoom || 1.5;
            const targetPx = (year - APP_CONFIG.minYear) * zoom;
            const centerOffset = el.clientHeight / 2;
            el.scrollTo({ top: targetPx - centerOffset, behavior: 'auto' }); // auto æ›´å¿«ï¼Œsmooth å¯èƒ½æœ‰å»¶è¿Ÿ
        };
    </script>
</body>

</html>