<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂÖ®ÊôØÈ°µ v11.06</title>

    <!-- üîë ÂÖ®Â±ÄÁâàÊú¨ÊéßÂà∂ -->
    <script>
        window.APP_VERSION = '2026.01.07.002';
    </script>

    <!-- [Unified CSS] Native Style (Merged) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@500;700;900&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <style id="dynamic-styles"></style>

    <style>
        /* =========================================
           EastAsia History - Standard Styles (v1.0)
           Replaces Tailwind CSS with native CSS
           ========================================= */

        :root {
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --slate-950: #020617;

            --blue-300: #93c5fd;
            --blue-400: #60a5fa;
            --blue-500: #3b82f6;
            --blue-600: #2563eb;

            --amber-300: #fcd34d;
            --amber-500: #f59e0b;
        }

        /* --- Âü∫Á°ÄËÆæÁΩÆ --- */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: var(--slate-900);
            color: var(--slate-300);
            font-family: 'Inter', -apple-system, sans-serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .pano-body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
            background: var(--slate-950);
        }

        #main-content {
            position: relative;
            width: 100%;
            height: calc(100% - 3rem);
            overflow: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            z-index: 1;
            will-change: scroll-position;
        }

        #chart-container {
            position: relative;
            min-width: 1400px;
            display: block;
            contain: layout;
        }

        /* --- Sticky Â∏ÉÂ±Ä --- */
        #sticky-header-row {
            position: sticky;
            top: 0;
            z-index: 4000;
            /* [Fix] Raise above labels (which are 2000+3000) */
            display: flex;
            height: 2.5rem;
            border-bottom: 1px solid var(--slate-700);
            background-color: var(--slate-900);
        }

        #header-corner {
            position: sticky;
            left: 0;
            z-index: 4100;
            /* [Fix] Topmost corner */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
        }

        #header-body {
            flex: 1;
            display: flex;
            background-color: var(--slate-900);
            position: relative;
        }

        #chart-body-row {
            display: flex;
            position: relative;
        }

        .sticky-ticks {
            position: sticky;
            left: 0;
            z-index: 3900;
            /* [Fix] High enough but below header */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
        }

        #render-area {
            flex: 1;
            position: relative;
            background-color: var(--slate-900);
            overflow: hidden;
        }

        /* --- Crosshair (ËçßÂÖâÁ∫ø) --- */
        #crosshair-line {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 50, 50, 1);
            box-shadow: 0 0 20px rgba(255, 50, 50, 1), 0 0 40px rgba(255, 50, 50, 0.8), 0 0 6px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1000;
        }

        #crosshair-label {
            display: none;
            position: absolute;
            left: 0.5rem;
            transform: translateY(-50%);
            background: rgba(220, 50, 50, 0.95);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1001;
            font-family: monospace;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Block Styles --- */
        .era-block-fragment {
            position: absolute;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            z-index: 10;
            box-sizing: border-box;
            transition: transform 0.1s ease, opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), filter 0.4s ease;
        }

        .no-border-left {
            border-left: none !important;
        }

        .no-border-right {
            border-right: none !important;
        }

        /* [Fix] Removed conflicting internal hover styles. Rely on SHARED_CSS_STYLES from index.html */

        /* --- Focus Mode --- */
        body.mode-focus .era-block-fragment:not(.is-focused) {
            opacity: 0.08 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
            border-color: transparent !important;
        }

        body.mode-focus .era-block-fragment.is-focused {
            opacity: 1 !important;
            filter: none !important;
            /* [Fix] Do not raise Z-Index above context limit. Just rely on labels-layer being higher. */
            z-index: 50 !important;
            /* [Fix] ÁßªÈô§ÁôΩËâ≤ËæπÊ°Ü */
            box-shadow: none !important;
            transform: none;
        }

        /* --- Dots Focus Mode --- */
        body.mode-focus .era-dot:not(.is-focused) {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
        }

        body.mode-focus .era-dot.is-focused {
            opacity: 1 !important;
            filter: none !important;
            transform: scale(1.3);
            /* [Fix] ÁßªÈô§ÁôΩËâ≤ËæπÊ°Ü */
            box-shadow: none;
        }

        .era-dimmed {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none;
        }

        /* --- Labels --- */
        .era-label {
            position: absolute;
            z-index: 60;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            transform: translate(-50%, -50%);
            line-height: 1.1;
            text-shadow: -1px -1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
            transition: opacity 0.4s, filter 0.4s, transform 0.3s;
        }

        body.mode-focus .era-label:not(.is-focused) {
            opacity: 0.1 !important;
            filter: blur(1px) grayscale(50%) !important;
            z-index: 60;
        }

        /* [Fix] Label È´ò‰∫Æ */
        body.mode-focus .era-label.is-focused {
            opacity: 1 !important;
            filter: none !important;
            z-index: 9000 !important;
            /* Context ÂÜÖÁΩÆÈ°∂ */
            transform: translate(-50%, -50%) scale(1.1);
            /* [Fix] Á°Æ‰øùÊó†ÁôΩËâ≤ËæπÊ°Ü */
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        /* [Fix] Progress Bar Style Override */
        .bar-container div {
            min-width: 4px;
            /* Èò≤Ê≠¢ËøáÁ™Ñ‰∏çÂèØËßÅ */
            height: 100% !important;
            top: 0 !important;
            bottom: 0;
        }

        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 1px;
        }

        .label-wrap {
            white-space: normal !important;
            word-break: break-word;
            line-height: 1.2 !important;
        }

        /* [v2.0] H2 ‰∏§Ë°åÊ®™ÊéíÂ∏ÉÂ±Ä */
        .label-h2 {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            line-height: 1.2 !important;
        }

        .label-h2 span {
            display: block;
        }

        .label-tier-1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-weight: 400;
            letter-spacing: 2px;
            z-index: 70;
        }

        .label-tier-2 {
            font-family: 'Noto Serif SC', serif;
            font-weight: 900;
            z-index: 65;
        }

        .label-tier-3 {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            z-index: 60;
        }

        /* --- Panel & Modals --- */
        /* Editor Panel (Replaces Tailwind classes) */
        #editor-panel {
            position: fixed;
            top: 3rem;
            bottom: 0;
            width: 100%;
            z-index: 400;
            display: flex;
            flex-direction: column;
            background-color: rgba(15, 23, 42, 0.95);
            /* slate-900/95 */
            backdrop-filter: blur(12px);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (min-width: 640px) {
            #editor-panel {
                width: 24rem;
            }
        }

        .panel-right {
            right: 0;
            border-left: 1px solid var(--slate-700);
            transform: translateX(100%);
        }

        .panel-left {
            left: 0;
            border-right: 1px solid var(--slate-700);
            transform: translateX(-100%);
        }

        .panel-open {
            transform: translateX(0) !important;
        }

        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--slate-700);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.5);
        }

        .panel-title {
            font-weight: bold;
            color: var(--blue-400);
        }

        .panel-close-btn {
            color: var(--slate-400);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border: none;
        }

        .panel-close-btn:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .jump-btn {
            display: none;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            background-color: var(--blue-600);
            color: white;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            border: 1px solid rgba(96, 165, 250, 0.5);
            cursor: pointer;
        }

        .jump-btn:hover {
            background-color: var(--blue-500);
        }

        .jump-btn.active-btn {
            display: flex;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        /* Selection Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 9999;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--slate-900);
            border: 1px solid var(--slate-700);
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 24rem;
            overflow: hidden;
        }

        .modal-header {
            padding: 0.75rem;
            border-bottom: 1px solid var(--slate-800);
            background-color: rgba(30, 41, 59, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-400);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .modal-close {
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            color: var(--slate-500);
            cursor: pointer;
            border: none;
            background: transparent;
        }

        .modal-close:hover {
            color: white;
            background-color: var(--slate-700);
        }

        /* --- JS Dynamic Elements Utilities --- */
        .header-col-label {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(51, 65, 85, 0.3);
            /* slate-700/30 */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 2px;
            font-size: 10px;
            cursor: help;
            color: var(--slate-400);
            line-height: 1.25;
            word-break: break-word;
            white-space: normal;
        }

        .header-col-label:hover,
        .header-col-label.active-header {
            color: var(--blue-400);
            background: rgba(255, 255, 255, 0.1);
            z-index: 50;
        }


        .timeline-tick-label {
            position: absolute;
            width: 100%;
            text-align: center;
            /* [Fix] Â±Ö‰∏≠ÂØπÈΩê */
            padding: 0 0.25rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            /* [Fix] Â±Ö‰∏≠ÂØπÈΩê */
            line-height: 1;
            font-size: 11px;
            /* [Fix] Â≠óÂè∑Á®çÂ§ß */
            font-weight: bold;
            /* [Fix] Âä†Á≤ó */
            color: var(--slate-400);
            /* [Fix] Á®ç‰∫Æ‰∏ÄÁÇπ */
            font-family: monospace;
            height: 0;
        }

        .suzerain-tag {
            margin-top: 0.5rem;
            font-size: 11px;
            color: var(--amber-300);
            border: 1px solid rgba(245, 158, 11, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-block;
            line-height: 1.6;
        }

        /* Modal Animation (Êõø‰ª£ Tailwind animate-in fade-in zoom-in) */
        .modal-content {
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Details Gap */
        .details-gap {
            margin-top: 1rem;
        }

        /* Detail Panel Elements */
        .regime-card {
            padding: 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .regime-card-title {
            font-size: 1.875rem;
            font-weight: 900;
            position: relative;
            z-index: 10;
            font-family: serif;
            margin: 0;
        }

        .regime-info-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0.9;
            font-size: 0.75rem;
            z-index: 10;
            position: relative;
            font-family: monospace;
        }

        .info-badge {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0 0.25rem;
            border-radius: 0.25rem;
        }

        .section-box {
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--slate-700);
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--slate-700);
            padding-bottom: 0.5rem;
        }

        .region-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 1.5rem;
            padding: 0 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            transition: background 0.2s;
            font-size: 10px;
            color: var(--slate-300);
        }

        .region-row:hover {
            background-color: rgba(51, 65, 85, 0.3);
        }

        .region-row.active-row {
            background-color: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .region-name {
            width: 5rem;
            text-align: right;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .region-name.active-name {
            color: var(--blue-300);
        }

        .bar-container {
            flex: 1;
            height: 0.5rem;
            background-color: rgba(51, 65, 85, 0.5);
            border-radius: 0.25rem;
            position: relative;
            overflow: hidden;
        }

        .time-text {
            width: 6rem;
            font-family: monospace;
            font-size: 9px;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Search Results */
        #search-results {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--slate-800);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            max-height: 300px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            width: 240px;
        }

        .search-item {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--slate-700);
            transition: background 0.15s;
            color: var(--slate-300);
            font-size: 0.75rem;
        }

        .search-item:hover {
            background: var(--slate-700);
        }
    </style>
</head>

<body class="pano-body">

    <div id="editor-panel" class="panel-right">
        <div class="panel-header">
            <h2 class="panel-title">üìú ÊîøÊùÉËØ¶ÊÉÖ</h2>

            <div style="display:flex; gap:0.5rem; align-items:center;">
                <button id="btn-jump-map-header" class="jump-btn">
                    <span>üó∫Ô∏è</span> Êü•ÁúãÂéÜÂè≤Âú∞Âõæ
                </button>
                <button id="btn-close-panel" class="panel-close-btn">‚úï</button>
            </div>
        </div>
        <div class="custom-scrollbar" id="editor-content" style="padding:1.25rem; overflow-y:auto; flex:1;"></div>
    </div>

    <div id="selection-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ËØ∑ÈÄâÊã©ÊîøÊùÉ</span>
                <button id="btn-close-modal" class="modal-close">‚úï</button>
            </div>
            <div id="selection-list" class="custom-scrollbar"
                style="padding:0.5rem; max-height:60vh; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="chart-container">
            <div id="sticky-header-row">
                <div id="header-corner">
                    <button id="btn-flip-cols" title="ÁøªËΩ¨Âú∞Âå∫Âàó"
                        style="width:100%; height:100%; border:none; background:transparent; color:var(--slate-500); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; transition:color 0.2s;">
                        ‚áÑ
                    </button>
                </div>
                <div id="header-body"></div>
            </div>
            <div id="chart-body-row">
                <div id="ticks-layer" class="sticky-ticks">
                    <div id="crosshair-label"></div>
                </div>
                <div id="render-area">
                    <div id="crosshair-line"></div>
                    <svg id="connections-layer" width="100%" height="100%"></svg>
                    <div id="blocks-layer" style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:10;">
                    </div>
                    <div id="labels-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:2000; pointer-events:none;">
                    </div>
                    <div id="grid-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:0; pointer-events:none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ‰ªéÁà∂Á∫ßËé∑ÂèñÂπ¥‰ªΩÈÖçÁΩÆÔºåÂ¶ÇÊûúÁà∂Á∫ß‰∏çÂèØÁî®Âàô‰ΩøÁî®Êú¨Âú∞ÈªòËÆ§ÂÄº
        const TIME_CONFIG = window.parent?.GLOBAL_CONFIG?.TIME || {
            minYear: -2100, // Ê≥®ÊÑè: GLOBAL_CONFIG Áî®Â§ßÂÜô key, ËøôÈáå fallback Áî®Â§ßÂÜô
            maxYear: 2025
        };

        // [New] Logger Bridge: Forward logs to parent console
        if (window.parent && window.parent.console) {
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            console.log = function (...args) {
                originalLog.apply(console, args);
                try { window.parent.console.log("[Pano]", ...args); } catch (e) { }
            };
            console.warn = function (...args) {
                originalWarn.apply(console, args);
                try { window.parent.console.warn("[Pano]", ...args); } catch (e) { }
            };
            console.error = function (...args) {
                originalError.apply(console, args);
                try { window.parent.console.error("[Pano]", ...args); } catch (e) { }
            };
            window.onerror = function (msg, source, line, col, error) {
                try { window.parent.console.error(`[Pano] Uncaught: ${msg} @ ${line}`); } catch (e) { }
            };
        }

        const APP_CONFIG = {
            minYear: TIME_CONFIG.MIN_YEAR || -2100,
            maxYear: TIME_CONFIG.MAX_YEAR || 2025
        };

        // Historical Perspectives Configuration
        const PERSPECTIVES = {
            default: {
                name: "ÈªòËÆ§Â∏ÉÂ±Ä",
                isDefault: true
            },

            songLiaoJin: {
                name: "ÂÆãËæΩÈáëÊó∂Êúü",
                coreRegimes: [
                    "ÂåóÂÆã|C5100",
                    "ÂçóÂÆã|R5110",
                    "ËæΩ|Q5700",
                    "Èáë|Q5710"
                ],
                weights: {
                    intraRegime: 100,    // Same regime regions
                    interRegime: 30,     // Different core regime regions
                    background: 0.1      // Background regions
                }
            }
        };

        // --- New Label System Modules (v2.0 Refactor) ---

        /**
         * Á©∫Èó¥Á¥¢ÂºïÁ±ª - ‰ΩøÁî® Dynamic Grid (Spatial Hash) ‰ºòÂåñÁ¢∞ÊíûÊ£ÄÊµã
         * Áõ∏ÊØî QuadTreeÔºåGrid Êõ¥ÁÆÄÂçï‰∏îÂú®Áâ©‰ΩìÂàÜÂ∏ÉÂùáÂåÄÊó∂ÊÄßËÉΩÊûÅ‰Ω≥
         */
        class SpatialIndex {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map(); // key: "x_y", value: [items]
                this.items = []; // keep track of all items
            }

            _getKey(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx}_${gy}`;
            }

            _getKeysForRect(rect) {
                const keys = [];
                const startX = Math.floor(rect.x / this.cellSize);
                const endX = Math.floor((rect.x + rect.w) / this.cellSize);
                const startY = Math.floor(rect.y / this.cellSize);
                const endY = Math.floor((rect.y + rect.h) / this.cellSize);

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        keys.push(`${x}_${y}`);
                    }
                }
                return keys;
            }

            insert(item) {
                // item must have {x, y, w, h}
                if (!item._sid) item._sid = Math.random().toString(36).substr(2, 9);

                this.items.push(item);
                const keys = this._getKeysForRect(item);
                keys.forEach(k => {
                    if (!this.grid.has(k)) this.grid.set(k, []);
                    this.grid.get(k).push(item);
                });
            }

            // ËøîÂõûÊâÄÊúâ‰∏é rect ÈáçÂè†ÁöÑ items
            query(rect) {
                const keys = this._getKeysForRect(rect);
                const candidates = new Set();

                // 1. Gather candidates
                keys.forEach(k => {
                    const cellItems = this.grid.get(k);
                    if (cellItems) {
                        for (let i = 0; i < cellItems.length; i++) {
                            candidates.add(cellItems[i]);
                        }
                    }
                });

                // 2. Precise check
                const result = [];
                candidates.forEach(item => {
                    if (this._intersects(rect, item)) {
                        result.push(item);
                    }
                });
                return result;
            }

            _intersects(a, b) {
                return a.x < b.x + b.w &&
                    a.x + a.w > b.x &&
                    a.y < b.y + b.h &&
                    a.y + a.h > b.y;
            }

            clear() {
                this.grid.clear();
                this.items = [];
            }
        }

        /**
         * LabelSystem - Ë¥üË¥£Êñ∞ÁöÑÊ†áÁ≠æÂ∏ÉÂ±ÄËÆ°ÁÆóÈÄªËæë
         * [v2.0] Â¢ûÂº∫ÁâàÔºöËæπÁïåÁ∫¶Êùü + Êô∫ËÉΩÊñπÂêëÈÄâÊã© + H2‰∏§Ë°åÂ∏ÉÂ±Ä
         */
        const LabelSystem = {
            index: null, // SpatialIndex instance

            init() {
                // ÂçïÂÖÉÊ†ºÂ§ßÂ∞èËÆæ‰∏∫ 128pxÔºåÈÄÇÂêàÂ∏∏ËßÑÊ†áÁ≠æÂ∞∫ÂØ∏
                this.index = new SpatialIndex(128);
            },

            /**
             * [New] Step 1: ËÆ°ÁÆóÊîøÊùÉÊâÄÊúâÁâáÊÆµÁöÑÂÆåÊï¥ËæπÁïåÊ°Ü (BoundingBox)
             * Áî®‰∫éÔºöËæπÁïåÁ∫¶ÊùüÊ£ÄÊü•„ÄÅÊñπÂêëÂÅèÂ•ΩÂà§Êñ≠
             * @param {Object} group ÊîøÊùÉÁªÑ
             * @param {Number} colWidth ÂàóÂÆΩ(ÂÉèÁ¥†)
             * @param {Number} zoom Áº©ÊîæÂÄçÁéá
             * @returns {Object} { x, y, w, h } ËæπÁïåÊ°ÜÔºàÂÉèÁ¥†ÂùêÊ†áÔºâ
             */
            calculateBoundingBox(group, colWidth, zoom) {
                const slices = group.visualSlices || [];
                if (slices.length === 0) {
                    return { x: 0, y: 0, w: 0, h: 0 };
                }

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                slices.forEach(slice => {
                    // ËÆ°ÁÆóÁâáÊÆµÁöÑÂ∑¶ËæπÁïåÔºàÂÉèÁ¥†Ôºâ
                    const left = (slice.cIdx + slice.left) * colWidth;
                    // ËÆ°ÁÆóÁâáÊÆµÁöÑÂè≥ËæπÁïåÔºàÂÉèÁ¥†Ôºâ
                    const right = left + slice.w * colWidth;
                    // ËÆ°ÁÆóÁâáÊÆµÁöÑ‰∏äËæπÁïåÔºàÂÉèÁ¥†ÔºåÂπ¥‰ªΩËΩ¨Êç¢Ôºâ
                    const top = (slice.start - APP_CONFIG.minYear) * zoom;
                    // ËÆ°ÁÆóÁâáÊÆµÁöÑ‰∏ãËæπÁïåÔºàÂÉèÁ¥†Ôºâ
                    const bottom = (slice.end - APP_CONFIG.minYear) * zoom;

                    minX = Math.min(minX, left);
                    maxX = Math.max(maxX, right);
                    minY = Math.min(minY, top);
                    maxY = Math.max(maxY, bottom);
                });

                return {
                    x: minX,
                    y: minY,
                    w: maxX - minX,
                    h: maxY - minY
                };
            },

            /**
             * [v2.0] Step 2 & 3: ÁîüÊàêÊ†áÁ≠æÂÄôÈÄâÊñπÊ°à
             * ÊîπËøõÁÇπÔºö
             * - ‰ΩøÁî® bboxÔºàËÄåÈùû posÔºâÂà§Êñ≠ÊñπÂêëÂÅèÂ•Ω
             * - ‰ΩøÁî® bestSlice ÁöÑÂ∞∫ÂØ∏ËÆ°ÁÆóÂ≠óÂè∑ÔºàÊõ¥Á≤æÁ°ÆÔºâ
             * - ÁÆÄÂåñ‰∏∫‰∏âÁßçÂ∏ÉÂ±ÄÁ±ªÂûãÔºöH(Ê®™Êéí)„ÄÅV(Á´ñÊéí)„ÄÅH2(Ê®™Êéí‰∏§Ë°å)
             * 
             * @param {Object} group ÊîøÊùÉÁªÑ
             * @param {Object} bbox ËæπÁïåÊ°Ü {x, y, w, h}ÔºàÁî®‰∫éÊñπÂêëÂÅèÂ•ΩÔºâ
             * @param {Object} pos ‰ΩçÁΩÆ‰ø°ÊÅØ
             * @param {Object} bestSlice ÊúÄÂ§ßÁâáÊÆµÔºàÁî®‰∫éÁ≤æÁ°ÆÂ≠óÂè∑ËÆ°ÁÆóÔºâ
             * @param {Number} zoom Áº©ÊîæÂÄçÁéá
             */
            generateCandidates(group, bbox, pos, bestSlice, zoom) {
                const tier = parseInt(group.explicitTier) || 3;
                const txt = group.name;
                const len = txt.length;

                // Âü∫Á°ÄÂ∞∫ÂØ∏ÈôêÂà∂ÔºàÊ†πÊçÆ TierÔºâ
                let minFS = 10, maxFS = 16;
                if (tier === 1) { minFS = 20; maxFS = 60; }
                else if (tier === 2) { minFS = 12; maxFS = 28; }

                const candidates = [];

                // [Fix v4] Â≠óÂè∑ËÆ°ÁÆóÂü∫ÂáÜÔºö
                // - Tier 1Ôºö‰ΩøÁî® bestSlice Âíå bbox ÁöÑÊ∑∑ÂêàÔºà60%Ôºâ
                // - Tier 2Ôºö‰ΩøÁî® bestSlice ‰∏∫‰∏ªÔºàÊõ¥‰øùÂÆàÔºâ
                // - Tier 3Ôºö‰ΩøÁî® bestSliceÔºàÂÆûÈôÖÁâáÊÆµÔºâ
                let sliceW, sliceH;
                const bsW = bestSlice ? bestSlice.w : bbox.w;
                const bsH = bestSlice ? (bestSlice.h * zoom) : bbox.h;

                if (tier === 1) {
                    // Â§ßÊúù‰ª£Ôºö‰ΩøÁî® bestSlice Âíå bbox ÁöÑÊ∑∑ÂêàÔºàËá≥Â∞ë 60% bboxÔºâ
                    sliceW = Math.min(bbox.w, Math.max(bsW, bbox.w * 0.6));
                    sliceH = Math.min(bbox.h, Math.max(bsH, bbox.h * 0.6));
                } else if (tier === 2) {
                    // ‰∏≠Á≠âÊîøÊùÉÔºö‰ª• bestSlice ‰∏∫‰∏ªÔºå‰ΩÜÂÖÅËÆ∏ÈÄÇÂ∫¶ÊîæÂ§ßÔºàÊúÄÂ§öÂà∞ bbox ÁöÑ 40%Ôºâ
                    sliceW = Math.min(bbox.w, Math.max(bsW, bbox.w * 0.4));
                    sliceH = Math.min(bbox.h, Math.max(bsH, bbox.h * 0.4));
                } else {
                    // Â∞èÊîøÊùÉÔºöÁõ¥Êé•‰ΩøÁî® bestSlice
                    sliceW = bsW;
                    sliceH = bsH;
                }

                // ‰ΩÜ‰ªç‰ΩøÁî® bbox Êù•Âà§Êñ≠Êï¥‰ΩìÁöÑÊñπÂêëÂÅèÂ•Ω
                const boxW = bbox.w;
                const boxH = bbox.h;

                // ========== ÊñπÂêëÂÅèÂ•ΩÂà§Êñ≠ ==========
                const ratio = boxH / boxW;

                // [Fix] Èôç‰ΩéÁ´ñÊéíÈòàÂÄºÔºöratio > 1.0 Â∞±ÂÅèÂ•ΩÁ´ñÊéíÔºàÊõ¥ÊïèÊÑüÔºâ
                const isNarrowTall = ratio > 1.0;

                // Âº∫Âà∂Á´ñÊéíÊù°‰ª∂ÔºöÈùûÂ∏∏Á™ÑÈ´ò (ratio > 2.0)
                const mustBeVertical = ratio > 2.0;

                // Êù°‰ª∂2: Ëâ≤ÂùóÂÆΩÂ∫¶Â§™Á™ÑÔºåÊ®™ÊéíÊîæ‰∏ç‰∏ã
                const minHorizontalWidth = len * minFS * 0.9;  // [Fix] ÊèêÈ´òÈòàÂÄº
                const horizontalWontFit = boxW < minHorizontalWidth;

                // Êù°‰ª∂3: Ëâ≤ÂùóÂÆΩÂ∫¶ÂæàÂÆΩÔºåÈÄÇÂêàÊ®™Êéí
                const isWideShort = ratio < 0.6;  // [Fix] Êõ¥‰∏•Ê†º

                // ÁªºÂêàÂà§Êñ≠ÂÅèÂ•ΩÊñπÂêë
                const preferVertical = isNarrowTall || horizontalWontFit || mustBeVertical;
                const preferHorizontal = isWideShort && !horizontalWontFit && !mustBeVertical;

                // ========== ËæÖÂä©ÂáΩÊï∞ ==========
                const addLayout = (type, fs, scoreMult = 1.0) => {
                    // [Fix v2] Tier 3 Èôç‰ΩéÊúÄÂ∞èÂ≠óÂè∑ÔºåËÆ©Êõ¥Â§öÂ∞èÊîøÊùÉËÉΩÊòæÁ§∫Ê†áÁ≠æ
                    let effectiveMinFS = minFS;
                    if (tier === 3) {
                        if (type === 'H') {
                            effectiveMinFS = 8;   // Ê®™ÊéíÊúÄÂ∞è 8px
                        } else {
                            effectiveMinFS = 7;   // V Âíå H2 ÊúÄÂ∞è 7px
                        }
                    }

                    fs = Math.min(Math.max(fs, effectiveMinFS), maxFS);
                    let w = 0, h = 0;

                    if (type === 'H') {
                        // Ê®™ÊéíÂçïË°å
                        w = fs * len * 0.95;  // Â≠óÁ¨¶Èó¥Ë∑ùÁ≥ªÊï∞
                        h = fs * 1.2;
                    } else if (type === 'V') {
                        // Á´ñÊéí
                        w = fs * 1.2;
                        h = fs * len * 1.1;  // Ë°åÈ´òÁ≥ªÊï∞
                    } else if (type === 'H2') {
                        // Ê®™Êéí‰∏§Ë°å
                        const row1Len = Math.ceil(len / 2);
                        w = fs * row1Len * 0.95;
                        h = fs * 2.0;  // [Fix] ÂáèÂ∞ëË°åÈ´òÔºåÊõ¥Á¥ßÂáë
                    }

                    // [Fix v2] ÊîæÂÆΩÊ∫¢Âá∫ÊÉ©ÁΩöÔºöÂÖÅËÆ∏ËΩªÂæÆÊ∫¢Âá∫
                    let overflowPenalty = 1.0;
                    const overflowX = w / sliceW;
                    const overflowY = h / sliceH;
                    // Ê∫¢Âá∫ 20% ‰ª•ÂÜÖÂè™ËΩªÂæÆÊÉ©ÁΩöÔºåË∂ÖËøá 20% ÊâçÂ§ßÂπÖÊÉ©ÁΩö
                    if (overflowX > 1.2) overflowPenalty *= 0.3;
                    else if (overflowX > 1.0) overflowPenalty *= 0.8;
                    if (overflowY > 1.2) overflowPenalty *= 0.3;
                    else if (overflowY > 1.0) overflowPenalty *= 0.8;

                    candidates.push({
                        type, fs, w, h,
                        scoreMult: scoreMult * overflowPenalty
                    });
                };

                // ========== ÁîüÊàêÂÄôÈÄâÂ∏ÉÂ±Ä ==========
                // [Fix] ‰ΩøÁî® sliceW/sliceH ËÆ°ÁÆóÂ≠óÂè∑ÔºàÂÆûÈôÖÂèØÊîæÁΩÆÂå∫ÂüüÔºâ

                // 1. Ê®™Êéí (H) - ÈªòËÆ§È¶ñÈÄâ
                const hFS = Math.min(sliceW * 0.9 / len, sliceH * 0.8);
                if (hFS >= minFS) {
                    let hScore = preferHorizontal ? 1.4 : (horizontalWontFit ? 0.6 : 1.2);
                    addLayout('H', hFS, hScore);
                    if (hFS * 0.85 >= minFS) {
                        addLayout('H', hFS * 0.85, hScore * 0.9);
                    }
                }

                // 2. Á´ñÊéí (V) - Á™ÑÈ´òÂûãÂå∫ÂüüÈ¶ñÈÄâ
                const vFS = Math.min(sliceW * 0.8, sliceH * 0.9 / len);
                if (vFS >= minFS) {
                    let vScore = preferVertical ? 1.6 : 0.8;

                    // Âº∫Âà∂Á´ñÊéíÁöÑÊÉÖÂÜµÁªôÊúÄÈ´òÂàÜ
                    if (mustBeVertical) {
                        vScore = 2.0;
                    }
                    // Áü≠ÂêçÁß∞ + ÂÅèÂ•ΩÁ´ñÊéí
                    else if (len >= 2 && len <= 5 && preferVertical) {
                        vScore = 1.9;
                    }
                    addLayout('V', vFS, vScore);
                    if (vFS * 0.85 >= minFS) {
                        addLayout('V', vFS * 0.85, vScore * 0.9);
                    }
                }

                // 3. Ê®™Êéí‰∏§Ë°å (H2) - ‰ªÖÂØπ4Â≠óÂèä‰ª•‰∏äÂêçÁß∞
                if (len >= 4) {
                    const row1Len = Math.ceil(len / 2);
                    const h2FS = Math.min(sliceW * 0.9 / row1Len, sliceH * 0.4);
                    if (h2FS >= minFS) {
                        // H2 ËØÑÂàÜÈÄªËæëÔºö
                        // - Ê®™ÊéíÂçïË°å‰ºöÊ∫¢Âá∫ ‚Üí H2 ‰ºòÂÖà (1.6)
                        // - ÂÆΩÊâÅÂûãÂå∫Âüü ‚Üí H2 ÈÄÇÂêà (1.3)
                        // - ÂÖ∂‰ªñÊÉÖÂÜµ ‚Üí ‰Ωé‰ºòÂÖàÁ∫ß (0.85)
                        let h2Score = 0.85;
                        if (horizontalWontFit && len >= 4) {
                            h2Score = 1.6;  // Ê®™ÊéíÊ∫¢Âá∫Êó∂ÔºåH2 Êàê‰∏∫È¶ñÈÄâ
                        } else if (isWideShort && len >= 4) {
                            h2Score = 1.3;  // ÂÆΩÊâÅÂå∫Âüü‰πüÈÄÇÂêà H2
                        }
                        addLayout('H2', h2FS, h2Score);
                        if (h2FS * 0.85 >= minFS) {
                            addLayout('H2', h2FS * 0.85, h2Score * 0.9);
                        }
                        // [Fix] Â¢ûÂä†Êõ¥Â∞èÂ≠óÂè∑ÈÄâÈ°πÔºåÂú®ÊúâÁ¢∞ÊíûÊó∂‰ΩøÁî®
                        if (h2FS * 0.7 >= minFS) {
                            addLayout('H2', h2FS * 0.7, h2Score * 0.75);
                        }
                    }
                }

                // [Fix] ‰∏∫ H Âíå V ‰πüÂ¢ûÂä† 0.7 ÂÄçÂ≠óÂè∑ÈÄâÈ°π
                if (hFS * 0.7 >= minFS) {
                    addLayout('H', hFS * 0.7, 0.7);
                }
                if (vFS * 0.7 >= minFS) {
                    addLayout('V', vFS * 0.7, 0.7);
                }

                // ========== Fallback ==========
                if (candidates.length === 0) {
                    // Â¶ÇÊûúÊ≤°ÊúâÂêàÊ≥ïÂÄôÈÄâÔºåÂº∫Âà∂Ê∑ªÂä†‰∏Ä‰∏™ÊúÄÂ∞èÁöÑ
                    candidates.push({
                        type: preferVertical ? 'V' : 'H',
                        fs: minFS,
                        w: preferVertical ? minFS : minFS * len,
                        h: preferVertical ? minFS * len : minFS,
                        scoreMult: 0.1
                    });
                }

                // ÊåâËØÑÂàÜÊéíÂ∫èÔºàÂ≠óÂè∑ √ó ËØÑÂàÜÁ≥ªÊï∞Ôºâ
                candidates.sort((a, b) => (b.fs * b.scoreMult) - (a.fs * a.scoreMult));
                return candidates;
            },

            /**
             * [v2.0] Step 4: ËÆ°ÁÆóÊúÄÁªàÂ∏ÉÂ±Ä
             * ÊîπËøõÁÇπÔºö
             * - ‰∏∫ÊØè‰∏™ÊîøÊùÉËÆ°ÁÆó BoundingBox
             * - Â∞Ü bbox ‰º†ÈÄíÁªô generateCandidates
             * - Ê∑ªÂä†ËæπÁïåÁ∫¶ÊùüÊ£ÄÊü•ÔºöÊ†áÁ≠æ‰∏çËÉΩË∂ÖÂá∫ bbox
             */
            computeAll(regimeGroups, regionIndexMap, colWidth, zoom) {
                if (!this.index) this.init();
                this.index.clear();

                const results = [];

                // 1. Êî∂ÈõÜÊâÄÊúâÊîøÊùÉÂèäÂÖ∂‰ΩçÁΩÆ‰ø°ÊÅØ
                const allItems = [];
                regimeGroups.forEach(g => {
                    const positions = Core.logic.calculateLabelPositions(g, regionIndexMap, colWidth);

                    positions.forEach(p => {
                        // ‰ΩøÁî® cluster ÁöÑËÅîÂêàËæπÁïåÊ°ÜÔºàÁî®‰∫éÊñπÂêëÂÅèÂ•ΩÂíåÂ≠óÂè∑Âà§Êñ≠Ôºâ
                        const cb = p.clusterBounds;
                        const clusterBbox = {
                            x: cb.minX,
                            y: (cb.minY - APP_CONFIG.minYear) * zoom,
                            w: cb.maxX - cb.minX,
                            h: (cb.maxY - cb.minY) * zoom
                        };

                        allItems.push({
                            group: g,
                            pos: p,
                            bbox: clusterBbox,
                            bestSlice: p.bestSlice  // ‰øùÁïô bestSlice ‰æõÂêéÁª≠È™åËØÅ
                        });
                    });
                });

                // 2. Êåâ Tier ‰ºòÂÖàÁ∫ß + Èù¢ÁßØÊéíÂ∫èÔºàTier 1 ÂÖàÂç†ÂùëÔºâ
                allItems.sort((a, b) => {
                    const tA = parseInt(a.group.explicitTier) || 3;
                    const tB = parseInt(b.group.explicitTier) || 3;
                    if (tA !== tB) return tA - tB;
                    return b.pos.area - a.pos.area;
                });

                // 3. ÊîæÁΩÆÂæ™ÁéØ
                allItems.forEach(item => {
                    const { group, pos, bbox, bestSlice } = item;
                    const tier = parseInt(group.explicitTier) || 3;

                    // Ëé∑ÂèñÂÄôÈÄâÂ∏ÉÂ±Ä
                    // [Fix] ‰º†ÂÖ• bestSliceÔºåÁî®‰∫éÊõ¥Á≤æÁ°ÆÁöÑÂ≠óÂè∑ËÆ°ÁÆó
                    const layouts = this.generateCandidates(group, bbox, pos, bestSlice, zoom);

                    let bestPlacement = null;
                    let bestScore = -Infinity;

                    // ÂÆö‰πâÂ∞ùËØïÁöÑ‰ΩçÁΩÆÂÅèÁßªÈáè
                    let offsets = [{ x: 0, y: 0 }];

                    // Ê†πÊçÆËæπÁïåÊ°ÜÈ´òÂ∫¶ÂÜ≥ÂÆöÂÅèÁßªËåÉÂõ¥
                    if (bbox.h > 40 || tier <= 2) {
                        offsets.push({ x: 0, y: -bbox.h * 0.2 });
                        offsets.push({ x: 0, y: bbox.h * 0.2 });
                    }
                    if (tier >= 3 && bbox.h > 60) {
                        offsets.push({ x: 0, y: -bbox.h * 0.35 });
                        offsets.push({ x: 0, y: bbox.h * 0.35 });
                    }

                    // ÈÅçÂéÜÊâÄÊúâ Â∏ÉÂ±Ä √ó ‰ΩçÁΩÆ ÁªÑÂêà
                    for (let layout of layouts) {
                        for (let off of offsets) {
                            // ËÆ°ÁÆóÊ†áÁ≠æ‰∏≠ÂøÉÁÇπÂùêÊ†á
                            const boxY = (pos.y - APP_CONFIG.minYear) * zoom;
                            let centerX = pos.x + off.x;
                            let centerY = boxY + off.y;

                            // [Fix] Âº∫Âà∂‰∏≠ÂøÉÁÇπÂú® bbox ÂÜÖÈÉ®
                            // Â¶ÇÊûúÂä†ÊùÉ‰∏≠ÂøÉË∑ëÂà∞ bbox Â§ñÈù¢ÔºåÂº∫Âà∂ÊãâÂõûÊù•
                            const bboxCenterX = bbox.x + bbox.w / 2;
                            const bboxCenterY = bbox.y + bbox.h / 2;

                            if (centerX < bbox.x || centerX > bbox.x + bbox.w) {
                                centerX = bboxCenterX;  // ‰ΩøÁî® bbox ‰∏≠ÂøÉ
                            }
                            if (centerY < bbox.y || centerY > bbox.y + bbox.h) {
                                centerY = bboxCenterY;  // ‰ΩøÁî® bbox ‰∏≠ÂøÉ
                            }

                            const w = layout.w;
                            const h = layout.h;

                            // ========== [Fix] ‰∏•Ê†ºÂåñËæπÁïåÁ∫¶ÊùüÊ£ÄÊü• ==========
                            // Ê†áÁ≠æÁöÑËæπÁïå
                            const labelLeft = centerX - w / 2;
                            const labelRight = centerX + w / 2;
                            const labelTop = centerY - h / 2;
                            const labelBottom = centerY + h / 2;

                            // [Fix] Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÂá∫ÊîøÊùÉËæπÁïåÊ°ÜÔºàÂÆπÂ∑ÆÊîπ‰∏∫0Ôºâ
                            const exceedsLeft = labelLeft < bbox.x;
                            const exceedsRight = labelRight > bbox.x + bbox.w;
                            const exceedsTop = labelTop < bbox.y;
                            const exceedsBottom = labelBottom > bbox.y + bbox.h;

                            // [Fix] ‰ªª‰ΩïÊñπÂêëË∂ÖÂá∫ÈÉΩË¶ÅÊÉ©ÁΩöÔºå1‰∏™ÊñπÂêë‰∏•ÈáçË∂ÖÂá∫Â∞±Ë∑≥Ëøá
                            const exceedsCount = [exceedsLeft, exceedsRight, exceedsTop, exceedsBottom].filter(Boolean).length;

                            // ËÆ°ÁÆóË∂ÖÂá∫Èáè
                            const overflowLeft = exceedsLeft ? (bbox.x - labelLeft) : 0;
                            const overflowRight = exceedsRight ? (labelRight - bbox.x - bbox.w) : 0;
                            const overflowTop = exceedsTop ? (bbox.y - labelTop) : 0;
                            const overflowBottom = exceedsBottom ? (labelBottom - bbox.y - bbox.h) : 0;
                            const maxOverflow = Math.max(overflowLeft, overflowRight, overflowTop, overflowBottom);

                            // [Fix v2] ÊîæÂÆΩËæπÁïåÊ£ÄÊü•ÔºöÂÖÅËÆ∏Êõ¥Â§öÊ∫¢Âá∫
                            // Â¶ÇÊûúË∂ÖÂá∫ÈáèÂ§ß‰∫éÊ†áÁ≠æÂ∞∫ÂØ∏ÁöÑ 50%ÔºåË∑≥Ëøá
                            if (maxOverflow > Math.min(w, h) * 0.5) {
                                continue;
                            }
                            // Â¶ÇÊûú‰∏â‰∏™Âèä‰ª•‰∏äÊñπÂêëË∂ÖÂá∫ÔºåË∑≥Ëøá
                            if (exceedsCount >= 3) {
                                continue;
                            }

                            // [Fix] Á¢∞ÊíûÁÆ±Âè™Êî∂Áº© 5%ÔºåÈÅøÂÖçËßÜËßâÈáçÂè†
                            const hitW = w * 0.95;
                            const hitH = h * 0.95;
                            const rect = {
                                x: centerX - hitW / 2,
                                y: centerY - hitH / 2,
                                w: hitW,
                                h: hitH
                            };

                            // Á¢∞ÊíûÊ£ÄÊµã
                            const conflicts = this.index.query(rect);
                            if (conflicts.length > 0) {
                                continue;  // ÊúâÁ¢∞ÊíûÔºåË∑≥Ëøá
                            }

                            // ËÆ°ÁÆóËØÑÂàÜ
                            let score = layout.fs * layout.scoreMult;

                            // ÂÅèÁßªÊÉ©ÁΩö
                            if (off.y !== 0) score *= 0.9;

                            // [Fix] ËæπÁïåË∂ÖÂá∫ÊÉ©ÁΩöÔºàÊ†πÊçÆÊ∫¢Âá∫ÈáèÂä®ÊÄÅÈôçÂàÜÔºâ
                            if (exceedsCount >= 1) {
                                // Ê∫¢Âá∫ÈáèË∂äÂ§ßÔºåÊÉ©ÁΩöË∂äÈáç
                                const overflowRatio = maxOverflow / Math.min(w, h);
                                score *= Math.max(0.3, 1 - overflowRatio * 2);
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestPlacement = {
                                    layout,
                                    x: centerX,
                                    y: centerY,
                                    rect,
                                    bbox  // ‰øùÂ≠ò bbox ‰æõË∞ÉËØï
                                };
                            }
                        }
                        // ÊâæÂà∞Ë∂≥Â§üÂ•ΩÁöÑ‰ΩçÁΩÆÂ∞±ÂÅúÊ≠¢
                        if (bestPlacement && bestScore > 10) break;
                    }

                    if (bestPlacement) {
                        // [Fix] Âº∫Âà∂Ê†áÁ≠æ‰ΩçÁΩÆÂú® bbox ÂÜÖ
                        let finalX = bestPlacement.x;
                        let finalY = bestPlacement.y;
                        const lw = bestPlacement.layout.w;
                        const lh = bestPlacement.layout.h;

                        // Clamp Ê†áÁ≠æ‰∏≠ÂøÉÔºåÁ°Æ‰øùÊ†áÁ≠æ‰∏çË∂ÖÂá∫ bbox
                        const minX = bbox.x + lw / 2;
                        const maxX = bbox.x + bbox.w - lw / 2;
                        const minY = bbox.y + lh / 2;
                        const maxY = bbox.y + bbox.h - lh / 2;

                        if (maxX > minX) {
                            finalX = Math.max(minX, Math.min(maxX, finalX));
                        } else {
                            finalX = bbox.x + bbox.w / 2;
                        }
                        if (maxY > minY) {
                            finalY = Math.max(minY, Math.min(maxY, finalY));
                        } else {
                            finalY = bbox.y + bbox.h / 2;
                        }

                        // [Fix] È™åËØÅÊ†áÁ≠æ‰∏≠ÂøÉÊòØÂê¶Âú®ÊîøÊùÉÁöÑÂÆûÈôÖÁâáÊÆµ‰∏ä
                        // Â¶ÇÊûú‰∏çÂú®ÔºåÂàôÁßªÂä®Âà∞ bestSlice ÁöÑ‰∏≠ÂøÉ
                        const slices = group.visualSlices || [];
                        const labelCenterY_year = (finalY / zoom) + APP_CONFIG.minYear;
                        const labelCenterX_col = finalX / colWidth;  // ËΩ¨Êç¢‰∏∫ÂàóÂùêÊ†á

                        let isOnValidSlice = false;
                        for (const slice of slices) {
                            const sliceLeft = slice.cIdx + slice.left;
                            const sliceRight = sliceLeft + slice.w;
                            const inX = labelCenterX_col >= sliceLeft && labelCenterX_col <= sliceRight;
                            const inY = labelCenterY_year >= slice.start && labelCenterY_year <= slice.end;
                            if (inX && inY) {
                                isOnValidSlice = true;
                                break;
                            }
                        }

                        if (!isOnValidSlice && item.bestSlice) {
                            // Ê†áÁ≠æ‰∏çÂú®ÊúâÊïàÁâáÊÆµ‰∏äÔºåÁßªÂä®Âà∞ bestSlice ‰∏≠ÂøÉ
                            const bs = item.bestSlice;
                            finalX = bs.x;  // bestSlice ÁöÑ‰∏≠ÂøÉ XÔºàÂÉèÁ¥†Ôºâ
                            finalY = (bs.y - APP_CONFIG.minYear) * zoom;  // Âπ¥‰ªΩËΩ¨ÂÉèÁ¥†
                        }

                        bestPlacement.x = finalX;
                        bestPlacement.y = finalY;

                        // Ê≥®ÂÜåÁ¢∞ÊíûÁÆ±
                        bestPlacement.rect.tier = tier;
                        this.index.insert(bestPlacement.rect);
                        // [DEBUG] ËæìÂá∫ÊúÄÁªàÊîæÁΩÆ‰ø°ÊÅØ
                        if (['ÂÆâ‰∏úÈÉΩÊä§Â∫ú', 'ÂêêËïÉÁéãÊúù'].includes(group.name)) {
                            console.log(`[DEBUG] ${group.name} ÊîæÁΩÆ:`, {
                                bbox: { x: bbox.x.toFixed(0), y: bbox.y.toFixed(0), w: bbox.w.toFixed(0), h: bbox.h.toFixed(0) },
                                ÂéüÂßãpos: { x: pos.x.toFixed(0), y: pos.y.toFixed(0) },
                                ÊúÄÁªà‰ΩçÁΩÆ: { x: finalX.toFixed(0), y: finalY.toFixed(0) },
                                isOnValidSlice,
                                Â∏ÉÂ±Ä: { type: bestPlacement.layout.type, w: lw.toFixed(0), h: lh.toFixed(0) }
                            });
                        }

                        results.push({
                            group,
                            ...bestPlacement
                        });
                    } else {
                        // ÊîæÁΩÆÂ§±Ë¥• ‚Üí ÈôçÁ∫ß‰∏∫ÂúÜÁÇπ
                        results.push({
                            group,
                            failed: true,
                            x: pos.x,
                            y: (pos.y - APP_CONFIG.minYear) * zoom,
                            bbox  // ‰øùÂ≠ò bbox ‰æõË∞ÉËØï
                        });
                    }
                });

                return results;
            }
        };


        const Core = {
            state: { regions: [], regionIndexMap: {}, regimeGroups: [], zoom: 1.5, rawData: [], features: { connections: true }, selectedRegimeId: null, lastClickedGeoCode: null, clickedYear: null, layoutCache: {}, intraColumnCache: {}, isFlipped: false },

            // [New] State sync: Report state changes (e.g. clicks) to parent
            updateParentState: function (updates) {
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'STATE_UPDATE_REQUEST',
                        payload: updates
                    }, window.location.origin);
                }
            },

            init: function () {
                // [Fix] Á¶ÅÁî®ÊµèËßàÂô®ÊªöÂä®ÊÅ¢Â§ç
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }

                // [Fix] ËÆ∞ÂΩïÂàùÂßãÂåñÊó∂Èó¥ÔºåÁî®‰∫éÊã¶Êà™ÂàùÂßãÈò∂ÊÆµÁöÑÈîôËØØÊªöÂä®Êåá‰ª§
                this._initTime = Date.now();



                window.addEventListener('message', (e) => {
                    // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÂÆâÂÖ®ÈòÄ
                    if (!e.data || typeof e.data !== 'object') return;

                    const { type, payload = {} } = e.data;

                    // Debug
                    if (type === 'CMD_RESET') console.log("üìú ÂÖ®ÊôØÈ°µÊî∂Âà∞Â§ç‰ΩçÊåá‰ª§!");

                    // 2. ÂàùÂßãÂåñÊï∞ÊçÆ‰∏éÊ†∑ÂºèÊ≥®ÂÖ•
                    if (type === 'INIT_DATA') {
                        const { data, sharedCSS, sliceData, layout } = payload;

                        // [ÂÖ≥ÈîÆ‰øÆÂ§ç] Ê≥®ÂÖ•Áà∂Á∫ßÂèëÊù•ÁöÑ CSS (Ëß£ÂÜ≥ texture-V/J ËôöÁ∫øÂíåÁΩëÊ†º‰∏çÊòæÁ§∫ÁöÑÈóÆÈ¢ò)
                        if (sharedCSS) {
                            const styleEl = document.getElementById('dynamic-styles');
                            if (styleEl) styleEl.innerHTML = sharedCSS;
                        }

                        // [New v10] ‰øùÂ≠òÈ¢ÑËÆ°ÁÆóÊï∞ÊçÆ
                        if (layout) {
                            console.log('[Panorama] Layout data received');
                            this.state.layoutData = layout; // ÂåÖÂê´ colOrder
                        }
                        if (sliceData) {
                            console.log('[Panorama] Slice data received');
                            this.state.sliceData = sliceData;
                        }

                        // Â§ÑÁêÜÊ†∏ÂøÉÊï∞ÊçÆ
                        if (data) {
                            this.processData(data);
                        } else {
                            console.warn("Panorama: INIT_DATA received but data is empty");
                        }
                    }

                    // 3. Áº©ÊîæÊéßÂà∂
                    if (type === 'CMD_ZOOM_IN') {
                        this.state.zoom = Math.min(this.state.zoom + 0.5, 10);
                        this.updateLayout(); // ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÂπ∂Ê∏≤Êüì
                    }
                    if (type === 'CMD_ZOOM_OUT') {
                        this.state.zoom = Math.max(this.state.zoom - 0.5, 0.5);
                        this.updateLayout(); // ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÂπ∂Ê∏≤Êüì
                    }

                    // 4. ÂÖ®ÊôØÂ§ç‰ΩçÈÄªËæë
                    if (type === 'CMD_RESET' || type === 'CMD_ZOOM_RESET') {
                        // Á°Æ‰øù Core Â∑≤Âä†ËΩΩ
                        if (this.resetView) {
                            this.resetView();
                        }
                    }

                    // 5. [ÂäüËÉΩ] ÂàáÊç¢ÁâπÊÄß (Â¶ÇÔºöÊòæÁ§∫/ÈöêËóèÁ∫ΩÂ∏¶ËøûÊé•)
                    if (type === 'CMD_TOGGLE_FEATURE') {
                        // payload ‰πüÊòØÂ≠óÁ¨¶‰∏≤Ôºå‰æãÂ¶Ç 'connections'
                        this.toggleFeature(payload);
                    }



                    // 8. ÂêåÊ≠•ÊªöÂä®Êåá‰ª§ [Fix] Êã¶Êà™ÂàùÂßãÂåñÈò∂ÊÆµÁöÑÁé∞‰ª£Âπ¥‰ªΩ
                    if (type === 'CMD_SCROLL_TO_YEAR') {
                        const timeSinceInit = Date.now() - this._initTime;
                        // Â¶ÇÊûúÂú®ÂàùÂßãÂåñÂêé3ÁßíÂÜÖÔºå‰∏îÂπ¥‰ªΩ > 0ÔºàÁé∞‰ª£ÔºâÔºåÂàôÂøΩÁï•ÔºàÂº∫Âà∂‰øùÊåÅÂú®Â§èÊúùÔºâ
                        if (timeSinceInit < 3000 && payload > 0) {
                            console.log(`[Panorama] Êã¶Êà™ÂàùÂßãÊªöÂä®Êåá‰ª§Ôºö${payload}Ôºå‰øùÊåÅÂú®Â§èÊúù`);
                            return;
                        }
                        if (window.scrollToYear) window.scrollToYear(payload);
                    }

                    // === 9. ÂÖ®Â±ÄÁä∂ÊÄÅÂêåÊ≠•ÔºàÂçïÂêëÊï∞ÊçÆÊµÅÔºöÁà∂‚ÜíÂ≠êÔºâ ===
                    if (type === 'STATE_SYNC') {
                        // Êé•Êî∂Áà∂È°µÈù¢ÁöÑÂÖ®Â±ÄÁä∂ÊÄÅÔºåÊõ¥Êñ∞Êú¨Âú∞ËßÜÂõæ
                        const appState = payload;

                        // 1. ÂêåÊ≠•Âπ¥‰ªΩ
                        if (appState.year !== undefined && window.scrollToYear) {
                            if (!this._userScrolling) {
                                window.scrollToYear(appState.year);
                            }
                        }

                        // 2. ÂêåÊ≠•ÈÄâ‰∏≠ÁöÑÊîøÊùÉ & Âå∫Âüü
                        if (appState.region) {
                            if (!this.state.lastClickedGeoCode || this.state.lastClickedGeoCode !== appState.region) {
                                if (this.ui && this.ui.highlightHeader) this.ui.highlightHeader(appState.region);
                            }
                            this.state.lastClickedGeoCode = String(appState.region);
                        }

                        if (appState.selectedRegimeId) {
                            const targetId = appState.selectedRegimeId;
                            const target = this.state.regimeGroups.find(g => g.regimeId === targetId);
                            const alreadyFocused = target && this.state.selectedRegimeId === target.regimeId;

                            if (target && !alreadyFocused) {
                                // [Fix] Á´ãÂç≥Êõ¥Êñ∞ÈÄªËæëÁä∂ÊÄÅÔºåÁ°Æ‰øùÂú®Âä®ÁîªÊàñÈáçÁªòÊúüÈó¥Áä∂ÊÄÅ‰∏ÄËá¥
                                this.state.selectedRegimeId = targetId;

                                setTimeout(() => {
                                    if (this.ui && this.ui.jumpToRegime) {
                                        this.ui.jumpToRegime(target, false);
                                    }
                                }, 50);
                            }
                        } else if (appState.selectedRegimeId === null && this.state.selectedRegimeId) {
                            // Ê∏ÖÈô§ÈÄâ‰∏≠
                            if (this.ui && this.ui.closePanel) this.ui.closePanel();
                        }

                        // Ë∞ÉËØïÊó•Âøó
                        // console.log('[Panorama] STATE_SYNC received:', appState);
                    }


                    // [ÈïúÂÉèÂêåÊ≠•Êû∂ÊûÑ] ÁßªÈô§ PREPARE_VIEW_SWITCH Â§ÑÁêÜ
                    // ‰∏§‰∏™È°µÈù¢ÂßãÁªà‰øùÊåÅÂêåÊ≠•ÔºåËßÜÂõæÂàáÊç¢Âè™ÊòØ CSS ÊòæÁ§∫/ÈöêËóèÔºåÊó†ÈúÄÊ∏ÖÁêÜ
                });

                // Notify parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'CHILD_READY', payload: { source: 'panorama' } }, window.location.origin);
                }

                // Bind UI Events
                this.bindEvents();
                this._setupScrollSync(); // ËÆæÁΩÆÊªöÂä®-Áä∂ÊÄÅÂêåÊ≠•
            },

            // === [ÂçïÂêëÊï∞ÊçÆÊµÅ] Ê∑ªÂä†ÊªöÂä®ÁõëÂê¨ÔºåÂêåÊ≠•Âπ¥‰ªΩÂà∞ÂÖ®Â±ÄÁä∂ÊÄÅ ===
            _setupScrollSync: function () {
                const mainContent = document.getElementById('main-content');
                if (!mainContent) return;

                let scrollTimer = null;
                let isProgrammaticScroll = false;
                let userScrollEndTimer = null;
                this._userScrolling = false;

                mainContent.addEventListener('scroll', () => {
                    if (isProgrammaticScroll || window._isProgrammaticScroll) return;

                    // Ê†áËÆ∞Áî®Êà∑Ê≠£Âú®ÊªöÂä®
                    this._userScrolling = true;
                    clearTimeout(userScrollEndTimer);
                    userScrollEndTimer = setTimeout(() => {
                        this._userScrolling = false;
                    }, 400); // Á®çÂæÆÈïø‰∫éÊõ¥Êñ∞È¢ëÁéá

                    // ËäÇÊµÅÔºöÊªöÂä®ÂÅúÊ≠¢300msÂêéÊâçÊõ¥Êñ∞Áä∂ÊÄÅÔºàÈÅøÂÖçÈ´òÈ¢ëpostMessageÔºâ
                    clearTimeout(scrollTimer);
                    scrollTimer = setTimeout(() => {
                        // [Fix] ÂàùÂßãÂåñÈò∂ÊÆµÔºàÂâç2ÁßíÔºâ‰∏çÂèëÈÄÅÊªöÂä®Áä∂ÊÄÅÊõ¥Êñ∞ÔºåÈò≤Ê≠¢Ë¶ÜÁõñURLÊåáÂÆöÁöÑÂπ¥‰ªΩ
                        const timeSinceInit = Date.now() - (Core._initTime || Date.now());
                        if (timeSinceInit < 2000) {
                            console.log('[Panorama] ÂàùÂßãÂåñÈò∂ÊÆµÔºåË∑≥ËøáÊªöÂä®Áä∂ÊÄÅÂêåÊ≠•');
                            return;
                        }

                        const centerYear = window.getCenterYear ? window.getCenterYear() : null;
                        if (centerYear !== null && window.parent && window.parent !== window) {
                            window.parent.postMessage({
                                type: 'STATE_UPDATE_REQUEST',
                                payload: { year: Math.round(centerYear) }
                            }, window.location.origin);
                        }
                    }, 300);
                }, { passive: true });

                // ÂΩìÊé•Êî∂Âà∞ STATE_SYNC Êó∂ÔºåÊ†áËÆ∞‰∏∫Á®ãÂ∫èÂåñÊªöÂä®
                const originalScrollToYear = window.scrollToYear;
                window.scrollToYear = function (year) {
                    isProgrammaticScroll = true;
                    originalScrollToYear(year);
                    setTimeout(() => { isProgrammaticScroll = false; }, 500);
                };
            },

            // --- [‰øÆÂ§ç] ÂÖ®ÊôØÈ°µ‰∏ìÁî®Â§ç‰ΩçÂáΩÊï∞ (ÂÆâÂÖ®Áâà) ---
            resetView: function () {
                console.log("üîÑ [Panorama] ÊâßË°åÂÖ®ÊôØÂ§ç‰Ωç...");

                // 1. ÈáçÁΩÆÊ†∏ÂøÉÊï∞ÊçÆ
                this.state.zoom = 1.5;
                this.state.lastClickedGeoCode = null;

                // 2. [ÂÆâÂÖ®‰øÆÂ§ç] Êõ¥Êñ∞ÊªëÂùó (ÂÖàÊ£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®)
                // ‰Ω†ÁöÑ‰ª£Á†ÅÈáåÂÖ∂ÂÆûÊ≤°Êúâ id="zoom-slider"ÔºåËøô‰πãÂâçÂØºËá¥‰∫ÜÊä•Èîô
                const zSlider = document.getElementById('zoom-slider');
                if (zSlider) {
                    zSlider.value = 1.5;
                }

                // 3. Ê∏ÖÁêÜËÅöÁÑ¶Áä∂ÊÄÅ
                this.ui.clearFocus();
                this.ui.closePanel();

                // 4. [ÂÆâÂÖ®‰øÆÂ§ç] ÈöêËóèÂºπÁ™ó (ÂÖàÊ£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®)
                const selModal = document.getElementById('selection-modal');
                if (selModal) selModal.classList.add('hidden');

                const searchRes = document.getElementById('search-results');
                if (searchRes) searchRes.style.display = 'none';

                const searchInp = document.getElementById('search-input');
                if (searchInp) searchInp.value = '';

                // ÁßªÈô§È´ò‰∫ÆÁ±ª
                document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));

                // 5. Á´ãÂç≥ÈáçÁªò
                this.updateLayout();

                // 6. [ÂÆâÂÖ®‰øÆÂ§ç] ÊªöÂä®ÂΩíÈõ∂
                const main = document.getElementById('main-content');
                if (main) {
                    main.style.scrollBehavior = 'auto'; // Á¶ÅÁî®Âπ≥ÊªëÊªöÂä®Èò≤Ê≠¢ÂÜ≤Á™Å
                    main.scrollTop = 0;
                    main.scrollLeft = 0;

                    // Âª∂Êó∂ÊÅ¢Â§çÂπ≥ÊªëÊªöÂä®ÔºåÂπ∂ÂÜçÊ¨°Á°Æ‰øù main Â≠òÂú®
                    setTimeout(() => {
                        const m = document.getElementById('main-content');
                        if (m) m.style.scrollBehavior = 'smooth';
                    }, 500);
                }

                console.log("‚úÖ ÂÖ®ÊôØËßÜÂõæÂ∑≤ÊÅ¢Â§ç (Zoom: 1.5)");
            },

            // [v10] Êñ∞‰∏ÄËá¥ÊÄßÊ£ÄÊµãÊñπÊ≥ï
            checkLayoutConsistency: function () {
                if (!this.state.layoutData || !this.state.layoutData.layout || !this.state.rawData) {
                    return;
                }
                if (this.state.hasCheckedConsistency) return;
                this.state.hasCheckedConsistency = true;

                const layout = this.state.layoutData.layout;
                const csvRegimeMap = {}; // geoId -> Set(rcodes)
                const layoutRegimeMap = {}; // geoId -> Set(rcodes)

                // ‰ªé CSV ÊèêÂèñÊîøÊùÉÂàóË°®
                for (const frag of this.state.rawData) {
                    const geoId = frag.geoCode;
                    // id format: Name|Code
                    const parts = frag.group.regimeId.split('|');
                    const rcode = parts.length > 1 ? parts[1] : parts[0];
                    if (!csvRegimeMap[geoId]) csvRegimeMap[geoId] = new Set();
                    csvRegimeMap[geoId].add(rcode);
                }

                // ‰ªéÂ∏ÉÂ±ÄÊèêÂèñÊîøÊùÉÂàóË°®
                for (const geoId in layout) {
                    layoutRegimeMap[geoId] = new Set();
                    for (const year in layout[geoId]) {
                        for (const regime of layout[geoId][year]) {
                            const parts = regime.split('|');
                            const rcode = parts.length > 1 ? parts[1] : parts[0];
                            if (rcode) layoutRegimeMap[geoId].add(rcode);
                        }
                    }
                }

                // ÊØîÂØπ
                const added = {}; // Êñ∞Â¢ûÊîøÊùÉ (CSV Êúâ, Layout Êó†)
                const removed = {}; // Âà†Èô§ÊîøÊùÉ (Layout Êúâ, CSV Êó†)
                let totalAdded = 0;
                let totalRemoved = 0;

                for (const geoId in csvRegimeMap) {
                    const csvSet = csvRegimeMap[geoId];
                    const layoutSet = layoutRegimeMap[geoId] || new Set();

                    const addedList = [...csvSet].filter(r => !layoutSet.has(r));

                    if (addedList.length > 0) {
                        added[geoId] = addedList;
                        totalAdded += addedList.length;
                    }
                }

                // Check removed regimes
                for (const geoId in layoutRegimeMap) {
                    const layoutSet = layoutRegimeMap[geoId];
                    const csvSet = csvRegimeMap[geoId] || new Set();

                    const removedList = [...layoutSet].filter(r => !csvSet.has(r));

                    if (removedList.length > 0) {
                        removed[geoId] = removedList;
                        totalRemoved += removedList.length;
                    }
                }

                // ÈùôÈªòÂ§ÑÁêÜÂà†Èô§ÁöÑÊîøÊùÉ
                if (totalRemoved > 0) {
                    console.warn(`[Layout] Â∏ÉÂ±Ä‰∏≠Êúâ ${totalRemoved} ‰∏™Â∑≤Âà†Èô§ÁöÑÊîøÊùÉ`, removed);
                }

                // Â§ÑÁêÜÊñ∞Â¢ûÊîøÊùÉ
                if (totalAdded > 0) {
                    console.warn('[Layout] Ê£ÄÊµãÂà∞Êñ∞Â¢ûÊîøÊùÉ:', added);

                    const isDev = location.hostname === 'localhost' ||
                        location.hostname === '127.0.0.1' ||
                        location.hostname.startsWith('192.168.') ||
                        location.protocol === 'file:';

                    if (isDev) {
                        // ÂºÄÂèëËÄÖÊ®°ÂºèÔºöÂºπÁ™óÊèêÁ§∫
                        setTimeout(() => {
                            const msg = `Ê£ÄÊµãÂà∞ ${totalAdded} ‰∏™Êñ∞Â¢ûÊîøÊùÉÊú™Âú®Â∏ÉÂ±Ä‰∏≠ÂÆö‰πâ„ÄÇ\n(ËØ¶ËßÅÊéßÂà∂Âè∞)\n\nÊòØÂê¶Ë∑≥ËΩ¨Âà∞ LayoutOptimizer Êõ¥Êñ∞Â∏ÉÂ±ÄÔºü`;
                            if (confirm(msg)) {
                                location.href = 'LayoutOptimizer.html';
                            }
                        }, 500); // Slight delay to ensure render happens first
                    }
                } else if (totalRemoved === 0) {
                    console.log('‚úÖ [Layout] ‰∏ÄËá¥ÊÄßÊ£ÄÊü•ÈÄöËøá: CSV ‰∏é Â∏ÉÂ±ÄÊï∞ÊçÆÂÆåÂÖ®ÂåπÈÖç');
                }
            },

            bindEvents: function () {
                const safeBind = (id, event, handler) => { const el = document.getElementById(id); if (el) el.addEventListener(event, handler); };
                safeBind('btn-connections', 'click', () => this.toggleFeature('connections'));
                safeBind('btn-close-panel', 'click', () => this.ui.closePanel());
                safeBind('btn-close-modal', 'click', () => document.getElementById('selection-modal').classList.add('hidden'));
                safeBind('btn-flip-cols', 'click', () => {
                    this.state.isFlipped = !this.state.isFlipped;
                    this.updateLayout();
                    // ÂèØÈÄâÔºöÁªôÊåâÈíÆÂ¢ûÂä†ÊøÄÊ¥ªÁä∂ÊÄÅÊ†∑Âºè
                    const btn = document.getElementById('btn-flip-cols');
                    if (btn) btn.style.color = this.state.isFlipped ? 'var(--blue-400)' : 'var(--slate-500)';
                });
                safeBind('quick-nav', 'change', (e) => {
                    const y = parseInt(e.target.value);
                    if (!isNaN(y)) {
                        const targetY = (y - APP_CONFIG.minYear) * this.state.zoom;
                        document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                    }
                });

                // [UX] ÁÇπÂáªÈù¢Êùø header ‰ªªÊÑè‰ΩçÁΩÆÂÖ≥Èó≠Èù¢Êùø
                const panelHeader = document.querySelector('#editor-panel .panel-header');
                if (panelHeader) {
                    panelHeader.addEventListener('click', (e) => {
                        // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÊåâÈíÆÊàñÂÖ∂Â≠êÂÖÉÁ¥†ÔºåÂøΩÁï•
                        if (e.target.closest('button') || e.target.closest('.jump-btn')) return;
                        this.ui.closePanel();
                    });
                }

                const searchInput = document.getElementById('search-input');
                const handleSearch = (val) => {
                    const term = val.trim().toLowerCase();
                    document.querySelectorAll('.era-block-fragment').forEach(b => {
                        if (b.dataset.name) b.classList.toggle('era-dimmed', term !== "" && !b.dataset.name.toLowerCase().includes(term));
                    });
                    this.ui.populateSearchResults(term);
                };
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => handleSearch(e.target.value));
                    searchInput.addEventListener('focus', (e) => { if (e.target.value.trim().length > 0) handleSearch(e.target.value); });
                }

                const zSlide = document.getElementById('zoom-slider');
                if (zSlide) zSlide.addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    requestAnimationFrame(() => this.render.drawAll());
                });

                // Add Interaction for render area
                const renderArea = document.getElementById('render-area');
                if (renderArea) {
                    const crosshairLine = document.getElementById('crosshair-line');
                    // [‰øÆÊîπ] ÁßªÈô§Â§ñÈÉ®ÁöÑ const crosshairLabel = ...

                    renderArea.addEventListener('mousemove', function (e) {
                        const rect = renderArea.getBoundingClientRect();
                        const y = e.clientY - rect.top;

                        // 1. Crosshair Line & Label
                        if (crosshairLine) { crosshairLine.style.display = 'block'; crosshairLine.style.top = y + 'px'; }
                        const crosshairLabel = document.getElementById('crosshair-label'); // Dynamic get
                        const year = Math.floor((y / Core.state.zoom) + APP_CONFIG.minYear);
                        if (crosshairLabel) { crosshairLabel.style.display = 'block'; crosshairLabel.style.top = y + 'px'; crosshairLabel.innerText = year; }


                        // [Fix] Dynamically calculate column metrics to avoid ReferenceError
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const cols = headerBody.children;
                            const colCount = cols.length;

                            if (colCount > 0) {
                                // Get actual width of first column
                                const colW = cols[0].getBoundingClientRect().width;
                                const mouseX = e.clientX - rect.left;
                                const colIdx = Math.floor(mouseX / colW);

                                if (cols.length > colIdx && colIdx >= 0) {
                                    const old = headerBody.querySelector('.active-header');
                                    const target = cols[colIdx];
                                    if (old !== target) {
                                        if (old) old.classList.remove('active-header');
                                        if (target) target.classList.add('active-header');
                                    }
                                }
                            }
                        }
                    });

                    renderArea.addEventListener('mouseleave', function () {
                        if (crosshairLine) crosshairLine.style.display = 'none';
                        const crosshairLabel = document.getElementById('crosshair-label');
                        if (crosshairLabel) crosshairLabel.style.display = 'none';

                        // Clear header highlight
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const old = headerBody.querySelector('.active-header');
                            if (old) old.classList.remove('active-header');
                        }
                    });
                }
            },

            processData: function (rows) {
                if (!rows || rows.length === 0) {
                    console.error("Panorama received empty data");
                    return;
                }

                // 1. Âª∫Á´ã Code -> Name ÂÖ®Â±ÄÊü•ÊâæË°® (Áî®‰∫éËß£ÊûêÂÆó‰∏ªÂõΩ‰ª£Á†Å)
                const codeToNameMap = {};
                rows.forEach(r => {
                    const code = r.regime_code;
                    const name = r.regime_name || r.name;
                    if (code && name) codeToNameMap[code] = name;
                });

                const uniqueRegs = {};
                const groups = {};
                const rawList = [];

                rows.forEach((r, i) => {
                    const geoCode = r.geo_code || r.geo;
                    const geoName = r.geo_name || r.region || "Êú™Áü•";

                    if (!geoCode) return;
                    if (!uniqueRegs[geoCode]) uniqueRegs[geoCode] = geoName;

                    const regimeName = r.regime_name || r.name || "Êú™Áü•ÊîøÊùÉ";
                    // [Fix] Fallback ÈÄªËæë‰∏é LayoutOptimizer Áªü‰∏ÄÔºöÂ¶ÇÊûúÊ≤°Êúâ CodeÔºå‰ΩøÁî® Name ‰ª£ÊõøÔºåËÄå‰∏çÊòØ "C11"
                    const regimeCode = r.regime_code || regimeName;
                    // [Fix] ‰ΩøÁî® name + code ‰Ωú‰∏∫ÂîØ‰∏ÄÊ†áËØÜÔºåÈò≤Ê≠¢ÂêåÂêç‰∏çÂêåÊîøÊùÉË¢´ÈîôËØØÂêàÂπ∂
                    // ‰æãÂ¶ÇÔºöÊàòÂõΩÁß¶(R1150) Âíå Áß¶ÊúùÁß¶(C2100) ÂøÖÈ°ªÂàÜÂºÄ
                    const key = regimeName + '|' + regimeCode;

                    // ÂàùÂßãÂåñ Group
                    if (!groups[key]) {
                        groups[key] = {
                            regimeId: key, // [Unified] ÊîøÊùÉÂîØ‰∏ÄÊ†áËØÜÁ¨¶ (Ê†ºÂºè: Name|Code)
                            groupId: 'g-' + this.logic.simpleHash(key), // CSS class name (hash)
                            name: regimeName,  // ÊòæÁ§∫ÂêçÁß∞‰ªçÁÑ∂ÊòØ regimeName
                            regimeCode: regimeCode,
                            minStart: 9999, maxEnd: -9999,
                            explicitTier: parseInt(r.regime_tier || r.level || 3),
                            fragments: [],
                            visualSlices: [],
                            globalMinCol: 9999, globalMaxCol: -9999,
                            // Group Á∫ßÂà´ÁöÑÂÆó‰∏ª‰ø°ÊÅØ‰ªÖ‰ΩúÂèÇËÄÉÔºàÂèñÂá∫Áé∞ËøáÁöÑ‰ªª‰Ωï‰∏Ä‰∏™Ôºâ
                            suzerain: null
                        };
                    }

                    let start = parseInt(r.start_year || r.year_start);
                    let end = (r.end_year === 'present' || r.year_end === 'present') ? TIME_CONFIG.MAX_YEAR : parseInt(r.end_year || r.year_end);
                    if (isNaN(start)) start = TIME_CONFIG.DEFAULT_START || -200;
                    if (isNaN(end)) end = TIME_CONFIG.MAX_YEAR;

                    // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„Äë‰∏∫ÂΩìÂâçËøô‰∏ÄË°åÔºàFragmentÔºâËß£ÊûêÂÆó‰∏ªÂõΩÂêçÁß∞
                    let rawSuzCode = r.suzerain_code || r.suzerain;
                    let resolvedSuzName = null;

                    if (rawSuzCode && rawSuzCode !== 'null') {
                        if (r.suzerain_type === 'V|J' && rawSuzCode.includes('|')) {
                            // ÂèåÈáçÂÖ≥Á≥ªÔºöÂàÜÂà´ÁøªËØë
                            const parts = rawSuzCode.split('|');
                            const name1 = codeToNameMap[parts[0]] || parts[0];
                            const name2 = codeToNameMap[parts[1]] || parts[1];
                            resolvedSuzName = `${name1}|${name2}`;
                        } else {
                            // ÂçïÈáçÂÖ≥Á≥ª
                            resolvedSuzName = codeToNameMap[rawSuzCode] || rawSuzCode;
                        }
                    } else {
                        // ÊòæÂºèÊ†áËÆ∞‰∏∫Á©∫ÔºåÁ°Æ‰øùËØ¶ÊÉÖÈ°µËÉΩËØÜÂà´Âá∫"Êó†"
                        rawSuzCode = null;
                    }

                    // ÊûÑÂª∫ Fragment
                    const frag = {
                        id: i, name: key, start: start, end: end,
                        regimeCode: r.regime_code, geoCode: geoCode,
                        explicitTier: groups[key].explicitTier,

                        // Á°Æ‰øùÂ≠òÂÖ•Ëß£ÊûêÂêéÁöÑÊï∞ÊçÆ
                        suzerain: rawSuzCode,
                        suzerainName: resolvedSuzName,
                        suzerainType: r.suzerain_type,
                        desc: r.desc,
                        group: groups[key] // [Fix] Link back to group for easy access
                    };

                    groups[key].fragments.push(frag);
                    groups[key].minStart = Math.min(groups[key].minStart, start);
                    groups[key].maxEnd = Math.max(groups[key].maxEnd, end);
                    groups[key].globalMinYear = Math.min(groups[key].globalMinYear, start);
                    groups[key].globalMaxYear = Math.max(groups[key].globalMaxYear, end);

                    rawList.push(frag);
                });

                this.state.rawRegions = Object.entries(uniqueRegs).map(([k, v]) => ({ id: k, label: v }));
                this.state.regimeGroups = Object.values(groups);
                this.state.rawData = rawList;

                this.updateLayout();
            },

            updateLayout: function () {
                // [v10] ‰∏ÄËá¥ÊÄßÊ£ÄÊµãÂ∑≤ÁßªËá≥Áã¨Á´ãÁöÑ checkLayoutConsistency ÊñπÊ≥ï

                this.state.regions = this.logic.applyFixedLayout(this.state.rawRegions);
                this.state.regionIndexMap = this.state.regions.reduce((acc, r, i) => { acc[r.id] = i; return acc; }, {});

                this.logic.calculateGroupCenters(this.state.regimeGroups, this.state.regionIndexMap);
                this.render.drawAll();
                this.state.dataReady = true;

                // [Fix] Â§ÑÁêÜÊöÇÂ≠òÁöÑÊªöÂä®ËØ∑Ê±ÇÔºàËß£ÂÜ≥ÂàùÂßãÂåñÊï∞ÊçÆÊú™Âä†ËΩΩÂÆåÊàêÊó∂ÁöÑÊªöÂä®‰∏¢Â§±ÈóÆÈ¢òÔºâ
                if (window._pendingScrollYear !== null) {
                    const target = window._pendingScrollYear;
                    window._pendingScrollYear = null;
                    setTimeout(() => window.scrollToYear(target), 50);
                    this.state.hasInitialScrolled = true;
                }
                // [Fix] ÂàùÂßãÂä†ËΩΩÊó∂ÔºåÂ¶ÇÊûúÊ≤°Êúâ‰ªª‰ΩïÂ§ñÈÉ®Êåá‰ª§ÔºåÈªòËÆ§ÊªöÂä®Âà∞È°∂ÈÉ®
                else if (!this.state.hasInitialScrolled) {
                    this.state.hasInitialScrolled = true;
                    setTimeout(() => {
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.scrollTop = 0;
                            mainContent.scrollLeft = 0;
                        }
                    }, 50);
                }
            },

            getStyle: function (group, frag) {
                const regimeCode = group.regimeCode;
                const name = group.name;
                const suzerainCode = (frag && frag.suzerain) ? frag.suzerain : group.suzerain;
                const suzerainType = (frag && frag.suzerainType) ? frag.suzerainType : group.suzerainType;

                if (window.parent && window.parent.GlobalUtils) {
                    try {
                        return window.parent.GlobalUtils.getStyle(regimeCode, name, suzerainCode, suzerainType);
                    } catch (e) {
                        console.warn("Call parent GlobalUtils.getStyle failed", e);
                    }
                }
                return { bg: '#666', border: '#444', className: 'texture-N', isDashed: false };
            },



            logic: {
                // [New] Perspective-Based Layout Optimization

                // Extract core regions from perspective configuration
                extractCoreRegions: function (perspective) {
                    const coreRegions = new Set();

                    Core.state.regimeGroups.forEach(group => {
                        if (perspective.coreRegimes.includes(group.regimeId)) {
                            group.fragments.forEach(frag => {
                                coreRegions.add(frag.geoCode);
                            });
                        }
                    });

                    console.log(`[${perspective.name}] Ê†∏ÂøÉÂå∫Âüü: ${coreRegions.size} Âàó`, Array.from(coreRegions));
                    return coreRegions;
                },

                // Check if two regions belong to the same core regime
                belongToSameRegime: function (regionA, regionB, coreRegimes) {
                    for (let regimeId of coreRegimes) {
                        const group = Core.state.regimeGroups.find(g => g.regimeId === regimeId);
                        if (!group) continue;

                        const regionsInRegime = new Set(group.fragments.map(f => f.geoCode));
                        if (regionsInRegime.has(regionA) && regionsInRegime.has(regionB)) {
                            return true;
                        }
                    }
                    return false;
                },

                // Build weighted affinity matrix for perspective
                buildWeightedMatrix: function (perspective, baseMatrix) {
                    if (perspective.isDefault) {
                        // Default perspective: use base matrix as-is
                        return baseMatrix;
                    }

                    const coreRegions = this.extractCoreRegions(perspective);
                    const n = Core.state.rawRegions.length;
                    const matrix = Array(n).fill(0).map((_, i) => baseMatrix[i].slice());

                    // Apply weights
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const rA = Core.state.rawRegions[i].id;
                            const rB = Core.state.rawRegions[j].id;

                            const bothCore = coreRegions.has(rA) && coreRegions.has(rB);
                            const bothBg = !coreRegions.has(rA) && !coreRegions.has(rB);

                            if (bothCore) {
                                const sameRegime = this.belongToSameRegime(rA, rB, perspective.coreRegimes);
                                matrix[i][j] *= sameRegime
                                    ? perspective.weights.intraRegime
                                    : perspective.weights.interRegime;
                            } else if (bothBg) {
                                matrix[i][j] *= perspective.weights.background;
                            } else {
                                matrix[i][j] *= perspective.weights.background;
                            }
                        }
                    }

                    return matrix;
                },

                getRegimeTier: function (t) { return parseInt(t) || 3; },
                simpleHash: function (str) { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); },

                calculateGroupCenters: function (groups, regionIndexMap) {
                    groups.forEach(g => {
                        let totalCol = 0, count = 0;
                        g.fragments.forEach(f => {
                            const idx = regionIndexMap[f.geoCode];
                            if (idx !== undefined) {
                                totalCol += idx; count++;
                                g.globalMinCol = Math.min(g.globalMinCol, idx);
                                g.globalMaxCol = Math.max(g.globalMaxCol, idx);
                            }
                        });
                        g.centerCol = count > 0 ? (totalCol / count) : 0;
                        g.globalDuration = g.globalMaxYear - g.globalMinYear;
                    });
                },

                applyFixedLayout: function (rawRegions) {
                    let sorted = [];
                    if (Core.state.layoutData && Core.state.layoutData.colOrder) {
                        const orderMap = {};
                        Core.state.layoutData.colOrder.forEach((id, i) => orderMap[id] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = orderMap[a.id] !== undefined ? orderMap[a.id] : 9999;
                            const rB = orderMap[b.id] !== undefined ? orderMap[b.id] : 9999;
                            return rA - rB;
                        });
                    } else {
                        // Fallback (Original fixed order)
                        const FIXED_ORDER = ['550', '530', '520', '510', '540', '440', '410', '420', '430', '330', '350', '340', '260', '270', '310', '250', '240', '320', '220', '210', '230', '190', '150', '130', '140', '160', '120', '110', '180', '170', '610', '620', '740', '730', '720', '710', '820', '810', '840', '830', '850', '910', '920', '930', '940', '950', '960'];
                        const rankMap = {}; FIXED_ORDER.forEach((c, i) => rankMap[c] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = rankMap[a.id] !== undefined ? rankMap[a.id] : 9999;
                            const rB = rankMap[b.id] !== undefined ? rankMap[b.id] : 9999;
                            return rA - rB;
                        });
                    }

                    if (Core.state.isFlipped) {
                        sorted.reverse();
                    }
                    return sorted;
                },

                sliceFragmentsByRegion: function (fragments, colIdx, allGroups, regionIndexMap, layoutCache) {
                    if (!fragments || fragments.length === 0) return [];
                    const slices = [];

                    // 1. Ëé∑ÂèñÂΩìÂâçÂàóÂØπÂ∫îÁöÑ Region ID
                    // fragments ‰∏≠ÁöÑ geoCode Â∫îËØ•ÈÉΩÊòØÂêå‰∏Ä‰∏™Ôºå‰ΩÜ‰∏∫‰∫Ü‰øùÈô©Âéª Core.state.regions Êü•
                    const regionObj = Core.state.regions[colIdx];
                    if (!regionObj) return [];
                    const regionId = regionObj.id;

                    // 2. Ê£ÄÊü•ÊòØÂê¶ÊúâÈ¢ÑËÆ°ÁÆóÁöÑ Slice Êï∞ÊçÆ (‰ºòÂÖà)
                    const sliceData = Core.state.sliceData && Core.state.sliceData[regionId];

                    if (sliceData && sliceData.length > 0) {
                        // === Êñ∞ÈÄªËæëÔºöÂü∫‰∫é Slice Êï∞ÊçÆÁîüÊàê ===
                        fragments.forEach(frag => {
                            const fStart = frag.start;
                            const fEnd = frag.end;
                            const regimeName = frag.group.name;
                            const regimeCode = frag.group.regimeCode || regimeName;
                            const targetID = regimeName + "|" + regimeCode;

                            // ÈÅçÂéÜËØ•Âå∫ÂüüÁöÑÊâÄÊúâÂàáÁâá
                            // ‰ºòÂåñÔºöÂèØ‰ª•‰ΩøÁî®‰∫åÂàÜÊü•ÊâæÊâæÂà∞Ëµ∑ÂßãÂàáÁâáÔºåËøôÈáåÊöÇÊó∂ÈÅçÂéÜ
                            sliceData.forEach(slice => {
                                // Ê£ÄÊü•ÂàáÁâáÊòØÂê¶‰∏éÊîøÊùÉÊó∂Èó¥Êúâ‰∫§ÈõÜ
                                const sStart = slice.start;
                                const sEnd = slice.end;
                                if (sEnd <= fStart || sStart >= fEnd) return;

                                // ËÆ°ÁÆó‰∫§ÈõÜÊó∂Èó¥ÊÆµ
                                const overlapStart = Math.max(fStart, sStart);
                                const overlapEnd = Math.min(fEnd, sEnd);
                                if (overlapStart >= overlapEnd) return;

                                // Êü•ÊâæÊîøÊùÉÂú®ËØ•ÂàáÁâá‰∏≠ÁöÑ‰ΩçÁΩÆ
                                const slots = slice.slots;
                                let slotIdx = slots.indexOf(targetID);
                                // ÂÖºÂÆπÂè™Â≠ò ID ÁöÑÊÉÖÂÜµ
                                if (slotIdx === -1) slotIdx = slots.findIndex(id => id.startsWith(regimeName + '|'));

                                let totalSlots = slots.length;
                                let left = 0, width = 100;

                                if (slotIdx !== -1) {
                                    width = 100 / totalSlots;
                                    if (Core.state.isFlipped) {
                                        left = (totalSlots - 1 - slotIdx) * width;
                                    } else {
                                        left = slotIdx * width;
                                    }
                                } else {
                                    // Ê≤°ÊâæÂà∞ÔºàÂèØËÉΩÊòØÊï∞ÊçÆ‰∏ç‰∏ÄËá¥ÊàñÊñ∞ÊîøÊùÉÔºâ
                                    // ‰ªçÁÑ∂ÊòæÁ§∫ÔºåËøΩÂä†Âà∞Êú´Â∞æ
                                    const effectiveTotal = Math.max(totalSlots, 1) + 1;
                                    width = 100 / effectiveTotal;
                                    left = Core.state.isFlipped ? 0 : (effectiveTotal - 1) * width;
                                }

                                pushSlice(slices, frag, overlapStart, overlapEnd, left, width, colIdx);
                            });
                        });
                        return slices;
                    }

                    // 3. (Fallback) Ê≤°ÊúâÊï∞ÊçÆÊó∂ËøîÂõûÁ©∫
                    console.warn('[Layout] No sliceData found for region ' + regionId);
                    return slices;

                    function pushSlice(outArr, originalFrag, s, e, l, w, cIdx) {
                        if (s >= e) return;
                        const newFrag = Object.assign({}, originalFrag);
                        newFrag.displayStart = s;
                        newFrag.displayEnd = e;
                        newFrag.leftPct = l;
                        newFrag.widthPct = w;

                        // Êõ¥Êñ∞ Group ÁªüËÆ°‰ø°ÊÅØ
                        newFrag.group.visualSlices.push({
                            cIdx: cIdx,
                            start: s, end: e,
                            left: l / 100, w: w / 100,
                            dur: e - s
                        });

                        outArr.push(newFrag);
                    }

                    return slices;
                },

                calculateLabelPositions: function (group, regionIndexMap, colWidth) {
                    const frags = group.visualSlices;
                    if (!frags || frags.length === 0) return [];

                    frags.sort((a, b) => a.cIdx - b.cIdx || a.start - b.start);

                    const clusters = [];
                    const processed = new Set();

                    frags.forEach((f, i) => {
                        if (processed.has(i)) return;
                        const currentCluster = [f];
                        processed.add(i);

                        let queue = [f];
                        while (queue.length > 0) {
                            let curr = queue.shift();
                            for (let j = 0; j < frags.length; j++) {
                                if (processed.has(j)) continue;
                                const cand = frags[j];

                                // Âêå‰∏ÄÂàó + Êó∂Èó¥Êé•Ëß¶
                                const sameCol = (cand.cIdx === curr.cIdx);
                                const timeTouch = (cand.start <= curr.end + 5) && (cand.end >= curr.start - 5);

                                // Áõ∏ÈÇªÂàó + Êó∂Èó¥ÈáçÂè† + [Fix] Ê∞¥Âπ≥ÊñπÂêëÁúüÊ≠£Êé•Ëß¶
                                const neighborCol = Math.abs(cand.cIdx - curr.cIdx) === 1;
                                const timeOverlap = (cand.start < curr.end) && (cand.end > curr.start);

                                // [Fix] Ê£ÄÊü•Ê∞¥Âπ≥ÊñπÂêëÊòØÂê¶ÁúüÊ≠£Êé•Ëß¶
                                // ‰ΩøÁî®ÂÆûÈôÖÁöÑ X ÂùêÊ†áËåÉÂõ¥Ê£ÄÊü•ÊòØÂê¶ÊúâÊé•Ëß¶ÊàñÈáçÂè†
                                let horizontalTouch = false;
                                if (neighborCol && timeOverlap) {
                                    // ËÆ°ÁÆó‰∏§‰∏™ÁâáÊÆµÁöÑÂÆûÈôÖ X ÂùêÊ†áËåÉÂõ¥
                                    const currLeft = curr.cIdx + curr.left;
                                    const currRight = curr.cIdx + curr.left + curr.w;
                                    const candLeft = cand.cIdx + cand.left;
                                    const candRight = cand.cIdx + cand.left + cand.w;

                                    // ‰∏§‰∏™ËåÉÂõ¥Êé•Ëß¶ÊàñÈáçÂè†Ôºö‰∏Ä‰∏™ÁöÑÂè≥ËæπÁïå >= Âè¶‰∏Ä‰∏™ÁöÑÂ∑¶ËæπÁïå
                                    // ÂÖÅËÆ∏ 0.05 ÁöÑÂÆπÂ∑Æ
                                    horizontalTouch = (currRight >= candLeft - 0.05) && (candRight >= currLeft - 0.05);
                                }

                                if ((sameCol && timeTouch) || (neighborCol && timeOverlap && horizontalTouch)) {
                                    currentCluster.push(cand);
                                    processed.add(j);
                                    queue.push(cand);
                                }
                            }
                        }
                        clusters.push(currentCluster);
                    });

                    const results = clusters.map(cluster => {
                        let totalArea = 0;
                        let weightedX = 0;
                        let weightedY = 0;
                        let minTime = 9999, maxTime = -9999;
                        let minC = 9999, maxC = -9999;

                        let maxSliceArea = -1;
                        let bestSlice = null;

                        cluster.forEach(f => {
                            const h = f.dur;
                            const wPct = f.w;
                            const area = h * wPct;

                            const physCenterX = (f.cIdx + f.left + (f.w / 2)) * colWidth;
                            const physCenterY = (f.start + f.end) / 2;

                            weightedX += physCenterX * area;
                            weightedY += physCenterY * area;
                            totalArea += area;

                            minTime = Math.min(minTime, f.start);
                            maxTime = Math.max(maxTime, f.end);
                            minC = Math.min(minC, f.cIdx);
                            maxC = Math.max(maxC, f.cIdx);
                        });

                        // [Fix v2] ËÆ°ÁÆó"ÊúÄ‰Ω≥ÊîæÁΩÆÂå∫Âüü"ÔºöËÄÉËôëÊ∞¥Âπ≥Áõ∏ÈÇªÁâáÊÆµÁöÑÂêàÂπ∂
                        // ÈááÊ†∑Â§ö‰∏™Êó∂Èó¥ÁÇπÔºåËÆ°ÁÆóÊØè‰∏™Êó∂Èó¥ÁÇπÁöÑÂêàÂπ∂ÂÆΩÂ∫¶
                        const sampleCount = 10;
                        const timeStep = (maxTime - minTime) / sampleCount;

                        for (let i = 0; i <= sampleCount; i++) {
                            const sampleYear = minTime + i * timeStep;

                            // ÊâæÂá∫Âú®Ëøô‰∏™Êó∂Èó¥ÁÇπÂ≠òÂú®ÁöÑÊâÄÊúâÁâáÊÆµ
                            const activeSlices = cluster.filter(f =>
                                f.start <= sampleYear && f.end >= sampleYear
                            );

                            if (activeSlices.length === 0) continue;

                            // [Fix v3] Â∞ÜÊ¥ªË∑ÉÁâáÊÆµÊåâÊ∞¥Âπ≥ËøûÊé•ÂàÜÁªÑ
                            // Âè™ÊúâÁúüÊ≠£Ê∞¥Âπ≥Êé•Ëß¶ÁöÑÁâáÊÆµÊâçÂú®Âêå‰∏ÄÁªÑ
                            const groups = [];
                            const used = new Set();

                            activeSlices.forEach((slice, idx) => {
                                if (used.has(idx)) return;

                                // ÂºÄÂßã‰∏Ä‰∏™Êñ∞ÁöÑËøûÊé•ÁªÑ
                                const group = [slice];
                                used.add(idx);

                                // BFS ÊâæÂá∫ÊâÄÊúâ‰∏éÂΩìÂâçÁâáÊÆµÊ∞¥Âπ≥ËøûÊé•ÁöÑÁâáÊÆµ
                                const queue = [slice];
                                while (queue.length > 0) {
                                    const curr = queue.shift();
                                    const currLeft = curr.cIdx + curr.left;
                                    const currRight = currLeft + curr.w;

                                    activeSlices.forEach((cand, candIdx) => {
                                        if (used.has(candIdx)) return;
                                        const candLeft = cand.cIdx + cand.left;
                                        const candRight = candLeft + cand.w;

                                        // Ê£ÄÊü•ÊòØÂê¶Ê∞¥Âπ≥Êé•Ëß¶ÔºàÊúâÈáçÂè†ÊàñÁ¥ßÈÇªÔºâ
                                        const touches = (currRight >= candLeft - 0.05) && (candRight >= currLeft - 0.05);
                                        if (touches) {
                                            group.push(cand);
                                            used.add(candIdx);
                                            queue.push(cand);
                                        }
                                    });
                                }

                                groups.push(group);
                            });

                            // ÂØπÊØè‰∏™ËøûÊé•ÁªÑËÆ°ÁÆóÈù¢ÁßØÔºåÈÄâÊã©ÊúÄÂ§ßÁöÑ
                            groups.forEach(group => {
                                // ËÆ°ÁÆóËØ•ÁªÑÁöÑÂêàÂπ∂ËæπÁïå
                                let groupLeft = Infinity, groupRight = -Infinity;
                                group.forEach(f => {
                                    const left = f.cIdx + f.left;
                                    const right = left + f.w;
                                    groupLeft = Math.min(groupLeft, left);
                                    groupRight = Math.max(groupRight, right);
                                });

                                const groupWidth = groupRight - groupLeft;

                                // ËÆ°ÁÆóËØ•ÁªÑÁöÑÂÖ¨ÂÖ±Êó∂Èó¥ËåÉÂõ¥
                                let commonStart = -Infinity, commonEnd = Infinity;
                                group.forEach(f => {
                                    commonStart = Math.max(commonStart, f.start);
                                    commonEnd = Math.min(commonEnd, f.end);
                                });
                                const commonDuration = Math.max(0, commonEnd - commonStart);

                                // ËØÑÂàÜ = ÂÆΩÂ∫¶ √ó ‚àöÊó∂Èó¥Ë∑®Â∫¶
                                const score = groupWidth * Math.sqrt(commonDuration);

                                if (score > maxSliceArea) {
                                    maxSliceArea = score;

                                    // [Fix] ‰ΩøÁî®ËØ•ÁªÑÁâáÊÆµÁöÑÈù¢ÁßØÂä†ÊùÉ‰∏≠ÂøÉÔºàX Âíå YÔºâ
                                    let weightedCenterX = 0;
                                    let weightedCenterY = 0;
                                    let totalGroupArea = 0;
                                    group.forEach(f => {
                                        const sliceCenterX = f.cIdx + f.left + f.w / 2;
                                        const sliceCenterY = (f.start + f.end) / 2;  // ÁâáÊÆµÁöÑÊó∂Èó¥‰∏≠ÁÇπ
                                        const sliceArea = f.w * f.dur;  // ‰ΩøÁî®ÁâáÊÆµËá™Ë∫´ÁöÑÊó∂Èó¥Ë∑®Â∫¶
                                        weightedCenterX += sliceCenterX * sliceArea;
                                        weightedCenterY += sliceCenterY * sliceArea;
                                        totalGroupArea += sliceArea;
                                    });
                                    const centerX = totalGroupArea > 0
                                        ? (weightedCenterX / totalGroupArea) * colWidth
                                        : (groupLeft + groupWidth / 2) * colWidth;
                                    const centerY = totalGroupArea > 0
                                        ? (weightedCenterY / totalGroupArea)
                                        : (commonStart + commonEnd) / 2;

                                    bestSlice = {
                                        x: centerX,
                                        y: centerY,  // ‰ΩøÁî®Âä†ÊùÉ‰∏≠ÂøÉ Y
                                        w: groupWidth * colWidth,
                                        h: commonDuration,
                                        left: groupLeft * colWidth,
                                        right: groupRight * colWidth,
                                        top: commonStart,
                                        bottom: commonEnd
                                    };
                                }
                            });
                        }

                        if (totalArea === 0) return null;

                        const finalX = weightedX / totalArea;
                        const finalY = weightedY / totalArea;
                        const fullHeight = maxTime - minTime;
                        const effectiveWidthPx = (totalArea / Math.max(fullHeight, 1)) * colWidth;
                        const boundingWidthPx = (maxC - minC + 1) * colWidth;
                        const colSpan = maxC - minC + 1;

                        // [Fix] ËÆ°ÁÆóËøô‰∏™ cluster ÁöÑÁ≤æÁ°ÆËæπÁïåÊ°ÜÔºàÂÉèÁ¥†ÂùêÊ†áÔºâ
                        // ËÄå‰∏çÊòØÊï¥‰∏™ÊîøÊùÉÁöÑËÅîÂêàËæπÁïåÊ°Ü
                        let clusterMinX = Infinity, clusterMaxX = -Infinity;
                        let clusterMinY = Infinity, clusterMaxY = -Infinity;

                        cluster.forEach(f => {
                            const left = (f.cIdx + f.left) * colWidth;
                            const right = left + f.w * colWidth;
                            clusterMinX = Math.min(clusterMinX, left);
                            clusterMaxX = Math.max(clusterMaxX, right);
                            // Ê≥®ÊÑèÔºöËøôÈáåÁöÑ Y ÊòØÂπ¥‰ªΩÔºåÈúÄË¶ÅÂú®‰ΩøÁî®Êó∂ËΩ¨Êç¢‰∏∫ÂÉèÁ¥†
                            clusterMinY = Math.min(clusterMinY, f.start);
                            clusterMaxY = Math.max(clusterMaxY, f.end);
                        });

                        return {
                            x: finalX,
                            y: finalY,
                            bestSlice: bestSlice,
                            w: effectiveWidthPx,
                            fullW: boundingWidthPx,
                            colSpan: colSpan,
                            h: fullHeight,
                            area: totalArea,
                            // [Fix] Ê∑ªÂä† cluster ÁöÑËæπÁïåÊ°ÜÔºàÊ≥®ÊÑè Y ÊòØÂπ¥‰ªΩÔºâ
                            clusterBounds: {
                                minX: clusterMinX,
                                maxX: clusterMaxX,
                                minY: clusterMinY,  // Âπ¥‰ªΩ
                                maxY: clusterMaxY   // Âπ¥‰ªΩ
                            }
                        };
                    }).filter(r => r !== null);

                    if (group.explicitTier == 1) {
                        results.sort((a, b) => b.area - a.area);
                        return [results[0]];
                    }

                    return results.filter(r => r.area > 5);
                }
            },

            render: {
                drawAll: function () {
                    // ÊÅ¢Â§ç‰∏•Ê†ºÁ¢∞ÊíûÊ£ÄÊµãÔºå‰∏ç‰ΩøÁî® Monkey Patch
                    collisionMgr.reset();

                    Core.state.regimeGroups.forEach(g => g.visualSlices = []);

                    let container = document.getElementById('chart-container');
                    if (!container) return;

                    let headerBody = document.getElementById('header-body');
                    let ticksLayer = document.getElementById('ticks-layer');
                    let renderArea = document.getElementById('render-area');

                    headerBody.innerHTML = '';
                    ticksLayer.innerHTML = '<div id="crosshair-label"></div>';
                    document.getElementById('blocks-layer').innerHTML = '';
                    document.getElementById('labels-layer').innerHTML = '';
                    document.getElementById('connections-layer').innerHTML = '';

                    if (!Core.state.regions || Core.state.regions.length === 0) return;

                    let totalHeight = (APP_CONFIG.maxYear - APP_CONFIG.minYear) * Core.state.zoom + 100;
                    let colCount = Core.state.regions.length;

                    ticksLayer.style.height = totalHeight + 'px';
                    renderArea.style.height = totalHeight + 'px';

                    Core.state.regions.forEach((r, i) => {
                        let el = document.createElement('div');
                        el.className = 'header-col-label';
                        el.style.left = (i / colCount) * 100 + '%'; el.style.width = (1 / colCount) * 100 + '%'; el.innerText = r.label;
                        headerBody.appendChild(el);
                    });

                    let tickFrag = document.createDocumentFragment();
                    for (let y = APP_CONFIG.minYear; y <= APP_CONFIG.maxYear; y += 100) {
                        let top = (y - APP_CONFIG.minYear) * Core.state.zoom;
                        if (top < 0) continue;
                        let el = document.createElement('div'); el.className = 'timeline-tick-label';
                        el.style.top = top + 'px'; el.innerText = y; tickFrag.appendChild(el);
                    }
                    ticksLayer.appendChild(tickFrag);

                    Core.render.setupInteractions(renderArea, colCount);

                    let fragsByRegion = {};
                    Core.state.regimeGroups.forEach(group => {
                        let style = Core.getStyle(group);
                        let groupId = group.groupId;
                        group.fragments.forEach(f => {
                            if (!fragsByRegion[f.geoCode]) fragsByRegion[f.geoCode] = [];
                            let fragStyle = style;
                            if (f.suzerain) fragStyle = Core.getStyle(group, f);
                            fragsByRegion[f.geoCode].push(Object.assign({}, f, { style: fragStyle, groupName: group.name, groupId: groupId, group: group }));
                        });
                    });

                    let allRenderSlices = [];
                    Core.state.regions.forEach((region, colIdx) => {
                        let fragments = fragsByRegion[region.id];
                        if (fragments) {
                            let slices = Core.logic.sliceFragmentsByRegion(fragments, colIdx, Core.state.regimeGroups, Core.state.regionIndexMap, Core.state.layoutCache);
                            slices.forEach(s => { s.colIdx = colIdx; allRenderSlices.push(s); });
                        }
                    });

                    allRenderSlices.sort((a, b) => {
                        if (a.groupId !== b.groupId) return a.groupId.localeCompare(b.groupId);
                        if (Math.abs(a.displayStart - b.displayStart) > 0.1) return a.displayStart - b.displayStart;
                        return a.colIdx - b.colIdx;
                    });

                    let mergedSlices = [];
                    if (allRenderSlices.length > 0) {
                        let currentMerge = allRenderSlices[0];
                        currentMerge.colspan = 1;
                        currentMerge.startCol = currentMerge.colIdx;
                        // [Fix] Á¥ØÂä†ÂÆûÈôÖÂÆΩÂ∫¶Ôºà‰ª•"ÂàóÂÆΩÁôæÂàÜÊØîÂçï‰Ωç"ËÆ°ÁÆóÔºâ
                        // ‰æãÂ¶ÇÔºö100% ÂÆΩÂ∫¶ = 1.0 ‰∏™ÂàóÂÆΩÂçï‰ΩçÔºå50% ÂÆΩÂ∫¶ = 0.5 ‰∏™ÂàóÂÆΩÂçï‰Ωç
                        currentMerge.totalWidthUnits = currentMerge.widthPct / 100;

                        for (let i = 1; i < allRenderSlices.length; i++) {
                            let next = allRenderSlices[i];
                            let prev = currentMerge;

                            // [Fix] ÂêàÂπ∂Êù°‰ª∂Ôºö
                            // 1. ÂêåÊîøÊùÉ„ÄÅÁõ∏ÈÇªÂàó„ÄÅÊó∂Èó¥ÂØπÈΩê
                            // 2. ËæπÁºòÂØπÈΩêÔºöprev ÂøÖÈ°ªÂç†Êª°Âè≥ËæπÁºòÔºånext ÂøÖÈ°ª‰ªéÂ∑¶ËæπÁºòÂºÄÂßã
                            // 3. [NEW] ‰∏çËÉΩÊòØÁã¨Âç†Êï¥ÂàóÁöÑÊÉÖÂÜµÔºàÁã¨Âç†ÊîøÊùÉÂèØËÉΩÂè™ÊòØÁ¢∞Â∑ßÂêåÂêçÔºå‰∏çÂ∫îÂêàÂπ∂Ôºâ
                            let basicMatch = next.groupId === prev.groupId &&
                                next.colIdx === (prev.startCol + prev.colspan) &&
                                Math.abs(next.displayStart - prev.displayStart) < 0.1 &&
                                Math.abs(next.displayEnd - prev.displayEnd) < 0.1;

                            // prev ÂøÖÈ°ªÂç†ÊçÆËØ•ÂàóÁöÑÊúÄÂè≥‰æßÔºàÁã¨Âç†ÊàñÂè≥ËæπÁºòÂØπÈΩêÔºâ
                            let prevRightEdge = (prev.leftPct + prev.widthPct) >= 95;
                            // next ÂøÖÈ°ª‰ªéÂ∑¶ËæπÁºòÂºÄÂßã
                            let nextLeftEdge = next.leftPct <= 5;

                            // [Fix] Á¶ÅÊ≠¢ÂêàÂπ∂Áã¨Âç†Êï¥ÂàóÁöÑÊÉÖÂÜµ
                            // Â¶ÇÊûúprevÊàñnextÁã¨Âç†Êï¥ÂàóÔºàwidthPct >= 95ÔºâÔºå‰∏çÂêàÂπ∂
                            let prevIsFullWidth = prev.widthPct >= 95;
                            let nextIsFullWidth = next.widthPct >= 95;
                            let canMerge = !prevIsFullWidth && !nextIsFullWidth;

                            let isSame = basicMatch && prevRightEdge && nextLeftEdge && canMerge;
                            if (isSame) {
                                currentMerge.colspan++;
                                // [Fix] Á¥ØÂä† next ÁöÑÂÆûÈôÖÂÆΩÂ∫¶
                                currentMerge.totalWidthUnits += next.widthPct / 100;
                            }
                            else {
                                mergedSlices.push(currentMerge);
                                currentMerge = next;
                                currentMerge.colspan = 1;
                                currentMerge.startCol = currentMerge.colIdx;
                                currentMerge.totalWidthUnits = currentMerge.widthPct / 100;
                            }
                        }
                        mergedSlices.push(currentMerge);
                    }

                    let blocksFrag = document.createDocumentFragment();
                    mergedSlices.forEach(slice => {
                        let top = (slice.displayStart - APP_CONFIG.minYear) * Core.state.zoom;
                        let h = Math.max((slice.displayEnd - slice.displayStart) * Core.state.zoom, 1);
                        let el = document.createElement('div');

                        el.className = 'era-block-fragment ' + slice.style.className + ' ' + slice.groupId;
                        el.style.backgroundColor = slice.style.bg;
                        if (slice.style.pattern) el.style.setProperty('--pat-color', slice.style.pattern);

                        if (slice.style.className.includes('texture-V') || slice.style.className.includes('texture-VJ')) {
                            el.style.borderStyle = 'dashed'; el.style.borderColor = slice.style.border; el.style.borderWidth = '2px';
                            el.style.zIndex = parseInt(el.style.zIndex || 10) + 1;
                        } else {
                            el.style.border = '1px solid rgba(0,0,0,0.1)';
                        }

                        let isLeft = slice.startCol === 0;
                        let isRight = (slice.startCol + slice.colspan) === colCount;
                        let checkNeighbor = (c) => allRenderSlices.some(o => o.colIdx === c && o.groupId === slice.groupId && Math.max(slice.displayStart, o.displayStart) < Math.min(slice.displayEnd, o.displayEnd));
                        let hasL = checkNeighbor(slice.startCol - 1);
                        let hasR = checkNeighbor(slice.startCol + slice.colspan);

                        if (hasL || (slice.colspan > 1 && !isLeft)) el.classList.add('no-border-left');
                        if (hasR || (slice.colspan > 1 && !isRight)) el.classList.add('no-border-right');

                        let colWidthPct = 100 / colCount;
                        // [Fix] ‰ΩøÁî®Á¥ØÂä†ÁöÑÂÆûÈôÖÂÆΩÂ∫¶ÔºåËÄåÈùû colspan * widthPct
                        let totalWidthPct = slice.totalWidthUnits * colWidthPct;
                        let totalLeftPct = (slice.startCol * colWidthPct) + ((slice.leftPct / 100) * colWidthPct);

                        el.style.left = totalLeftPct + '%';

                        if ((hasL || hasR || slice.colspan > 1) && slice.widthPct >= 95) {
                            el.style.width = `calc(${totalWidthPct}% + 1px)`;
                            if (hasL || (!isLeft && slice.colspan > 1)) el.style.marginLeft = '-1px';
                        } else {
                            el.style.width = totalWidthPct + '%';
                        }

                        el.style.top = top + 'px'; el.style.height = h + 'px';
                        // [Fix] ÊâÄÊúâËâ≤Âùó‰ΩøÁî®Áªü‰∏ÄÁöÑ z-indexÔºå‰∏ç‰ºö‰∫íÁõ∏Ë¶ÜÁõñ
                        el.style.zIndex = 10;
                        el.__data__ = { group: slice.group, style: slice.style, fragment: slice };

                        el.onmouseenter = () => {
                            if (!Core.state.selectedRegimeId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.add('group-hovered'));
                                if (Core.state.features.connections) Core.render.drawConnections(slice.group, '#fff');
                                // [New] Highlight Header based on this block's region
                                if (slice.geoCode) Core.ui.highlightHeader(slice.geoCode);
                            }
                        };
                        el.onmouseleave = () => {
                            if (!Core.state.selectedRegimeId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.remove('group-hovered'));
                                document.getElementById('connections-layer').innerHTML = '';
                                // [New] Clear Header Highlight
                                Core.ui.clearHeaderHighlight();
                            }
                        };

                        blocksFrag.appendChild(el);
                    });
                    document.getElementById('blocks-layer').appendChild(blocksFrag);

                    Core.render.drawLabels(colCount);

                    // [Fix] Redrawing destroys all DOM elements, so we MUST restore specific focus styles if active
                    // This handles cases where resize/display-change triggers redraw during a jump animation
                    if (Core.state.selectedRegimeId) {
                        // Use setTimeout to ensure DOM is fully ready
                        setTimeout(() => {
                            if (Core.ui && Core.ui.setFocus) {
                                Core.ui.setFocus(Core.state.selectedRegimeId);
                            }
                        }, 0);
                    }
                },

                setupInteractions: function (renderArea, colCount) {
                    renderArea.onclick = (e) => {
                        if (e.target.closest('#selection-modal')) return;
                        let clickedBlock = e.target.closest('.era-block-fragment');
                        if (clickedBlock && clickedBlock.__data__) {
                            e.stopPropagation();
                            let d = clickedBlock.__data__;
                            Core.state.lastClickedGeoCode = d.fragment.geoCode;

                            // [Fix] ÊñπÊ°àAÔºöËÆ°ÁÆóÁÇπÂáª‰ΩçÁΩÆÂØπÂ∫îÁöÑÂπ¥‰ªΩÔºà‰∏éÂçÅÂ≠óÁ∫ø‰∏ÄËá¥Ôºâ
                            const rect = renderArea.getBoundingClientRect();
                            const clickY = e.clientY - rect.top;
                            const clickedYear = Math.floor((clickY / Core.state.zoom) + APP_CONFIG.minYear);
                            Core.state.clickedYear = clickedYear;

                            Core.ui.setFocus(d.group.regimeId); // [Refactor] ‰º†ÈÄí group.regimeId
                            Core.ui.showDetails(d.group, d.style);

                            // [Sync] ÁÇπÂáªÊîøÊùÉÊó∂ÔºåÂêëÁà∂Á∫ß‰∏äÊä•Áä∂ÊÄÅÂèòÊõ¥
                            // [Fix] ‰ΩøÁî®ÁÇπÂáª‰ΩçÁΩÆÂπ¥‰ªΩÔºåÁ°Æ‰øù‰∏éÂçÅÂ≠óÁ∫øÊòæÁ§∫‰∏ÄËá¥
                            Core.updateParentState({
                                selectedRegimeId: d.group.regimeId,
                                region: String(d.fragment.geoCode),
                                year: clickedYear
                            });

                            return;
                        }
                        if (!e.target.closest('.era-label')) Core.ui.clearFocus();
                    };
                },

                // --- ÈáçÊûÑÁâà v2.0Ôºö‰ΩøÁî® LabelSystem ËøõË°åÊ∏≤Êüì ---
                drawLabels: function (colCount) {
                    let labelsFrag = document.createDocumentFragment();
                    let renderArea = document.getElementById('render-area');

                    // 1. Ê∏ÖÁêÜÊóßÊ†áÁ≠æ
                    if (renderArea) {
                        const oldItems = renderArea.querySelectorAll('.era-label, .era-dot');
                        oldItems.forEach(el => el.remove());
                    }

                    let colWidthPx = renderArea.scrollWidth / colCount;
                    if (!colWidthPx || colWidthPx < 10) colWidthPx = 100;

                    // 2. Ë∞ÉÁî® LabelSystem ËÆ°ÁÆóÊâÄÊúâ‰ΩçÁΩÆ
                    const results = LabelSystem.computeAll(
                        Core.state.regimeGroups,
                        Core.state.regionIndexMap,
                        colWidthPx,
                        Core.state.zoom
                    );

                    // 3. Ê∏≤ÊüìÁªìÊûú
                    results.forEach(item => {
                        const { group, x, y } = item;

                        // A. ÊàêÂäüÊîæÁΩÆÊñáÂ≠óÊ†áÁ≠æ
                        if (!item.failed) {
                            const { layout } = item;
                            const tier = parseInt(group.explicitTier) || 3;

                            let label = document.createElement('div');
                            let layoutClass = '';

                            // [v2.0] Ê†πÊçÆÂ∏ÉÂ±ÄÁ±ªÂûãËÆæÁΩÆ CSS Á±ª
                            if (layout.type === 'V') {
                                layoutClass = 'vertical-text';
                            } else if (layout.type === 'H2') {
                                layoutClass = 'label-h2';  // Êñ∞Â¢ûÔºö‰∏§Ë°åÂ∏ÉÂ±Ä
                            }

                            label.className = `era-label label-tier-${tier} ${group.groupId} ${layoutClass}`;

                            // [v2.0] H2 Á±ªÂûãÔºöÂ∞ÜÂêçÁß∞ÊãÜÂàÜ‰∏∫‰∏§Ë°å
                            if (layout.type === 'H2') {
                                const name = group.name;
                                const midPoint = Math.ceil(name.length / 2);
                                const line1 = name.substring(0, midPoint);
                                const line2 = name.substring(midPoint);
                                label.innerHTML = `<span>${line1}</span><span>${line2}</span>`;
                            } else {
                                label.innerText = group.name;
                            }

                            // Â±Ö‰∏≠ÂÆö‰Ωç
                            // [DEBUG] Ê∏≤ÊüìÂ±ÇË∞ÉËØï
                            if (['ÂÆâ‰∏úÈÉΩÊä§Â∫ú', 'ÂêêËïÉÁéãÊúù'].includes(group.name)) {
                                console.log(`[RENDER] ${group.name}:`, { x, y, bbox: item.bbox });
                            }
                            label.style.left = x + 'px';
                            label.style.top = y + 'px';

                            // ÂÆΩÂ∫¶Â§ÑÁêÜ
                            if (layout.type === 'H2') {
                                label.style.width = layout.w + 'px';
                            } else if (layout.type === 'H') {
                                label.style.whiteSpace = 'nowrap';
                            }

                            label.style.fontSize = layout.fs + 'px';
                            label.style.lineHeight = (layout.type === 'H2') ? '1.2' : '1';

                            if (Core.state.selectedRegimeId === group.regimeId) {
                                label.classList.add('is-focused');
                            }

                            labelsFrag.appendChild(label);
                        }
                        // B. ÊîæÁΩÆÂ§±Ë¥• -> ÈôçÁ∫ß‰∏∫Â∞èÂúÜÁÇπ
                        else {
                            let dotSize = 4;
                            // Â¶ÇÊûúÊòØ Tier 1/2 Â§±Ë¥•ÔºåÂúÜÁÇπÁ®çÂæÆÂ§ß‰∏ÄÁÇπ
                            const tier = parseInt(group.explicitTier) || 3;
                            if (tier <= 2) dotSize = 6;

                            let dot = document.createElement('div');
                            dot.className = `era-dot ${group.groupId}`;
                            dot.style.cssText = `
                                position: absolute;
                                border-radius: 50%;
                                background: rgba(255,255,255,0.4);
                                cursor: help;
                                z-index: 3000;
                                transition: all 0.2s;
                                pointer-events: auto;
                            `;
                            dot.style.left = (x - dotSize / 2) + 'px';
                            dot.style.top = (y - dotSize / 2) + 'px';
                            dot.style.width = dotSize + 'px';
                            dot.style.height = dotSize + 'px';
                            dot.title = group.name; // Èº†Ê†áÊÇ¨ÂÅúÊòæÁ§∫ÂêçÂ≠ó

                            dot.onmouseenter = () => {
                                dot.style.background = 'white';
                                dot.style.transform = 'scale(1.5)';
                                dot.style.boxShadow = '0 0 5px rgba(255,255,255,0.8)';
                            };
                            dot.onmouseleave = () => {
                                dot.style.background = 'rgba(255,255,255,0.4)';
                                dot.style.transform = 'scale(1)';
                                dot.style.boxShadow = 'none';
                            };
                            dot.onclick = (e) => {
                                e.stopPropagation();
                                Core.ui.setFocus(group.regimeId); // [Refactor] ‰º†ÈÄí group.regimeId
                                Core.ui.showDetails(group, Core.getStyle(group));
                            };
                            labelsFrag.appendChild(dot);
                        }
                    });

                    // 4. ÊåÇËΩΩ DOM
                    const labelLayer = document.getElementById('labels-layer');
                    if (labelLayer) {
                        labelLayer.innerHTML = ''; // Ensure clear
                        labelLayer.appendChild(labelsFrag);
                    } else {
                        renderArea.appendChild(labelsFrag);
                    }
                },

                drawConnections: function (group, color) {
                    let svg = document.getElementById('connections-layer');
                    svg.innerHTML = '';
                    let rect = document.getElementById('render-area').getBoundingClientRect();
                    let colW = rect.width / Core.state.regions.length;
                    let points = [];
                    group.fragments.forEach(f => {
                        let idx = Core.state.regionIndexMap[f.geoCode]; if (idx === undefined) return;
                        let top = (f.start - APP_CONFIG.minYear) * Core.state.zoom;
                        let xOffset = f.left + (f.w / 2);
                        if (isNaN(xOffset)) xOffset = 0.5;
                        points.push({ x: (idx + xOffset) * colW, y: top + (f.end - f.start) * Core.state.zoom / 2 });
                    });
                    if (points.length < 2) return;
                    points.sort((a, b) => a.x - b.x);
                    let d = "M " + points[0].x + " " + points[0].y;
                    for (let i = 1; i < points.length; i++) { let p1 = points[i - 1], p2 = points[i]; let mx = (p1.x + p2.x) / 2; d += " C " + mx + " " + p1.y + ", " + mx + " " + p2.y + ", " + p2.x + " " + p2.y; }
                    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", d); path.setAttribute("class", "connection-path"); path.setAttribute("stroke", color);
                    svg.appendChild(path);
                }
            },

            ui: {
                // [New] Highlight Header based on Region Code
                highlightHeader: function (geoCode) {
                    if (!geoCode) return;
                    const idx = Core.state.regionIndexMap[geoCode];
                    if (idx !== undefined) {
                        const headerBody = document.getElementById('header-body');
                        if (headerBody && headerBody.children[idx]) {
                            const target = headerBody.children[idx];
                            const old = headerBody.querySelector('.active-header');
                            if (old && old !== target) old.classList.remove('active-header');
                            target.classList.add('active-header');
                        }
                    }
                },
                clearHeaderHighlight: function () {
                    const headerBody = document.getElementById('header-body');
                    if (headerBody) {
                        const old = headerBody.querySelector('.active-header');
                        if (old) old.classList.remove('active-header');
                    }
                },

                closePanel: function () {
                    document.getElementById('editor-panel').classList.remove('panel-open');
                    Core.ui.clearFocus();
                },
                // [Refactor] setFocus Áé∞Âú®Êé•Âèó group.regimeId (Name|Code Ê†ºÂºè)
                // ÂÜÖÈÉ®ÈÄöËøá id Êü•Êâæ groupÔºåÂÜçÁî® group.groupId (hash) Êìç‰Ωú DOM
                setFocus: function (regimeId) {
                    // [Refactor] setFocus Â∫î‰∏∫ÂπÇÁ≠âÊìç‰ΩúÔºå‰ªÖË¥üË¥£ËÆæÁΩÆÁÑ¶ÁÇπÔºå‰∏çË¥üË¥£ÂèçËΩ¨„ÄÇ
                    // ÂéüÊúâÁöÑ toggle ÈÄªËæëË¢´ÁßªÈô§ÔºåÈò≤Ê≠¢ STATE_SYNC È¢ÑËÆæ ID ÂêéÂØºËá¥Ê≠§Â§ÑÂà§ÂÆö‰∏∫"ÈáçÂ§çÁÇπÂáª"ËÄåËØØÂÖ≥Èó≠„ÄÇ

                    // Êü•ÊâæÂØπÂ∫îÁöÑ group ÂØπË±°
                    const group = Core.state.regimeGroups.find(g => g.regimeId === regimeId);
                    if (!group) {
                        console.warn('[setFocus] Regime not found:', regimeId);
                        return;
                    }

                    // Â≠òÂÇ®ÈÄªËæë ID (Name|Code)
                    Core.state.selectedRegimeId = regimeId;

                    // [Fix] ‰∏äÊä•Áä∂ÊÄÅÁªôÁà∂È°µÈù¢ÔºåÁ°Æ‰øùÂ∑¶‰∏äËßíÂàáÊç¢Êó∂ËÉΩÂêåÊ≠•
                    Core.updateParentState({ selectedRegimeId: regimeId });

                    // DOM Êìç‰Ωú‰ΩøÁî® CSS ÂÆâÂÖ®ÁöÑ groupId (hash)
                    const cssClass = group.groupId;
                    document.body.classList.add('mode-focus');
                    document.querySelectorAll('.group-hovered').forEach(el => el.classList.remove('group-hovered'));
                    document.querySelectorAll('.is-focused').forEach(el => el.classList.remove('is-focused'));
                    document.querySelectorAll('.' + cssClass).forEach(el => el.classList.add('is-focused'));

                    Core.render.drawConnections(group, '#fff');
                },
                clearFocus: function () {
                    // [Sync] Âè™ÊúâÂú®Á°ÆÂÆûÊúâÈÄâ‰∏≠ÁöÑÊÉÖÂÜµ‰∏ãÊâçÈÄöÁü•ÔºåÈÅøÂÖçÂÜó‰Ωô
                    if (Core.state.selectedRegimeId !== null) {
                        Core.updateParentState({ selectedRegimeId: null });
                    }

                    Core.state.selectedRegimeId = null;
                    document.body.classList.remove('mode-focus');

                    // Restore original styles
                    document.querySelectorAll('.is-focused').forEach(el => {
                        el.classList.remove('is-focused');
                    });
                    document.getElementById('connections-layer').innerHTML = '';
                },
                showDetails: function (group, style) {
                    const panel = document.getElementById('editor-panel');
                    if (!panel) return;

                    panel.classList.remove('panel-right', 'panel-left');
                    const totalCols = Core.state.regions.length;
                    const centerRatio = (group.centerCol || 0) / totalCols;
                    panel.classList.add(centerRatio > 0.5 ? 'panel-left' : 'panel-right');
                    requestAnimationFrame(() => panel.classList.add('panel-open'));

                    // 1. ÈÅçÂéÜÊâÄÊúâÁâáÊÆµÔºåÊî∂ÈõÜËØ•ÊîøÊùÉÂéÜÂè≤‰∏äÊâÄÊúâÁöÑÂÆó‰∏ªÂÖ≥Á≥ª
                    const uniqueSuzerains = new Set();

                    group.fragments.forEach(f => {
                        if (!f.suzerain) {
                            uniqueSuzerains.add("Êó†");
                        }
                        else if (f.suzerainName) {
                            let txt = f.suzerainName;

                            // ÊÉÖÂÜµ A: V|J ÂèåÈáçÂÖ≥Á≥ª
                            if (f.suzerainType === 'V|J' && txt.includes('|')) {
                                const parts = txt.split('|');
                                const nameV = parts[0];
                                const nameJ = parts[1] || parts[0];
                                txt = `${nameJ} (ÁæÅÁ∏ª) & ${nameV} (Ëó©Â±û)`;
                            }
                            // ÊÉÖÂÜµ B: Âçï‰∏ÄÂÖ≥Á≥ª
                            else if (f.suzerainType) {
                                const typeMap = { 'V': 'Ëó©Â±û', 'J': 'ÁæÅÁ∏ª' };
                                const typeName = typeMap[f.suzerainType] || f.suzerainType;
                                txt = `${txt} (${typeName})`;
                            }

                            uniqueSuzerains.add(txt);
                        }
                    });

                    // 2. ÁîüÊàê HTML (‰øùÊåÅÂéüÈÄªËæë‰∏çÂèò)
                    let suzerainHtml = '';
                    const hasOverlay = Array.from(uniqueSuzerains).some(s => s !== "Êó†");

                    if (hasOverlay) {
                        const list = Array.from(uniqueSuzerains).join(' <span style="color:var(--slate-500)">/</span> ');
                        suzerainHtml = `<div class="suzerain-tag">ÂÆó‰∏ª: ${list}</div>`;
                    }

                    const f0 = group.fragments[0];
                    const typeMap = { 'C': '‰∏≠Âéü', 'Q': 'ÂæÅÊúç', 'R': 'Ââ≤ÊçÆ', 'N': 'ÈÉ®Êóè', 'F': 'ËæπÁñÜ', 'T': 'ËøáÊ∏°', 'V': 'Ëó©Â±û' };
                    const typeLabel = typeMap[group.regimeCode.charAt(0)] || 'Êú™Áü•';

                    let originLabel = f0.geoCode;
                    const originRegion = Core.state.rawRegions.find(r => r.id == f0.geoCode);
                    if (originRegion) originLabel = originRegion.label;

                    let detailHtml = '';
                    const fragsByGeo = {};
                    group.fragments.forEach(f => {
                        if (!fragsByGeo[f.geoCode]) fragsByGeo[f.geoCode] = [];
                        fragsByGeo[f.geoCode].push(f);
                    });

                    const sortedGeoCodes = Object.keys(fragsByGeo).sort((a, b) =>
                        (Core.state.regionIndexMap[a] || 0) - (Core.state.regionIndexMap[b] || 0)
                    );

                    const totalDur = Math.max(group.maxEnd - group.minStart, 1);

                    sortedGeoCodes.forEach(geoCode => {
                        const frags = fragsByGeo[geoCode];
                        frags.sort((a, b) => a.start - b.start);

                        let barsHtml = '';
                        let timeTexts = [];

                        // ‰ΩøÁî®Á¥¢Âºï i Êù•Â¢ûÂä† z-index
                        frags.forEach((f, i) => {
                            const left = ((f.start - group.minStart) / totalDur) * 100;
                            const width = ((f.end - f.start) / totalDur) * 100;
                            // [Fix] Use inline styles instead of Tailwind classes
                            barsHtml += `<div style="position:absolute; top:0; left:${left}%; width:${width}%; height:100%; background:${style.bg || '#888'}; opacity:0.9; border-radius:1px; min-width:3px; z-index:${10 + i};"></div>`;
                            timeTexts.push(`${f.start}~${f.end}`);
                        });

                        const regionName = Core.state.rawRegions.find(r => r.id == geoCode)?.label || geoCode;
                        const isCurrent = Core.state.lastClickedGeoCode == geoCode;

                        const rowClass = isCurrent ? 'active-row' : '';
                        const nameClass = isCurrent ? 'active-name' : '';
                        const icon = isCurrent ? 'üëâ ' : '';
                        const timeStr = timeTexts.join(', ');

                        detailHtml += `<div class="region-row ${rowClass}">
                            <div class="region-name ${nameClass}" title="${regionName}">${icon}${regionName}</div>
                            <div class="bar-container">${barsHtml}</div>
                            <div class="time-text" title="${timeStr}">${timeStr}</div>
                        </div>`;
                    });

                    // --- [Êñ∞Â¢ûÈÄªËæë] Â§ÑÁêÜÊ†áÈ¢òÊ†èÊåâÈíÆ ---
                    // [Fix] ‰ºòÂÖà‰ΩøÁî®Áî®Êà∑ÁÇπÂáªÁöÑÁâáÊÆµÂå∫ÂüüÔºåÂÖ∂Ê¨°ÊòØ lastClickedGeoCodeÔºåÊúÄÂêéÊòØÊîøÊùÉÁöÑÁ¨¨‰∏Ä‰∏™Âå∫Âüü
                    // ËøôÁ°Æ‰øù‰∫Ü‰ªé‰ªª‰ΩïÂÖ•Âè£ÁÇπÂáªÈÉΩËÉΩË∑≥ËΩ¨Âà∞Ê≠£Á°ÆÁöÑÂå∫Âüü
                    const targetGeo = Core.state.lastClickedGeoCode || (sortedGeoCodes.length > 0 ? sortedGeoCodes[0] : null);

                    // ÊûÑÂª∫Ë∑≥ËΩ¨ÂèÇÊï∞ÂØπË±°
                    // [Fix] ÊñπÊ°àAÔºö‰ºòÂÖà‰ΩøÁî®ÁÇπÂáª‰ΩçÁΩÆÂπ¥‰ªΩÔºà‰∏éÂçÅÂ≠óÁ∫ø‰∏ÄËá¥ÔºâÔºåfallback Âà∞ËßÜÂè£‰∏≠ÂøÉÂπ¥‰ªΩ
                    const yearToUse = Core.state.clickedYear || (window.getCenterYear ? window.getCenterYear() : group.minStart + 1);

                    const jumpPayload = {
                        target: 'map',
                        params: {
                            region: targetGeo,
                            // [Fix] ‰ΩøÁî®ÁÇπÂáª‰ΩçÁΩÆÂπ¥‰ªΩÔºåÁ°Æ‰øù‰∏éÁî®Êà∑Êìç‰ΩúÊó∂ÁúãÂà∞ÁöÑÂçÅÂ≠óÁ∫ø‰∏ÄËá¥
                            year: yearToUse,
                            regime: group.name,
                            // [Fix] ‰º†ÈÄíÂÆåÊï¥ÁöÑ regimeIdÔºåËÆ©Âú∞ÂõæÈ°µËÉΩÂ§üËá™Âä®ÈîÅÂÆöËØ•ÊîøÊùÉ
                            selectedRegimeId: group.regimeId
                        }
                    };

                    // Ëé∑ÂèñÂπ∂ÊøÄÊ¥ªÊ†áÈ¢òÊ†èÊåâÈíÆ
                    const jumpBtn = document.getElementById('btn-jump-map-header');
                    if (jumpBtn) {
                        jumpBtn.classList.add('active-btn'); // ÊòæÁ§∫ (CSS Controlled)
                        // ÁßªÈô§ÊóßÁõëÂê¨Âô® (ÈÄöËøáÂÖãÈöÜËäÇÁÇπÊõøÊç¢)
                        const newBtn = jumpBtn.cloneNode(true);
                        jumpBtn.parentNode.replaceChild(newBtn, jumpBtn);

                        // ÁªëÂÆöÊñ∞‰∫ã‰ª∂
                        newBtn.onclick = () => {
                            window.parent.postMessage({ type: "REQUEST_SWITCH", payload: jumpPayload }, window.location.origin);
                        };
                    }

                    // --- [Êõ¥Êñ∞Ê∏≤Êüì] ÁßªÈô§ÂÜÖÂÆπÂå∫ÁöÑÂ§ßÊåâÈíÆ ---
                    document.getElementById('editor-content').innerHTML = `
                        <div class="regime-card" style="background: ${style.bg}; color: ${style.text};">
                            <h3 class="regime-card-title">${group.name}</h3>
                            
                            <div class="regime-info-row">
                                <span class="info-badge" title="Regime Code">Code: ${group.regimeCode}</span>
                                <span class="info-badge" title="Tier Level">Tier: ${group.explicitTier}</span>
                                <span class="info-badge" title="ÊîøÊùÉÁ±ªÂûã">Type: ${typeLabel}</span>
                                <span class="info-badge" title="Ëµ∑Ê∫êÂå∫Âüü">Origin: ${originLabel}</span>
                            </div>

                            ${suzerainHtml}
                        </div>
                        
                        <div class="section-box details-gap">
                             <h4 class="section-title">ÁªüËæñÂå∫Âüü (${sortedGeoCodes.length})</h4>
                             <div class="custom-scrollbar" style="max-height:300px; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">${detailHtml}</div>
                        </div>
                    `;
                },
                populateSearchResults: function (term) {
                    const container = document.getElementById('search-results');
                    if (!term || term.length < 1) { container.style.display = 'none'; return; }

                    const seen = new Set();
                    const results = Core.state.regimeGroups.filter(g => {
                        if (g.name.toLowerCase().includes(term) && !seen.has(g.name)) { seen.add(g.name); return true; }
                        return false;
                    }).slice(0, 10);

                    if (results.length === 0) { container.style.display = 'none'; return; }

                    container.innerHTML = '';
                    results.forEach(g => {
                        const div = document.createElement('div');
                        div.className = 'search-item';
                        div.innerHTML = `<span>${g.name}</span> <span style="font-size:9px; color:var(--slate-500); margin-left:0.5rem">(${g.minStart})</span>`;
                        div.onclick = () => {
                            this.jumpToRegime(g);

                            // [Sync] ÊêúÁ¥¢ÈÄâ‰∏≠Êó∂ÔºåÂêëÁà∂Á∫ß‰∏äÊä•Áä∂ÊÄÅÂèòÊõ¥
                            Core.updateParentState({
                                selectedRegimeId: g.regimeId,
                                year: window.getCenterYear ? window.getCenterYear() : undefined
                            });

                            document.getElementById('search-input').value = '';
                            container.style.display = 'none';
                            document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));
                        };
                        container.appendChild(div);
                    });
                    container.style.display = 'block';
                },
                jumpToRegime: function (group, targetYearOrSkip = false) {
                    const renderArea = document.getElementById('render-area');
                    const mainContent = document.getElementById('main-content');

                    const colWidth = renderArea.scrollWidth / Core.state.regions.length;
                    const targetX = (group.centerCol + 0.5) * colWidth;

                    // Determine Target Y
                    let targetY;
                    if (typeof targetYearOrSkip === 'number') {
                        // Priority 1: Specified Year (from handleJump)
                        targetY = (targetYearOrSkip - APP_CONFIG.minYear) * Core.state.zoom;
                    } else if (targetYearOrSkip === true) {
                        // Priority 2: Keep Current Y (Skip)
                        targetY = undefined;
                    } else {
                        // Priority 3: Smart Default
                        // Â¶ÇÊûúÂΩìÂâçÂπ¥‰ªΩ (Core.state.year) Âú®ÊîøÊùÉÂ≠òÁª≠ËåÉÂõ¥ÂÜÖÔºåÂàôÁª¥ÊåÅÂú®ËØ•Âπ¥‰ªΩ
                        // Âê¶ÂàôÔºàÂ¶Ç‰ªéÂÖ∂‰ªñÊó∂‰∏çÁõ∏ÂÖ≥ÁöÑÈ°µÈù¢Ë∑≥ËΩ¨ÔºâÔºåÊâçÂõûÊªöÂà∞ÊîøÊùÉËµ∑ÂßãÂπ¥‰ªΩ
                        const currentYear = Core.state.year;
                        if (currentYear >= group.minStart && currentYear <= group.maxEnd) {
                            console.log(`[Jump] Keeping year ${currentYear} (within regime range)`);
                            targetY = (currentYear - APP_CONFIG.minYear) * Core.state.zoom;
                        } else {
                            // Default to Regime Start
                            targetY = (group.minStart - APP_CONFIG.minYear) * Core.state.zoom;
                        }
                    }

                    if (targetY === undefined) {
                        // Âè™ÂÅöÊ∞¥Âπ≥ÊªöÂä®Ôºå‰∏çÂπ≤Êâ∞ÂûÇÁõ¥ÊªöÂä®
                        // Áõ¥Êé•ËÆæÁΩÆ scrollLeft Á°Æ‰øù‰∏çÂΩ±Âìç scrollTop
                        const targetLeft = Math.max(0, targetX - window.innerWidth / 2);
                        mainContent.scrollLeft = targetLeft;
                    } else {
                        // ÂêåÊó∂ÊªöÂä®Âà∞ÊîøÊùÉ‰ΩçÁΩÆÔºàÊ∞¥Âπ≥+ÂûÇÁõ¥Ôºâ
                        const targetTop = targetY - (window.innerHeight / 2);
                        // [Optimize] Â¶ÇÊûúË∑ùÁ¶ªËøáËøú (>5000px)Ôºå‰ΩøÁî®Áû¨Áßª‰ª•Èò≤Ê≠¢ÂÜóÈïøÁöÑÊªöÂä®Âä®ÁîªÔºàÂ¶Ç‰ªéÈ°∂ÈÉ®ÂàùÂßãÂåñÊó∂Ôºâ
                        // Âê¶Âàô‰ΩøÁî®Âπ≥ÊªëÊªöÂä®Êèê‰æõÊõ¥Â•ΩÁöÑ‰ΩìÈ™å
                        const dist = Math.abs(mainContent.scrollTop - targetTop);
                        const behavior = dist > 5000 ? 'auto' : 'smooth';

                        // [Sync Protection] Ê†áËÆ∞‰∏∫Á®ãÂ∫èÂåñÊªöÂä®ÔºåÈò≤Ê≠¢ _setupScrollSync Âú®ÊªöÂä®ËøáÁ®ã‰∏≠‰∏äÊä•‰∏≠Èó¥Áä∂ÊÄÅ
                        window._isProgrammaticScroll = true;

                        mainContent.scrollTo({
                            left: targetX - window.innerWidth / 2,
                            top: targetTop,
                            behavior: behavior
                        });

                        setTimeout(() => { window._isProgrammaticScroll = false; }, 1000);
                    }
                    // [Clean] ÁßªÈô§‰∫Ü programmaticScroll ‰øùÊä§ÈÄªËæëÔºåÂõ†‰∏∫‰∏çÂÜçÈúÄË¶ÅÈò≤Ê≠¢ conflict
                    setTimeout(() => {
                        Core.ui.setFocus(group.regimeId); // [Refactor] ‰º†ÈÄí group.regimeId
                        Core.ui.showDetails(group, Core.getStyle(group));
                    }, 500);
                }
            },

            toggleFeature: function (f) {
                this.state.features[f] = !this.state.features[f];
                document.getElementById('btn-' + f).classList.toggle('active');
                if (f === 'connections') this.render.drawAll();
            }
        };

        const collisionMgr = { rects: [], add: function (x, y, w, h, tier) { const n = { l: x + 1, t: y + 1, r: x + w - 1, b: y + h - 1 }; if (tier <= 1) { this.rects.push(n); return true; } for (let r of this.rects) if (n.l < r.r && n.r > r.l && n.t < r.b && n.b > r.t) return false; this.rects.push(n); return true; }, reset: function () { this.rects = [] } };

        document.addEventListener('DOMContentLoaded', () => Core.init());
        // [Sync] Êö¥Èú≤ÁªôÁà∂Á∫ßÁöÑÂêåÊ≠• API
        window.getCenterYear = function () {
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return 2025;
            const zoom = Core.state.zoom || 1.5;
            // ËÆ°ÁÆó‰∏≠ÂøÉÁÇπÂØπÂ∫îÁöÑÂπ¥‰ªΩÔºö APP_CONFIG.minYear + (scrollTop + clientH/2) / zoom
            const midPx = el.scrollTop + (el.clientHeight / 2);
            const year = APP_CONFIG.minYear + (midPx / zoom);
            return Math.round(year);
        };

        window._pendingScrollYear = null;

        window.scrollToYear = function (year) {
            if (typeof year !== 'number' || isNaN(year)) return;
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return;

            // [Fix] Â¶ÇÊûúÊï∞ÊçÆÂ∞öÊú™ReadyÔºàÈ´òÂ∫¶ÂèØËÉΩ‰∏çÂØπÔºâÔºåÊöÇÂ≠òËØ∑Ê±Ç
            if (!Core.state.dataReady || el.scrollHeight < 1000) {
                console.log(`[Panorama] Pending scroll to ${year} until ready`);
                window._pendingScrollYear = year;
                return;
            }

            const zoom = Core.state.zoom || 1.5;
            const targetPx = (year - APP_CONFIG.minYear) * zoom;
            const centerOffset = el.clientHeight / 2;
            el.scrollTo({ top: targetPx - centerOffset, behavior: 'auto' }); // auto Êõ¥Âø´Ôºåsmooth ÂèØËÉΩÊúâÂª∂Ëøü
        };
    </script>
</body>

</html>