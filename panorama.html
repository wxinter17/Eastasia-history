<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¨æ™¯é¡µ v11.08</title>

    <!-- ğŸ”‘ å…¨å±€ç‰ˆæœ¬æ§åˆ¶ -->
    <script>
        window.APP_VERSION = '2026.01.11.001';
    </script>

    <!-- [Unified CSS] Native Style (Merged) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@500;700;900&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <style id="dynamic-styles"></style>

    <style>
        /* =========================================
           EastAsia History - Standard Styles (v1.0)
           Replaces Tailwind CSS with native CSS
           ========================================= */

        :root {
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;
            --slate-950: #020617;

            --blue-300: #93c5fd;
            --blue-400: #60a5fa;
            --blue-500: #3b82f6;
            --blue-600: #2563eb;

            --amber-300: #fcd34d;
            --amber-500: #f59e0b;
        }

        /* --- åŸºç¡€è®¾ç½® --- */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: var(--slate-900);
            color: var(--slate-300);
            font-family: 'Inter', -apple-system, sans-serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .pano-body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 14px;
            background: var(--slate-950);
        }

        #main-content {
            position: relative;
            width: 100%;
            height: calc(100% - 3rem);
            overflow: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            z-index: 1;
            will-change: scroll-position;
        }

        #chart-container {
            position: relative;
            min-width: 1400px;
            display: block;
            contain: layout;
        }

        /* --- Sticky å¸ƒå±€ --- */
        #sticky-header-row {
            position: sticky;
            top: 0;
            z-index: 4000;
            /* [Fix] Raise above labels (which are 2000+3000) */
            display: flex;
            height: 2.5rem;
            border-bottom: 1px solid var(--slate-700);
            background-color: var(--slate-900);
        }

        #header-corner {
            position: sticky;
            left: 0;
            z-index: 4100;
            /* [Fix] Topmost corner */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
        }

        #header-body {
            flex: 1;
            display: flex;
            background-color: var(--slate-900);
            position: relative;
        }

        #chart-body-row {
            display: flex;
            position: relative;
        }

        .sticky-ticks {
            position: sticky;
            left: 0;
            z-index: 3900;
            /* [Fix] High enough but below header */
            width: 3.5rem;
            flex-shrink: 0;
            background-color: var(--slate-900);
            border-right: 1px solid var(--slate-700);
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
        }

        #render-area {
            flex: 1;
            position: relative;
            background-color: var(--slate-900);
            overflow: hidden;
        }

        /* --- Crosshair (è§å…‰çº¿) --- */
        #crosshair-line {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 50, 50, 1);
            box-shadow: 0 0 20px rgba(255, 50, 50, 1), 0 0 40px rgba(255, 50, 50, 0.8), 0 0 6px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1000;
        }

        #crosshair-label {
            display: none;
            position: absolute;
            left: 0.5rem;
            transform: translateY(-50%);
            background: rgba(220, 50, 50, 0.95);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1001;
            font-family: monospace;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Block Styles --- */
        .era-block-fragment {
            position: absolute;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            z-index: 10;
            box-sizing: border-box;
            transition: transform 0.1s ease, opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), filter 0.4s ease;
        }

        .no-border-left {
            border-left: none !important;
        }

        .no-border-right {
            border-right: none !important;
        }

        /* [Fix] Removed conflicting internal hover styles. Rely on SHARED_CSS_STYLES from index.html */

        /* --- Focus Mode --- */
        body.mode-focus .era-block-fragment:not(.is-focused) {
            opacity: 0.08 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
            border-color: transparent !important;
        }

        body.mode-focus .era-block-fragment.is-focused {
            opacity: 1 !important;
            filter: none !important;
            /* [Fix] Do not raise Z-Index above context limit. Just rely on labels-layer being higher. */
            z-index: 50 !important;
            /* [Fix] ç§»é™¤ç™½è‰²è¾¹æ¡† */
            box-shadow: none !important;
            transform: none;
        }

        /* --- Dots Focus Mode --- */
        body.mode-focus .era-dot:not(.is-focused) {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none !important;
        }

        body.mode-focus .era-dot.is-focused {
            opacity: 1 !important;
            filter: none !important;
            transform: scale(1.3);
            /* [Fix] ç§»é™¤ç™½è‰²è¾¹æ¡† */
            box-shadow: none;
        }

        .era-dimmed {
            opacity: 0.1 !important;
            filter: grayscale(100%) !important;
            pointer-events: none;
        }

        /* --- Labels --- */
        .era-label {
            position: absolute;
            z-index: 60;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            transform: translate(-50%, -50%);
            line-height: 1.1;
            text-shadow: -1px -1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
            transition: opacity 0.4s, filter 0.4s, transform 0.3s;
        }

        body.mode-focus .era-label:not(.is-focused) {
            opacity: 0.1 !important;
            filter: blur(1px) grayscale(50%) !important;
            z-index: 60;
        }

        /* [Fix] Label é«˜äº® */
        body.mode-focus .era-label.is-focused {
            opacity: 1 !important;
            filter: none !important;
            z-index: 9000 !important;
            /* Context å†…ç½®é¡¶ */
            transform: translate(-50%, -50%) scale(1.1);
            /* [Fix] ç¡®ä¿æ— ç™½è‰²è¾¹æ¡† */
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        /* [Fix] Progress Bar Style Override */
        .bar-container div {
            min-width: 4px;
            /* é˜²æ­¢è¿‡çª„ä¸å¯è§ */
            height: 100% !important;
            top: 0 !important;
            bottom: 0;
        }

        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 1px;
        }

        .label-wrap {
            white-space: normal !important;
            word-break: break-word;
            line-height: 1.2 !important;
        }

        /* [v2.0] H2 ä¸¤è¡Œæ¨ªæ’å¸ƒå±€ */
        .label-h2 {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            line-height: 1.2 !important;
        }

        .label-h2 span {
            display: block;
        }

        .label-tier-1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-weight: 400;
            letter-spacing: 2px;
            z-index: 70;
        }

        .label-tier-2 {
            font-family: 'Noto Serif SC', serif;
            font-weight: 900;
            z-index: 65;
        }

        .label-tier-3 {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            z-index: 60;
        }

        /* --- Panel & Modals --- */
        /* Editor Panel (Replaces Tailwind classes) */
        #editor-panel {
            position: fixed;
            top: 3rem;
            bottom: 0;
            width: 100%;
            z-index: 400;
            display: flex;
            flex-direction: column;
            background-color: rgba(15, 23, 42, 0.95);
            /* slate-900/95 */
            backdrop-filter: blur(12px);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (min-width: 640px) {
            #editor-panel {
                width: 24rem;
            }
        }

        .panel-right {
            right: 0;
            border-left: 1px solid var(--slate-700);
            transform: translateX(100%);
        }

        .panel-left {
            left: 0;
            border-right: 1px solid var(--slate-700);
            transform: translateX(-100%);
        }

        .panel-open {
            transform: translateX(0) !important;
        }

        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid var(--slate-700);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.5);
        }

        .panel-title {
            font-weight: bold;
            color: var(--blue-400);
        }

        .panel-close-btn {
            color: var(--slate-400);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border: none;
        }

        .panel-close-btn:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .jump-btn {
            display: none;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            background-color: var(--blue-600);
            color: white;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            border: 1px solid rgba(96, 165, 250, 0.5);
            cursor: pointer;
        }

        .jump-btn:hover {
            background-color: var(--blue-500);
        }

        .jump-btn.active-btn {
            display: flex;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        /* Selection Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 9999;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--slate-900);
            border: 1px solid var(--slate-700);
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 24rem;
            overflow: hidden;
        }

        .modal-header {
            padding: 0.75rem;
            border-bottom: 1px solid var(--slate-800);
            background-color: rgba(30, 41, 59, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-400);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .modal-close {
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            color: var(--slate-500);
            cursor: pointer;
            border: none;
            background: transparent;
        }

        .modal-close:hover {
            color: white;
            background-color: var(--slate-700);
        }

        /* --- JS Dynamic Elements Utilities --- */
        .header-col-label {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(51, 65, 85, 0.3);
            /* slate-700/30 */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 2px;
            font-size: 10px;
            cursor: help;
            color: var(--slate-400);
            line-height: 1.25;
            word-break: break-word;
            white-space: normal;
        }

        .header-col-label:hover,
        .header-col-label.active-header {
            color: var(--blue-400);
            background: rgba(255, 255, 255, 0.1);
            z-index: 50;
        }


        .timeline-tick-label {
            position: absolute;
            width: 100%;
            text-align: center;
            /* [Fix] å±…ä¸­å¯¹é½ */
            padding: 0 0.25rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            /* [Fix] å±…ä¸­å¯¹é½ */
            line-height: 1;
            font-size: 11px;
            /* [Fix] å­—å·ç¨å¤§ */
            font-weight: bold;
            /* [Fix] åŠ ç²— */
            color: var(--slate-400);
            /* [Fix] ç¨äº®ä¸€ç‚¹ */
            font-family: monospace;
            height: 0;
        }

        .suzerain-tag {
            margin-top: 0.5rem;
            font-size: 11px;
            color: var(--amber-300);
            border: 1px solid rgba(245, 158, 11, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-block;
            line-height: 1.6;
        }

        /* Modal Animation (æ›¿ä»£ Tailwind animate-in fade-in zoom-in) */
        .modal-content {
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Details Gap */
        .details-gap {
            margin-top: 1rem;
        }

        /* Detail Panel Elements */
        .regime-card {
            padding: 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .regime-card-title {
            font-size: 1.875rem;
            font-weight: 900;
            position: relative;
            z-index: 10;
            font-family: serif;
            margin: 0;
        }

        .regime-info-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0.9;
            font-size: 0.75rem;
            z-index: 10;
            position: relative;
            font-family: monospace;
        }

        .info-badge {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0 0.25rem;
            border-radius: 0.25rem;
        }

        .section-box {
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--slate-700);
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--slate-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--slate-700);
            padding-bottom: 0.5rem;
        }

        .region-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 1.5rem;
            padding: 0 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            transition: background 0.2s;
            font-size: 10px;
            color: var(--slate-300);
        }

        .region-row:hover {
            background-color: rgba(51, 65, 85, 0.3);
        }

        .region-row.active-row {
            background-color: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
        }

        .region-name {
            width: 5rem;
            text-align: right;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .region-name.active-name {
            color: var(--blue-300);
        }

        .bar-container {
            flex: 1;
            height: 0.5rem;
            background-color: rgba(51, 65, 85, 0.5);
            border-radius: 0.25rem;
            position: relative;
            overflow: hidden;
        }

        .time-text {
            width: 6rem;
            font-family: monospace;
            font-size: 9px;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Search Results */
        #search-results {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--slate-800);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            max-height: 300px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            width: 240px;
        }

        .search-item {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--slate-700);
            transition: background 0.15s;
            color: var(--slate-300);
            font-size: 0.75rem;
        }

        .search-item:hover {
            background: var(--slate-700);
        }
    </style>
</head>

<body class="pano-body">

    <div id="editor-panel" class="panel-right">
        <div class="panel-header">
            <h2 class="panel-title">ğŸ“œ æ”¿æƒè¯¦æƒ…</h2>

            <div style="display:flex; gap:0.5rem; align-items:center;">
                <button id="btn-jump-map-header" class="jump-btn">
                    <span>ğŸ—ºï¸</span> æŸ¥çœ‹å†å²åœ°å›¾
                </button>
                <button id="btn-close-panel" class="panel-close-btn">âœ•</button>
            </div>
        </div>
        <div class="custom-scrollbar" id="editor-content" style="padding:1.25rem; overflow-y:auto; flex:1;"></div>
    </div>

    <div id="selection-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">è¯·é€‰æ‹©æ”¿æƒ</span>
                <button id="btn-close-modal" class="modal-close">âœ•</button>
            </div>
            <div id="selection-list" class="custom-scrollbar"
                style="padding:0.5rem; max-height:60vh; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="chart-container">
            <div id="sticky-header-row">
                <div id="header-corner">
                    <button id="btn-flip-cols" title="ç¿»è½¬åœ°åŒºåˆ—"
                        style="width:100%; height:100%; border:none; background:transparent; color:var(--slate-500); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; transition:color 0.2s;">
                        â‡„
                    </button>
                </div>
                <div id="header-body"></div>
            </div>
            <div id="chart-body-row">
                <div id="ticks-layer" class="sticky-ticks">
                    <div id="crosshair-label"></div>
                </div>
                <div id="render-area">
                    <div id="crosshair-line"></div>
                    <svg id="connections-layer" width="100%" height="100%"></svg>
                    <div id="blocks-layer" style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:10;">
                    </div>
                    <div id="labels-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:2000; pointer-events:none;">
                    </div>
                    <div id="grid-layer"
                        style="position:absolute; top:0; left:0; right:0; bottom:0; z-index:0; pointer-events:none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ä»çˆ¶çº§è·å–å¹´ä»½é…ç½®ï¼Œå¦‚æœçˆ¶çº§ä¸å¯ç”¨åˆ™ä½¿ç”¨æœ¬åœ°é»˜è®¤å€¼
        const TIME_CONFIG = window.parent?.GLOBAL_CONFIG?.TIME || {
            minYear: -2100, // æ³¨æ„: GLOBAL_CONFIG ç”¨å¤§å†™ key, è¿™é‡Œ fallback ç”¨å¤§å†™
            maxYear: 2025
        };

        // [New] Logger Bridge: Forward logs to parent console
        if (window.parent && window.parent.console) {
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            console.log = function (...args) {
                originalLog.apply(console, args);
                try { window.parent.console.log("[Pano]", ...args); } catch (e) { }
            };
            console.warn = function (...args) {
                originalWarn.apply(console, args);
                try { window.parent.console.warn("[Pano]", ...args); } catch (e) { }
            };
            console.error = function (...args) {
                originalError.apply(console, args);
                try { window.parent.console.error("[Pano]", ...args); } catch (e) { }
            };
            window.onerror = function (msg, source, line, col, error) {
                try { window.parent.console.error(`[Pano] Uncaught: ${msg} @ ${line}`); } catch (e) { }
            };
        }

        const APP_CONFIG = {
            minYear: TIME_CONFIG.MIN_YEAR || -2100,
            maxYear: TIME_CONFIG.MAX_YEAR || 2025
        };

        // Historical Perspectives Configuration
        const PERSPECTIVES = {
            default: {
                name: "é»˜è®¤å¸ƒå±€",
                isDefault: true
            },

            songLiaoJin: {
                name: "å®‹è¾½é‡‘æ—¶æœŸ",
                coreRegimes: [
                    "åŒ—å®‹|C5100",
                    "å—å®‹|R5110",
                    "è¾½|Q5700",
                    "é‡‘|Q5710"
                ],
                weights: {
                    intraRegime: 100,    // Same regime regions
                    interRegime: 30,     // Different core regime regions
                    background: 0.1      // Background regions
                }
            }
        };

        // --- New Label System Modules (v2.0 Refactor) ---

        /**
         * ç©ºé—´ç´¢å¼•ç±» - ä½¿ç”¨ Dynamic Grid (Spatial Hash) ä¼˜åŒ–ç¢°æ’æ£€æµ‹
         * ç›¸æ¯” QuadTreeï¼ŒGrid æ›´ç®€å•ä¸”åœ¨ç‰©ä½“åˆ†å¸ƒå‡åŒ€æ—¶æ€§èƒ½æä½³
         */
        class SpatialIndex {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map(); // key: "x_y", value: [items]
                this.items = []; // keep track of all items
            }

            _getKey(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx}_${gy}`;
            }

            _getKeysForRect(rect) {
                const keys = [];
                const startX = Math.floor(rect.x / this.cellSize);
                const endX = Math.floor((rect.x + rect.w) / this.cellSize);
                const startY = Math.floor(rect.y / this.cellSize);
                const endY = Math.floor((rect.y + rect.h) / this.cellSize);

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        keys.push(`${x}_${y}`);
                    }
                }
                return keys;
            }

            insert(item) {
                // item must have {x, y, w, h}
                if (!item._sid) item._sid = Math.random().toString(36).substr(2, 9);

                this.items.push(item);
                const keys = this._getKeysForRect(item);
                keys.forEach(k => {
                    if (!this.grid.has(k)) this.grid.set(k, []);
                    this.grid.get(k).push(item);
                });
            }

            // è¿”å›æ‰€æœ‰ä¸ rect é‡å çš„ items
            query(rect) {
                const keys = this._getKeysForRect(rect);
                const candidates = new Set();

                // 1. Gather candidates
                keys.forEach(k => {
                    const cellItems = this.grid.get(k);
                    if (cellItems) {
                        for (let i = 0; i < cellItems.length; i++) {
                            candidates.add(cellItems[i]);
                        }
                    }
                });

                // 2. Precise check
                const result = [];
                candidates.forEach(item => {
                    if (this._intersects(rect, item)) {
                        result.push(item);
                    }
                });
                return result;
            }

            _intersects(a, b) {
                return a.x < b.x + b.w &&
                    a.x + a.w > b.x &&
                    a.y < b.y + b.h &&
                    a.y + a.h > b.y;
            }

            clear() {
                this.grid.clear();
                this.items = [];
            }
        }

        /**
         * LabelSystem - è´Ÿè´£æ–°çš„æ ‡ç­¾å¸ƒå±€è®¡ç®—é€»è¾‘
         * [v2.0] å¢å¼ºç‰ˆï¼šè¾¹ç•Œçº¦æŸ + æ™ºèƒ½æ–¹å‘é€‰æ‹© + H2ä¸¤è¡Œå¸ƒå±€
         */
        const LabelSystem = {
            index: null, // SpatialIndex instance

            init() {
                // å•å…ƒæ ¼å¤§å°è®¾ä¸º 128pxï¼Œé€‚åˆå¸¸è§„æ ‡ç­¾å°ºå¯¸
                this.index = new SpatialIndex(128);
            },

            /**
             * [New] Step 1: è®¡ç®—æ”¿æƒæ‰€æœ‰ç‰‡æ®µçš„å®Œæ•´è¾¹ç•Œæ¡† (BoundingBox)
             * ç”¨äºï¼šè¾¹ç•Œçº¦æŸæ£€æŸ¥ã€æ–¹å‘åå¥½åˆ¤æ–­
             * @param {Object} group æ”¿æƒç»„
             * @param {Number} colWidth åˆ—å®½(åƒç´ )
             * @param {Number} zoom ç¼©æ”¾å€ç‡
             * @returns {Object} { x, y, w, h } è¾¹ç•Œæ¡†ï¼ˆåƒç´ åæ ‡ï¼‰
             */
            calculateBoundingBox(group, colWidth, zoom) {
                const slices = group.visualSlices || [];
                if (slices.length === 0) {
                    return { x: 0, y: 0, w: 0, h: 0 };
                }

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                slices.forEach(slice => {
                    // è®¡ç®—ç‰‡æ®µçš„å·¦è¾¹ç•Œï¼ˆåƒç´ ï¼‰
                    const left = (slice.cIdx + slice.left) * colWidth;
                    // è®¡ç®—ç‰‡æ®µçš„å³è¾¹ç•Œï¼ˆåƒç´ ï¼‰
                    const right = left + slice.w * colWidth;
                    // è®¡ç®—ç‰‡æ®µçš„ä¸Šè¾¹ç•Œï¼ˆåƒç´ ï¼Œå¹´ä»½è½¬æ¢ï¼‰
                    const top = (slice.start - APP_CONFIG.minYear) * zoom;
                    // è®¡ç®—ç‰‡æ®µçš„ä¸‹è¾¹ç•Œï¼ˆåƒç´ ï¼‰
                    const bottom = (slice.end - APP_CONFIG.minYear) * zoom;

                    minX = Math.min(minX, left);
                    maxX = Math.max(maxX, right);
                    minY = Math.min(minY, top);
                    maxY = Math.max(maxY, bottom);
                });

                return {
                    x: minX,
                    y: minY,
                    w: maxX - minX,
                    h: maxY - minY
                };
            },

            /**
             * [v2.0] Step 2 & 3: ç”Ÿæˆæ ‡ç­¾å€™é€‰æ–¹æ¡ˆ
             * æ”¹è¿›ç‚¹ï¼š
             * - ä½¿ç”¨ bboxï¼ˆè€Œé posï¼‰åˆ¤æ–­æ–¹å‘åå¥½
             * - ä½¿ç”¨ bestSlice çš„å°ºå¯¸è®¡ç®—å­—å·ï¼ˆæ›´ç²¾ç¡®ï¼‰
             * - ç®€åŒ–ä¸ºä¸‰ç§å¸ƒå±€ç±»å‹ï¼šH(æ¨ªæ’)ã€V(ç«–æ’)ã€H2(æ¨ªæ’ä¸¤è¡Œ)
             * 
             * @param {Object} group æ”¿æƒç»„
             * @param {Object} bbox è¾¹ç•Œæ¡† {x, y, w, h}ï¼ˆç”¨äºæ–¹å‘åå¥½ï¼‰
             * @param {Object} pos ä½ç½®ä¿¡æ¯
             * @param {Object} bestSlice æœ€å¤§ç‰‡æ®µï¼ˆç”¨äºç²¾ç¡®å­—å·è®¡ç®—ï¼‰
             * @param {Number} zoom ç¼©æ”¾å€ç‡
             */
            generateCandidates(group, bbox, pos, bestSlice, zoom) {
                const tier = parseInt(group.explicitTier) || 3;
                const txt = group.name;
                const len = txt.length;

                // åŸºç¡€å°ºå¯¸é™åˆ¶ï¼ˆæ ¹æ® Tierï¼‰
                let minFS = 10, maxFS = 16;
                if (tier === 1) { minFS = 20; maxFS = 60; }
                else if (tier === 2) { minFS = 12; maxFS = 28; }

                const candidates = [];

                // [Fix] æ–¹æ¡ˆ Aï¼šä¸¥æ ¼é™åˆ¶è·¨åˆ—æ ‡ç­¾çš„é«˜åº¦
                // 0. æ„å»ºåˆ—é«˜åº¦æŸ¥æ‰¾è¡¨ (ç”¨äºåç»­è®¡ç®—å…¬å…±é«˜åº¦)
                const colYMap = new Map();
                if (group.visualSlices) {
                    group.visualSlices.forEach(s => {
                        const top = (s.start - APP_CONFIG.minYear) * zoom;
                        const bottom = (s.end - APP_CONFIG.minYear) * zoom;
                        if (!colYMap.has(s.colIdx) || (bottom - top) > (colYMap.get(s.colIdx).bottom - colYMap.get(s.colIdx).top)) {
                            colYMap.set(s.colIdx, { top, bottom });
                        }
                    });
                }

                // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŒ‡å®šè·¨åº¦ä¸‹çš„æœ€å¤§å®‰å…¨é«˜åº¦
                const getSafeHeightForWidth = (targetW, centerCol) => {
                    const halfCols = (targetW / 2) / colWidth;
                    const startCol = Math.floor(centerCol - halfCols);
                    const endCol = Math.ceil(centerCol + halfCols);
                    let commonTop = -Infinity, commonBottom = Infinity, coveredCols = 0;

                    for (let c = startCol; c <= endCol; c++) {
                        if (colYMap.has(c)) {
                            const range = colYMap.get(c);
                            commonTop = Math.max(commonTop, range.top);
                            commonBottom = Math.min(commonBottom, range.bottom);
                            coveredCols++;
                        } else { return 0; } // æ–­å¼€
                    }
                    if (coveredCols === 0 || commonTop >= commonBottom) return 0;
                    return commonBottom - commonTop;
                };

                const bsW = bestSlice ? bestSlice.w : bbox.w;
                const bsH = bestSlice ? (bestSlice.h * zoom) : bbox.h;
                const colWidth = pos.colWidth || 24;

                let baseW = bsW;
                let baseH = bsH;

                // å…è®¸å°è¯•è®¡ç®—ç”± bbox å¸¦æ¥çš„ç†è®ºæœ€å¤§å®½åº¦ï¼ˆTier 1/2ï¼‰
                // ä½†æœ€ç»ˆä¼šè¢« safeHeight å¦å†³
                if (tier === 1) {
                    baseW = Math.min(bbox.w, Math.max(bsW, bbox.w * 0.6));
                } else if (tier === 2) {
                    baseW = Math.min(bbox.w, Math.max(bsW, bbox.w * 0.4));
                }

                // å…¼å®¹æ—§å˜é‡åï¼Œä¾›åç»­é€»è¾‘ä½¿ç”¨
                let sliceW = baseW;
                let sliceH = baseH;

                // [Fix] æ ¸å¿ƒä¿®æ­£ï¼šå¯¹äº Tier 1/2ï¼Œå¿…é¡»å¼ºè¡Œæå‡ sliceH çš„åŸºç¡€å€¼
                // å¢åŠ å®½åº¦æ ¡éªŒï¼šåªæœ‰ > 3 åˆ—å®½çš„ä¸»ä½“æ‰äº«å—æ­¤å¾…é‡ï¼Œé˜²æ­¢å°ç¢ç‰‡ï¼ˆå¦‚ç§¦é£åœ°ï¼‰è¢«æ”¾å¤§
                if (bbox.w > colWidth * 3) {
                    if (tier === 1) sliceH = Math.max(sliceH, 40);
                    else if (tier === 2) sliceH = Math.max(sliceH, 30);
                }

                // [Fix v7] ä½¿ç”¨ sliceW/sliceH æ¥åˆ¤æ–­æ–¹å‘åå¥½
                // å› ä¸º bbox å¯èƒ½åŒ…å«ç©ºç™½åŒºåŸŸï¼Œå¯¼è‡´æ¯”ä¾‹å¤±çœŸ
                const boxW = sliceW;  // ä½¿ç”¨å®é™…å¯æ”¾ç½®åŒºåŸŸçš„å®½åº¦
                const boxH = sliceH;  // ä½¿ç”¨å®é™…å¯æ”¾ç½®åŒºåŸŸçš„é«˜åº¦

                // ========== æ–¹å‘åå¥½åˆ¤æ–­ ==========
                const ratio = boxH / boxW;

                // [Fix] é™ä½ç«–æ’é˜ˆå€¼ï¼šratio > 1.5 æ‰åå¥½ç«–æ’ï¼ˆåŒºåŸŸæ˜æ˜¾é«˜äºå®½ï¼‰
                const isNarrowTall = ratio > 1.5;

                // å¼ºåˆ¶ç«–æ’æ¡ä»¶ï¼šéå¸¸çª„é«˜ (ratio > 2.5)
                const mustBeVertical = ratio > 2.5;

                // æ¡ä»¶2: è‰²å—å®½åº¦å¤ªçª„ï¼Œæ¨ªæ’æ”¾ä¸ä¸‹
                const minHorizontalWidth = len * minFS * 0.9;
                const horizontalWontFit = boxW < minHorizontalWidth;

                // æ¡ä»¶3: è‰²å—å®½åº¦å¾ˆå®½ï¼Œé€‚åˆæ¨ªæ’ï¼ˆratio < 0.8 è¡¨ç¤ºå®½æ‰åŒºåŸŸï¼‰
                const isWideShort = ratio < 0.8;

                // ç»¼åˆåˆ¤æ–­åå¥½æ–¹å‘
                const preferVertical = isNarrowTall || horizontalWontFit || mustBeVertical;
                const preferHorizontal = isWideShort && !horizontalWontFit && !mustBeVertical;

                // ========== è¾…åŠ©å‡½æ•° ==========
                const addLayout = (type, fs, scoreMult = 1.0) => {
                    // [Fix v2] Tier 3 é™ä½æœ€å°å­—å·ï¼Œè®©æ›´å¤šå°æ”¿æƒèƒ½æ˜¾ç¤ºæ ‡ç­¾
                    let effectiveMinFS = minFS;
                    if (tier === 3) {
                        if (type === 'H') {
                            effectiveMinFS = 8;   // æ¨ªæ’æœ€å° 8px
                        } else {
                            effectiveMinFS = 7;   // V å’Œ H2 æœ€å° 7px
                        }
                    }

                    fs = Math.min(Math.max(fs, effectiveMinFS), maxFS);
                    let w = 0, h = 0;

                    if (type === 'H') {
                        // æ¨ªæ’å•è¡Œ
                        w = fs * len * 0.95;  // å­—ç¬¦é—´è·ç³»æ•°
                        h = fs * 1.2;
                    } else if (type === 'V') {
                        // ç«–æ’
                        w = fs * 1.2;
                        h = fs * len * 1.1;  // è¡Œé«˜ç³»æ•°
                    } else if (type === 'H2') {
                        // æ¨ªæ’ä¸¤è¡Œ
                        const row1Len = Math.ceil(len / 2);
                        w = fs * row1Len * 0.95;
                        h = fs * 2.0;  // [Fix] å‡å°‘è¡Œé«˜ï¼Œæ›´ç´§å‡‘
                    }

                    // [Fix v2] æ”¾å®½æº¢å‡ºæƒ©ç½šï¼šå…è®¸è½»å¾®æº¢å‡º
                    let overflowPenalty = 1.0;
                    const overflowX = w / sliceW;
                    const overflowY = h / sliceH;
                    // æº¢å‡º 20% ä»¥å†…åªè½»å¾®æƒ©ç½šï¼Œè¶…è¿‡ 20% æ‰å¤§å¹…æƒ©ç½š
                    if (overflowX > 1.2) overflowPenalty *= 0.3;
                    else if (overflowX > 1.0) overflowPenalty *= 0.8;
                    if (overflowY > 1.2) overflowPenalty *= 0.3;
                    else if (overflowY > 1.0) overflowPenalty *= 0.8;

                    candidates.push({
                        type, fs, w, h,
                        scoreMult: scoreMult * overflowPenalty
                    });
                };

                // ========== ç”Ÿæˆå€™é€‰å¸ƒå±€ ==========
                // [Fix] ä½¿ç”¨ sliceW/sliceH è®¡ç®—å­—å·ï¼ˆå®é™…å¯æ”¾ç½®åŒºåŸŸï¼‰

                // 1. æ¨ªæ’ (H) - é»˜è®¤é¦–é€‰
                // å…ˆåŸºäºç†è®ºå®½åº¦ç®—ä¸€ä¸ªå­—å·
                let hFS = Math.min(sliceW * 0.9 / len, sliceH * 0.8);

                // [CRITICAL FIX] æ ¡éªŒè¯¥å­—å·å¯¹åº”çš„å®½åº¦ï¼Œåœ¨é«˜åº¦ä¸Šæ˜¯å¦å®‰å…¨
                if (hFS >= minFS) {
                    const estW = hFS * len;
                    const centerCol = bestSlice ? (bestSlice.colIdx + bestSlice.colspan / 2) : (pos.col || 0);

                    // è®¡ç®—åœ¨æ­¤å®½åº¦ä¸‹çš„å…¬å…±å®‰å…¨é«˜åº¦
                    let safeH = getSafeHeightForWidth(estW, centerCol);
                    // [Fix] ä»…å¯¹ä¸»ä½“éƒ¨åˆ†ç»™äºˆæœ€å°é«˜åº¦ä¿éšœ
                    if (bbox.w > colWidth * 3) {
                        if (tier === 1) safeH = Math.max(safeH, 30);
                        else if (tier === 2) safeH = Math.max(safeH, 20);
                    }

                    // [Fix] ç³»æ•°è°ƒæ•´ï¼šTier 1 ç»™äºˆæå¤§è±å… (3.0)ï¼Œé˜²æ­¢å› å±€éƒ¨ç‹­çª„è€Œæƒ©ç½šæ•´ä½“
                    const safeLimitMult = (tier === 1) ? 3.0 : 1.5;
                    const constrainedFS = Math.min(hFS, safeH * safeLimitMult);

                    if (constrainedFS >= minFS) {
                        // ä½¿ç”¨ä¿®æ­£åçš„å®‰å…¨å­—å·
                        let hScore = preferHorizontal ? 1.4 : (horizontalWontFit ? 0.6 : 1.2);
                        addLayout('H', constrainedFS, hScore);
                        if (constrainedFS * 0.85 >= minFS) {
                            addLayout('H', constrainedFS * 0.85, hScore * 0.9);
                        }
                    } else {
                        // è·¨åˆ—å¤±è´¥ï¼Œé€€å›åˆ°ä»…åŸºäº bestSlice (å•åˆ—) å°è¯•
                        const singleColFS = Math.min(bsW * 0.9 / len, bsH * 0.8);
                        if (singleColFS >= minFS) {
                            addLayout('H', singleColFS, 1.0);
                        }
                    }
                }

                // 2. ç«–æ’ (V) - çª„é«˜å‹åŒºåŸŸé¦–é€‰
                const vFS = Math.min(sliceW * 0.8, sliceH * 0.9 / len);
                if (vFS >= minFS) {
                    let vScore = preferVertical ? 1.6 : 0.8;

                    // å¼ºåˆ¶ç«–æ’çš„æƒ…å†µç»™æœ€é«˜åˆ†
                    if (mustBeVertical) {
                        vScore = 2.0;
                    }
                    // çŸ­åç§° + åå¥½ç«–æ’
                    else if (len >= 2 && len <= 5 && preferVertical) {
                        vScore = 1.9;
                    }
                    addLayout('V', vFS, vScore);
                    if (vFS * 0.85 >= minFS) {
                        addLayout('V', vFS * 0.85, vScore * 0.9);
                    }
                }

                // 3. æ¨ªæ’ä¸¤è¡Œ (H2) - ä»…å¯¹4å­—åŠä»¥ä¸Šåç§°
                if (len >= 4) {
                    const row1Len = Math.ceil(len / 2);
                    let h2FS = Math.min(sliceW * 0.9 / row1Len, sliceH * 0.4);

                    if (h2FS >= minFS) {
                        const estW = h2FS * row1Len;
                        const centerCol = bestSlice ? (bestSlice.colIdx + bestSlice.colspan / 2) : 0;
                        let safeH = getSafeHeightForWidth(estW, centerCol);
                        // [Fix] ä»…å¯¹ä¸»ä½“éƒ¨åˆ†ç»™äºˆæœ€å°é«˜åº¦ä¿éšœ
                        if (bbox.w > colWidth * 3) {
                            if (tier === 1) safeH = Math.max(safeH, 30);
                            else if (tier === 2) safeH = Math.max(safeH, 20);
                        }

                        // å¯¹åŒè¡Œå¸ƒå±€ï¼ŒsafeH çº¦æŸæ›´ä¸¥ï¼ˆå› ä¸ºæœ‰ä¸¤è¡Œï¼‰
                        const constrainedH2FS = Math.min(h2FS, safeH * 1.3 * 0.45); // æ”¾å®½è‡³ 1.3 å€

                        let h2Score = 0.85;
                        if (horizontalWontFit) h2Score = 1.6;
                        else if (isWideShort) h2Score = 1.3;

                        if (constrainedH2FS >= minFS) {
                            addLayout('H2', constrainedH2FS, h2Score);
                            if (constrainedH2FS * 0.85 >= minFS) {
                                addLayout('H2', constrainedH2FS * 0.85, h2Score * 0.9);
                            }
                        } else {
                            // Fallback to single col H2
                            const singleColH2FS = Math.min(bsW * 0.9 / row1Len, bsH * 0.45);
                            if (singleColH2FS >= minFS) {
                                addLayout('H2', singleColH2FS, 0.9);
                            }
                        }
                    }
                }

                // [Fix] ä¸ºæ‰€æœ‰ç±»å‹å¢åŠ æ›´å°å­—å·é€‰é¡¹ (0.7x)ï¼Œåœ¨ç¢°æ’æ¿€çƒˆæ—¶ä½¿ç”¨
                // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦åŸºäº constrained çš„ç»“æœï¼Œä½†ç”±äºä¸Šæ–‡å˜é‡ä½œç”¨åŸŸé™åˆ¶ï¼Œæˆ‘ä»¬ç®€å•åŸºäº minFS å†æ¬¡å°è¯•
                // ä¸ºäº†ç®€å•æœ‰æ•ˆï¼Œæˆ‘ä»¬åªå¯¹å·²ç»ç”Ÿæˆçš„ candidates è¿›è¡Œç¼©å°è¡ç”Ÿ
                const currentCount = candidates.length;
                for (let i = 0; i < currentCount; i++) {
                    const c = candidates[i];
                    if (c.fs * 0.7 >= minFS) {
                        // é™ä½åˆ†æ•°ï¼Œä½œä¸ºå¤‡é€‰
                        addLayout(c.type, c.fs * 0.7, c.scoreMult * 0.6);
                    }
                }

                // ========== Fallback ==========
                if (candidates.length === 0) {
                    // å¦‚æœæ²¡æœ‰åˆæ³•å€™é€‰ï¼Œå¼ºåˆ¶æ·»åŠ ä¸€ä¸ªæœ€å°çš„
                    candidates.push({
                        type: preferVertical ? 'V' : 'H',
                        fs: minFS,
                        w: preferVertical ? minFS : minFS * len,
                        h: preferVertical ? minFS * len : minFS,
                        scoreMult: 0.1
                    });
                }

                // æŒ‰è¯„åˆ†æ’åºï¼ˆå­—å· Ã— è¯„åˆ†ç³»æ•°ï¼‰
                candidates.sort((a, b) => (b.fs * b.scoreMult) - (a.fs * a.scoreMult));
                return candidates;
            },

            /**
             * [v2.0] Step 4: è®¡ç®—æœ€ç»ˆå¸ƒå±€
             * æ”¹è¿›ç‚¹ï¼š
             * - ä¸ºæ¯ä¸ªæ”¿æƒè®¡ç®— BoundingBox
             * - å°† bbox ä¼ é€’ç»™ generateCandidates
             * - æ·»åŠ è¾¹ç•Œçº¦æŸæ£€æŸ¥ï¼šæ ‡ç­¾ä¸èƒ½è¶…å‡º bbox
             */
            computeAll(regimeGroups, regionIndexMap, colWidth, zoom) {
                if (!this.index) this.init();
                this.index.clear();

                const results = [];

                // 1. æ”¶é›†æ‰€æœ‰æ”¿æƒåŠå…¶ä½ç½®ä¿¡æ¯
                const allItems = [];

                regimeGroups.forEach(g => {
                    const positions = Core.logic.calculateLabelPositions(g, regionIndexMap, colWidth);

                    positions.forEach(p => {
                        // ä½¿ç”¨ cluster çš„è”åˆè¾¹ç•Œæ¡†ï¼ˆç”¨äºæ–¹å‘åå¥½å’Œå­—å·åˆ¤æ–­ï¼‰
                        const cb = p.clusterBounds;
                        const clusterBbox = {
                            x: cb.minX,
                            y: (cb.minY - APP_CONFIG.minYear) * zoom,
                            w: cb.maxX - cb.minX,
                            h: (cb.maxY - cb.minY) * zoom
                        };

                        allItems.push({
                            group: g,
                            pos: p,
                            bbox: clusterBbox,
                            bestSlice: p.bestSlice  // ä¿ç•™ bestSlice ä¾›åç»­éªŒè¯
                        });
                    });
                });

                // 2. æŒ‰ Tier ä¼˜å…ˆçº§ + é¢ç§¯æ’åºï¼ˆTier 1 å…ˆå å‘ï¼‰
                allItems.sort((a, b) => {
                    const tA = parseInt(a.group.explicitTier) || 3;
                    const tB = parseInt(b.group.explicitTier) || 3;
                    if (tA !== tB) return tA - tB;
                    return b.pos.area - a.pos.area;
                });

                // 3. æ”¾ç½®å¾ªç¯
                allItems.forEach(item => {
                    const { group, pos, bbox, bestSlice } = item;
                    const tier = parseInt(group.explicitTier) || 3;

                    // è·å–å€™é€‰å¸ƒå±€
                    // [Fix] ä¼ å…¥ bestSliceï¼Œç”¨äºæ›´ç²¾ç¡®çš„å­—å·è®¡ç®—
                    const layouts = this.generateCandidates(group, bbox, pos, bestSlice, zoom);

                    let bestPlacement = null;
                    let bestScore = -Infinity;

                    // å®šä¹‰å°è¯•çš„ä½ç½®åç§»é‡
                    let offsets = [{ x: 0, y: 0 }];

                    // æ ¹æ®è¾¹ç•Œæ¡†é«˜åº¦å†³å®šåç§»èŒƒå›´
                    if (bbox.h > 40 || tier <= 2) {
                        offsets.push({ x: 0, y: -bbox.h * 0.2 });
                        offsets.push({ x: 0, y: bbox.h * 0.2 });
                    }
                    if (tier >= 3 && bbox.h > 60) {
                        offsets.push({ x: 0, y: -bbox.h * 0.35 });
                        offsets.push({ x: 0, y: bbox.h * 0.35 });
                    }

                    // éå†æ‰€æœ‰ å¸ƒå±€ Ã— ä½ç½® ç»„åˆ
                    for (let layout of layouts) {
                        for (let off of offsets) {
                            // [Fix v6] ä¼˜å…ˆä½¿ç”¨ bestSlice ä¸­å¿ƒè€Œä¸æ˜¯ cluster åŠ æƒä¸­å¿ƒ
                            // è¿™ç¡®ä¿æ ‡ç­¾æ”¾åœ¨æœ€å¤§çš„è¿ç»­è‰²å—ä¸Šï¼Œè€Œä¸æ˜¯æ•´ä¸ªæ”¿æƒçš„å‡ ä½•ä¸­å¿ƒ
                            let centerX, centerY;

                            if (bestSlice) {
                                // ä½¿ç”¨ bestSlice çš„ä¸­å¿ƒï¼ˆå·²ç»æ˜¯åƒç´ åæ ‡ï¼‰
                                centerX = bestSlice.x + off.x;
                                centerY = ((bestSlice.y - APP_CONFIG.minYear) * zoom) + off.y;
                            } else {
                                // Fallback: ä½¿ç”¨ cluster çš„åŠ æƒä¸­å¿ƒ
                                const boxY = (pos.y - APP_CONFIG.minYear) * zoom;
                                centerX = pos.x + off.x;
                                centerY = boxY + off.y;
                            }

                            // [Fix] å¦‚æœä¸­å¿ƒç‚¹è·‘åˆ° bbox å¤–é¢ï¼Œä½¿ç”¨ bestSlice ä¸­å¿ƒæˆ– bbox ä¸­å¿ƒ
                            const bboxCenterX = bbox.x + bbox.w / 2;
                            const bboxCenterY = bbox.y + bbox.h / 2;

                            if (centerX < bbox.x || centerX > bbox.x + bbox.w) {
                                centerX = bestSlice ? bestSlice.x : bboxCenterX;
                            }
                            if (centerY < bbox.y || centerY > bbox.y + bbox.h) {
                                centerY = bestSlice ? ((bestSlice.y - APP_CONFIG.minYear) * zoom) : bboxCenterY;
                            }

                            const w = layout.w;
                            const h = layout.h;

                            // ========== [Fix] ä¸¥æ ¼åŒ–è¾¹ç•Œçº¦æŸæ£€æŸ¥ ==========
                            // æ ‡ç­¾çš„è¾¹ç•Œ
                            const labelLeft = centerX - w / 2;
                            const labelRight = centerX + w / 2;
                            const labelTop = centerY - h / 2;
                            const labelBottom = centerY + h / 2;

                            // [Fix] æ£€æŸ¥æ˜¯å¦è¶…å‡ºæ”¿æƒè¾¹ç•Œæ¡†ï¼ˆå®¹å·®æ”¹ä¸º0ï¼‰
                            const exceedsLeft = labelLeft < bbox.x;
                            const exceedsRight = labelRight > bbox.x + bbox.w;
                            const exceedsTop = labelTop < bbox.y;
                            const exceedsBottom = labelBottom > bbox.y + bbox.h;

                            // [Fix] ä»»ä½•æ–¹å‘è¶…å‡ºéƒ½è¦æƒ©ç½šï¼Œ1ä¸ªæ–¹å‘ä¸¥é‡è¶…å‡ºå°±è·³è¿‡
                            const exceedsCount = [exceedsLeft, exceedsRight, exceedsTop, exceedsBottom].filter(Boolean).length;

                            // è®¡ç®—è¶…å‡ºé‡
                            const overflowLeft = exceedsLeft ? (bbox.x - labelLeft) : 0;
                            const overflowRight = exceedsRight ? (labelRight - bbox.x - bbox.w) : 0;
                            const overflowTop = exceedsTop ? (bbox.y - labelTop) : 0;
                            const overflowBottom = exceedsBottom ? (labelBottom - bbox.y - bbox.h) : 0;
                            const maxOverflow = Math.max(overflowLeft, overflowRight, overflowTop, overflowBottom);

                            // [Fix v2] æ”¾å®½è¾¹ç•Œæ£€æŸ¥ï¼šå…è®¸æ›´å¤šæº¢å‡º
                            // å¦‚æœè¶…å‡ºé‡å¤§äºæ ‡ç­¾å°ºå¯¸çš„ 50%ï¼Œè·³è¿‡
                            if (maxOverflow > Math.min(w, h) * 0.5) {
                                continue;
                            }
                            // å¦‚æœä¸‰ä¸ªåŠä»¥ä¸Šæ–¹å‘è¶…å‡ºï¼Œè·³è¿‡
                            if (exceedsCount >= 3) {
                                continue;
                            }

                            // [Fix] ç¢°æ’ç®±åªæ”¶ç¼© 5%ï¼Œé¿å…è§†è§‰é‡å 
                            const hitW = w * 0.95;
                            const hitH = h * 0.95;
                            const rect = {
                                x: centerX - hitW / 2,
                                y: centerY - hitH / 2,
                                w: hitW,
                                h: hitH
                            };

                            // ç¢°æ’æ£€æµ‹
                            const conflicts = this.index.query(rect);
                            if (conflicts.length > 0) {
                                continue;  // æœ‰ç¢°æ’ï¼Œè·³è¿‡
                            }

                            // è®¡ç®—è¯„åˆ†
                            let score = layout.fs * layout.scoreMult;

                            // åç§»æƒ©ç½š
                            if (off.y !== 0) score *= 0.9;

                            // [Fix] è¾¹ç•Œè¶…å‡ºæƒ©ç½šï¼ˆæ ¹æ®æº¢å‡ºé‡åŠ¨æ€é™åˆ†ï¼‰
                            if (exceedsCount >= 1) {
                                // æº¢å‡ºé‡è¶Šå¤§ï¼Œæƒ©ç½šè¶Šé‡
                                const overflowRatio = maxOverflow / Math.min(w, h);
                                score *= Math.max(0.3, 1 - overflowRatio * 2);
                            }

                            if (score > bestScore) {
                                bestScore = score;
                                bestPlacement = {
                                    layout,
                                    x: centerX,
                                    y: centerY,
                                    rect,
                                    bbox  // ä¿å­˜ bbox ä¾›è°ƒè¯•
                                };
                            }
                        }
                        // æ‰¾åˆ°è¶³å¤Ÿå¥½çš„ä½ç½®å°±åœæ­¢
                        if (bestPlacement && bestScore > 10) break;
                    }

                    if (bestPlacement) {
                        // [Fix] å¼ºåˆ¶æ ‡ç­¾ä½ç½®åœ¨ bbox å†…
                        let finalX = bestPlacement.x;
                        let finalY = bestPlacement.y;
                        const lw = bestPlacement.layout.w;
                        const lh = bestPlacement.layout.h;

                        // Clamp æ ‡ç­¾ä¸­å¿ƒï¼Œç¡®ä¿æ ‡ç­¾ä¸è¶…å‡º bbox
                        const minX = bbox.x + lw / 2;
                        const maxX = bbox.x + bbox.w - lw / 2;
                        const minY = bbox.y + lh / 2;
                        const maxY = bbox.y + bbox.h - lh / 2;

                        if (maxX > minX) {
                            finalX = Math.max(minX, Math.min(maxX, finalX));
                        } else {
                            // [Fix v6] æ ‡ç­¾å¤ªå¤§æ”¾ä¸ä¸‹ï¼Œä¼˜å…ˆä½¿ç”¨ bestSlice ä¸­å¿ƒ
                            finalX = bestSlice ? bestSlice.x : (bbox.x + bbox.w / 2);
                        }
                        if (maxY > minY) {
                            finalY = Math.max(minY, Math.min(maxY, finalY));
                        } else {
                            // [Fix v6] æ ‡ç­¾å¤ªé«˜æ”¾ä¸ä¸‹ï¼Œä¼˜å…ˆä½¿ç”¨ bestSlice ä¸­å¿ƒ
                            finalY = bestSlice ? ((bestSlice.y - APP_CONFIG.minYear) * zoom) : (bbox.y + bbox.h / 2);
                        }

                        // [Fix v8] éªŒè¯æ ‡ç­¾æ˜¯å¦å®Œå…¨åœ¨æ”¿æƒçš„æœ‰æ•ˆç‰‡æ®µå†…
                        // è€ƒè™‘æ ‡ç­¾çš„å®Œæ•´å°ºå¯¸ï¼Œä¸ä»…ä»…æ˜¯ä¸­å¿ƒç‚¹
                        const slices = group.visualSlices || [];
                        const labelHalfH_year = (lh / 2) / zoom;  // æ ‡ç­¾é«˜åº¦çš„ä¸€åŠï¼ˆå¹´ä»½å•ä½ï¼‰
                        const labelHalfW_col = (lw / 2) / colWidth;  // æ ‡ç­¾å®½åº¦çš„ä¸€åŠï¼ˆåˆ—å•ä½ï¼‰

                        const labelCenterY_year = (finalY / zoom) + APP_CONFIG.minYear;
                        const labelCenterX_col = finalX / colWidth;

                        // è®¡ç®—æ ‡ç­¾çš„å®Œæ•´è¾¹ç•Œï¼ˆå¹´ä»½/åˆ—åæ ‡ï¼‰
                        const labelTop_year = labelCenterY_year - labelHalfH_year;
                        const labelBottom_year = labelCenterY_year + labelHalfH_year;
                        const labelLeft_col = labelCenterX_col - labelHalfW_col;
                        const labelRight_col = labelCenterX_col + labelHalfW_col;

                        // æ£€æŸ¥æ˜¯å¦æœ‰ç‰‡æ®µèƒ½å®Œå…¨å®¹çº³æ ‡ç­¾
                        let isFullyContained = false;
                        let bestContainingSlice = null;
                        let maxContainment = 0;

                        for (const slice of slices) {
                            const sliceLeft = slice.cIdx + slice.left;
                            const sliceRight = sliceLeft + slice.w;
                            const sliceTop = slice.start;
                            const sliceBottom = slice.end;

                            // æ£€æŸ¥ X æ–¹å‘æ˜¯å¦åŒ…å«
                            const containsX = labelLeft_col >= sliceLeft && labelRight_col <= sliceRight;
                            // æ£€æŸ¥ Y æ–¹å‘æ˜¯å¦åŒ…å«
                            const containsY = labelTop_year >= sliceTop && labelBottom_year <= sliceBottom;

                            if (containsX && containsY) {
                                isFullyContained = true;
                                break;
                            }

                            // è®¡ç®—åŒ…å«ç¨‹åº¦ï¼ˆç”¨äºæ‰¾æœ€ä½³è°ƒæ•´ç›®æ ‡ï¼‰
                            if (containsX) {
                                // X æ–¹å‘ OKï¼Œè®¡ç®— Y æ–¹å‘çš„åŒ…å«ç¨‹åº¦
                                const sliceHeight = sliceBottom - sliceTop;
                                if (sliceHeight > maxContainment) {
                                    maxContainment = sliceHeight;
                                    bestContainingSlice = slice;
                                }
                            }
                        }

                        let isOnValidSlice = isFullyContained;

                        // [Fix v8] å¦‚æœæ ‡ç­¾æ²¡æœ‰å®Œå…¨åŒ…å«åœ¨ä»»ä½•ç‰‡æ®µå†…ï¼Œå°è¯•è°ƒæ•´ Y ä½ç½®
                        if (!isFullyContained && bestContainingSlice) {
                            const slice = bestContainingSlice;
                            const sliceTop = slice.start;
                            const sliceBottom = slice.end;

                            // è®¡ç®—èƒ½è®©æ ‡ç­¾å®Œå…¨åœ¨ç‰‡æ®µå†…çš„ Y èŒƒå›´
                            const validYMin_year = sliceTop + labelHalfH_year;
                            const validYMax_year = sliceBottom - labelHalfH_year;

                            if (validYMax_year >= validYMin_year) {
                                // æœ‰è¶³å¤Ÿç©ºé—´å®¹çº³æ ‡ç­¾ï¼Œè°ƒæ•´ Y åˆ°æœ‰æ•ˆèŒƒå›´å†…
                                let adjustedY_year = labelCenterY_year;
                                if (adjustedY_year < validYMin_year) {
                                    adjustedY_year = validYMin_year;  // ä¸‹ç§»
                                } else if (adjustedY_year > validYMax_year) {
                                    adjustedY_year = validYMax_year;  // ä¸Šç§»
                                }
                                finalY = (adjustedY_year - APP_CONFIG.minYear) * zoom;
                                isOnValidSlice = true;
                            }
                        }

                        // å¦‚æœä»ç„¶ä¸åœ¨æœ‰æ•ˆä½ç½®ï¼Œä½¿ç”¨ bestSlice ä¸­å¿ƒ
                        if (!isOnValidSlice && item.bestSlice) {
                            const bs = item.bestSlice;
                            finalX = bs.x;
                            // [Fix v8] ä¹Ÿè¦ç¡®ä¿ bestSlice ä¸­å¿ƒèƒ½å®¹çº³æ ‡ç­¾
                            const bsValidYMin = bs.top + labelHalfH_year;
                            const bsValidYMax = bs.bottom - labelHalfH_year;
                            if (bsValidYMax >= bsValidYMin) {
                                // è°ƒæ•´åˆ° bestSlice èƒ½å®¹çº³æ ‡ç­¾çš„ä½ç½®
                                let bsY = bs.y;
                                if (bsY < bsValidYMin) bsY = bsValidYMin;
                                else if (bsY > bsValidYMax) bsY = bsValidYMax;
                                finalY = (bsY - APP_CONFIG.minYear) * zoom;
                            } else {
                                finalY = (bs.y - APP_CONFIG.minYear) * zoom;
                            }
                        }

                        bestPlacement.x = finalX;
                        bestPlacement.y = finalY;

                        // æ³¨å†Œç¢°æ’ç®±
                        bestPlacement.rect.tier = tier;
                        this.index.insert(bestPlacement.rect);
                        results.push({
                            group,
                            ...bestPlacement
                        });
                    } else {
                        // æ”¾ç½®å¤±è´¥ â†’ é™çº§ä¸ºåœ†ç‚¹
                        results.push({
                            group,
                            failed: true,
                            x: pos.x,
                            y: (pos.y - APP_CONFIG.minYear) * zoom,
                            bbox  // ä¿å­˜ bbox ä¾›è°ƒè¯•
                        });
                    }
                });

                return results;
            }
        };


        const Core = {
            state: { regions: [], regionIndexMap: {}, regimeGroups: [], zoom: 1.5, rawData: [], features: { connections: true }, selectedRegimeId: null, lastClickedGeoCode: null, clickedYear: null, layoutCache: {}, intraColumnCache: {}, isFlipped: false },

            // [New] State sync: Report state changes (e.g. clicks) to parent
            updateParentState: function (updates) {
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'STATE_UPDATE_REQUEST',
                        payload: updates
                    }, window.location.origin);
                }
            },

            init: function () {
                // [Fix] ç¦ç”¨æµè§ˆå™¨æ»šåŠ¨æ¢å¤
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }

                // [Fix] è®°å½•åˆå§‹åŒ–æ—¶é—´ï¼Œç”¨äºæ‹¦æˆªåˆå§‹é˜¶æ®µçš„é”™è¯¯æ»šåŠ¨æŒ‡ä»¤
                this._initTime = Date.now();



                window.addEventListener('message', (e) => {
                    // ã€å…³é”®ä¿®å¤ã€‘å®‰å…¨é˜€
                    if (!e.data || typeof e.data !== 'object') return;

                    const { type, payload = {} } = e.data;

                    // Debug
                    if (type === 'CMD_RESET') console.log("ğŸ“œ å…¨æ™¯é¡µæ”¶åˆ°å¤ä½æŒ‡ä»¤!");

                    // 2. åˆå§‹åŒ–æ•°æ®ä¸æ ·å¼æ³¨å…¥
                    if (type === 'INIT_DATA') {
                        const { data, sharedCSS, sliceData, layout } = payload;

                        // [å…³é”®ä¿®å¤] æ³¨å…¥çˆ¶çº§å‘æ¥çš„ CSS (è§£å†³ texture-V/J è™šçº¿å’Œç½‘æ ¼ä¸æ˜¾ç¤ºçš„é—®é¢˜)
                        if (sharedCSS) {
                            const styleEl = document.getElementById('dynamic-styles');
                            if (styleEl) styleEl.innerHTML = sharedCSS;
                        }

                        // [New v10] ä¿å­˜é¢„è®¡ç®—æ•°æ®
                        if (layout) {
                            this.state.layoutData = layout; // åŒ…å« colOrder
                        }
                        if (sliceData) {
                            this.state.sliceData = sliceData;
                        }

                        // å¤„ç†æ ¸å¿ƒæ•°æ®
                        if (data) {
                            this.processData(data);
                        } else {
                            console.warn("Panorama: INIT_DATA received but data is empty");
                        }
                    }

                    // 3. ç¼©æ”¾æ§åˆ¶
                    if (type === 'CMD_ZOOM_IN') {
                        this.state.zoom = Math.min(this.state.zoom + 0.5, 10);
                        this.updateLayout(); // é‡æ–°è®¡ç®—å¸ƒå±€å¹¶æ¸²æŸ“
                    }
                    if (type === 'CMD_ZOOM_OUT') {
                        this.state.zoom = Math.max(this.state.zoom - 0.5, 0.5);
                        this.updateLayout(); // é‡æ–°è®¡ç®—å¸ƒå±€å¹¶æ¸²æŸ“
                    }

                    // 4. å…¨æ™¯å¤ä½é€»è¾‘
                    if (type === 'CMD_RESET' || type === 'CMD_ZOOM_RESET') {
                        // ç¡®ä¿ Core å·²åŠ è½½
                        if (this.resetView) {
                            this.resetView();
                        }
                    }

                    // 5. [åŠŸèƒ½] åˆ‡æ¢ç‰¹æ€§ (å¦‚ï¼šæ˜¾ç¤º/éšè—çº½å¸¦è¿æ¥)
                    if (type === 'CMD_TOGGLE_FEATURE') {
                        // payload ä¹Ÿæ˜¯å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ 'connections'
                        this.toggleFeature(payload);
                    }



                    // 8. åŒæ­¥æ»šåŠ¨æŒ‡ä»¤ [Fix] æ‹¦æˆªåˆå§‹åŒ–é˜¶æ®µçš„ç°ä»£å¹´ä»½
                    if (type === 'CMD_SCROLL_TO_YEAR') {
                        const timeSinceInit = Date.now() - this._initTime;
                        // å¦‚æœåœ¨åˆå§‹åŒ–å3ç§’å†…ï¼Œä¸”å¹´ä»½ > 0ï¼ˆç°ä»£ï¼‰ï¼Œåˆ™å¿½ç•¥ï¼ˆå¼ºåˆ¶ä¿æŒåœ¨å¤æœï¼‰
                        if (timeSinceInit < 3000 && payload > 0) {
                            console.log(`[Panorama] æ‹¦æˆªåˆå§‹æ»šåŠ¨æŒ‡ä»¤ï¼š${payload}ï¼Œä¿æŒåœ¨å¤æœ`);
                            return;
                        }
                        if (window.scrollToYear) window.scrollToYear(payload);
                    }

                    // === 9. å…¨å±€çŠ¶æ€åŒæ­¥ï¼ˆå•å‘æ•°æ®æµï¼šçˆ¶â†’å­ï¼‰ ===
                    if (type === 'STATE_SYNC') {
                        // æ¥æ”¶çˆ¶é¡µé¢çš„å…¨å±€çŠ¶æ€ï¼Œæ›´æ–°æœ¬åœ°è§†å›¾
                        const appState = payload;

                        // 1. åŒæ­¥å¹´ä»½
                        if (appState.year !== undefined && window.scrollToYear) {
                            if (!this._userScrolling) {
                                window.scrollToYear(appState.year);
                            }
                        }

                        // 2. åŒæ­¥é€‰ä¸­çš„æ”¿æƒ & åŒºåŸŸ
                        if (appState.region) {
                            if (!this.state.lastClickedGeoCode || this.state.lastClickedGeoCode !== appState.region) {
                                if (this.ui && this.ui.highlightHeader) this.ui.highlightHeader(appState.region);
                            }
                            this.state.lastClickedGeoCode = String(appState.region);
                        }

                        if (appState.selectedRegimeId) {
                            const targetId = appState.selectedRegimeId;
                            const target = this.state.regimeGroups.find(g => g.regimeId === targetId);
                            const alreadyFocused = target && this.state.selectedRegimeId === target.regimeId;

                            if (target && !alreadyFocused) {
                                // [Fix] ç«‹å³æ›´æ–°é€»è¾‘çŠ¶æ€ï¼Œç¡®ä¿åœ¨åŠ¨ç”»æˆ–é‡ç»˜æœŸé—´çŠ¶æ€ä¸€è‡´
                                this.state.selectedRegimeId = targetId;

                                setTimeout(() => {
                                    if (this.ui && this.ui.jumpToRegime) {
                                        this.ui.jumpToRegime(target, false);
                                    }
                                }, 50);
                            }
                        } else if (appState.selectedRegimeId === null && this.state.selectedRegimeId) {
                            // æ¸…é™¤é€‰ä¸­
                            if (this.ui && this.ui.closePanel) this.ui.closePanel();
                        }

                        // è°ƒè¯•æ—¥å¿—
                        // console.log('[Panorama] STATE_SYNC received:', appState);
                    }


                    // [é•œåƒåŒæ­¥æ¶æ„] ç§»é™¤ PREPARE_VIEW_SWITCH å¤„ç†
                    // ä¸¤ä¸ªé¡µé¢å§‹ç»ˆä¿æŒåŒæ­¥ï¼Œè§†å›¾åˆ‡æ¢åªæ˜¯ CSS æ˜¾ç¤º/éšè—ï¼Œæ— éœ€æ¸…ç†
                });

                // Notify parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'CHILD_READY', payload: { source: 'panorama' } }, window.location.origin);
                }

                // Bind UI Events
                this.bindEvents();
                this._setupScrollSync(); // è®¾ç½®æ»šåŠ¨-çŠ¶æ€åŒæ­¥
            },

            // === [å•å‘æ•°æ®æµ] æ·»åŠ æ»šåŠ¨ç›‘å¬ï¼ŒåŒæ­¥å¹´ä»½åˆ°å…¨å±€çŠ¶æ€ ===
            _setupScrollSync: function () {
                const mainContent = document.getElementById('main-content');
                if (!mainContent) return;

                let scrollTimer = null;
                let isProgrammaticScroll = false;
                let userScrollEndTimer = null;
                this._userScrolling = false;

                mainContent.addEventListener('scroll', () => {
                    if (isProgrammaticScroll || window._isProgrammaticScroll) return;

                    // æ ‡è®°ç”¨æˆ·æ­£åœ¨æ»šåŠ¨
                    this._userScrolling = true;
                    clearTimeout(userScrollEndTimer);
                    userScrollEndTimer = setTimeout(() => {
                        this._userScrolling = false;
                    }, 400); // ç¨å¾®é•¿äºæ›´æ–°é¢‘ç‡

                    // èŠ‚æµï¼šæ»šåŠ¨åœæ­¢300msåæ‰æ›´æ–°çŠ¶æ€ï¼ˆé¿å…é«˜é¢‘postMessageï¼‰
                    clearTimeout(scrollTimer);
                    scrollTimer = setTimeout(() => {
                        // [Fix] åˆå§‹åŒ–é˜¶æ®µï¼ˆå‰2ç§’ï¼‰ä¸å‘é€æ»šåŠ¨çŠ¶æ€æ›´æ–°ï¼Œé˜²æ­¢è¦†ç›–URLæŒ‡å®šçš„å¹´ä»½
                        const timeSinceInit = Date.now() - (Core._initTime || Date.now());
                        if (timeSinceInit < 2000) {
                            console.log('[Panorama] åˆå§‹åŒ–é˜¶æ®µï¼Œè·³è¿‡æ»šåŠ¨çŠ¶æ€åŒæ­¥');
                            return;
                        }

                        const centerYear = window.getCenterYear ? window.getCenterYear() : null;
                        if (centerYear !== null && window.parent && window.parent !== window) {
                            window.parent.postMessage({
                                type: 'STATE_UPDATE_REQUEST',
                                payload: { year: Math.round(centerYear) }
                            }, window.location.origin);
                        }
                    }, 300);
                }, { passive: true });

                // å½“æ¥æ”¶åˆ° STATE_SYNC æ—¶ï¼Œæ ‡è®°ä¸ºç¨‹åºåŒ–æ»šåŠ¨
                const originalScrollToYear = window.scrollToYear;
                window.scrollToYear = function (year) {
                    isProgrammaticScroll = true;
                    originalScrollToYear(year);
                    setTimeout(() => { isProgrammaticScroll = false; }, 500);
                };
            },

            // --- [ä¿®å¤] å…¨æ™¯é¡µä¸“ç”¨å¤ä½å‡½æ•° (å®‰å…¨ç‰ˆ) ---
            resetView: function () {
                console.log("ğŸ”„ [Panorama] æ‰§è¡Œå…¨æ™¯å¤ä½...");

                // 1. é‡ç½®æ ¸å¿ƒæ•°æ®
                this.state.zoom = 1.5;
                this.state.lastClickedGeoCode = null;

                // 2. [å®‰å…¨ä¿®å¤] æ›´æ–°æ»‘å— (å…ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨)
                // ä½ çš„ä»£ç é‡Œå…¶å®æ²¡æœ‰ id="zoom-slider"ï¼Œè¿™ä¹‹å‰å¯¼è‡´äº†æŠ¥é”™
                const zSlider = document.getElementById('zoom-slider');
                if (zSlider) {
                    zSlider.value = 1.5;
                }

                // 3. æ¸…ç†èšç„¦çŠ¶æ€
                this.ui.clearFocus();
                this.ui.closePanel();

                // 4. [å®‰å…¨ä¿®å¤] éšè—å¼¹çª— (å…ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨)
                const selModal = document.getElementById('selection-modal');
                if (selModal) selModal.classList.add('hidden');

                const searchRes = document.getElementById('search-results');
                if (searchRes) searchRes.style.display = 'none';

                const searchInp = document.getElementById('search-input');
                if (searchInp) searchInp.value = '';

                // ç§»é™¤é«˜äº®ç±»
                document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));

                // 5. ç«‹å³é‡ç»˜
                this.updateLayout();

                // 6. [å®‰å…¨ä¿®å¤] æ»šåŠ¨å½’é›¶
                const main = document.getElementById('main-content');
                if (main) {
                    main.style.scrollBehavior = 'auto'; // ç¦ç”¨å¹³æ»‘æ»šåŠ¨é˜²æ­¢å†²çª
                    main.scrollTop = 0;
                    main.scrollLeft = 0;

                    // å»¶æ—¶æ¢å¤å¹³æ»‘æ»šåŠ¨ï¼Œå¹¶å†æ¬¡ç¡®ä¿ main å­˜åœ¨
                    setTimeout(() => {
                        const m = document.getElementById('main-content');
                        if (m) m.style.scrollBehavior = 'smooth';
                    }, 500);
                }

                console.log("âœ… å…¨æ™¯è§†å›¾å·²æ¢å¤ (Zoom: 1.5)");
            },

            // [v10] æ–°ä¸€è‡´æ€§æ£€æµ‹æ–¹æ³•
            checkLayoutConsistency: function () {
                if (!this.state.layoutData || !this.state.layoutData.layout || !this.state.rawData) {
                    return;
                }
                if (this.state.hasCheckedConsistency) return;
                this.state.hasCheckedConsistency = true;

                const layout = this.state.layoutData.layout;
                const csvRegimeMap = {}; // geoId -> Set(rcodes)
                const layoutRegimeMap = {}; // geoId -> Set(rcodes)

                // ä» CSV æå–æ”¿æƒåˆ—è¡¨
                for (const frag of this.state.rawData) {
                    const geoId = frag.geoCode;
                    // id format: Name|Code
                    const parts = frag.group.regimeId.split('|');
                    const rcode = parts.length > 1 ? parts[1] : parts[0];
                    if (!csvRegimeMap[geoId]) csvRegimeMap[geoId] = new Set();
                    csvRegimeMap[geoId].add(rcode);
                }

                // ä»å¸ƒå±€æå–æ”¿æƒåˆ—è¡¨
                for (const geoId in layout) {
                    layoutRegimeMap[geoId] = new Set();
                    for (const year in layout[geoId]) {
                        for (const regime of layout[geoId][year]) {
                            const parts = regime.split('|');
                            const rcode = parts.length > 1 ? parts[1] : parts[0];
                            if (rcode) layoutRegimeMap[geoId].add(rcode);
                        }
                    }
                }

                // æ¯”å¯¹
                const added = {}; // æ–°å¢æ”¿æƒ (CSV æœ‰, Layout æ— )
                const removed = {}; // åˆ é™¤æ”¿æƒ (Layout æœ‰, CSV æ— )
                let totalAdded = 0;
                let totalRemoved = 0;

                for (const geoId in csvRegimeMap) {
                    const csvSet = csvRegimeMap[geoId];
                    const layoutSet = layoutRegimeMap[geoId] || new Set();

                    const addedList = [...csvSet].filter(r => !layoutSet.has(r));

                    if (addedList.length > 0) {
                        added[geoId] = addedList;
                        totalAdded += addedList.length;
                    }
                }

                // Check removed regimes
                for (const geoId in layoutRegimeMap) {
                    const layoutSet = layoutRegimeMap[geoId];
                    const csvSet = csvRegimeMap[geoId] || new Set();

                    const removedList = [...layoutSet].filter(r => !csvSet.has(r));

                    if (removedList.length > 0) {
                        removed[geoId] = removedList;
                        totalRemoved += removedList.length;
                    }
                }

                // é™é»˜å¤„ç†åˆ é™¤çš„æ”¿æƒ
                if (totalRemoved > 0) {
                    console.warn(`[Layout] å¸ƒå±€ä¸­æœ‰ ${totalRemoved} ä¸ªå·²åˆ é™¤çš„æ”¿æƒ`, removed);
                }

                // å¤„ç†æ–°å¢æ”¿æƒ
                if (totalAdded > 0) {
                    console.warn('[Layout] æ£€æµ‹åˆ°æ–°å¢æ”¿æƒ:', added);

                    const isDev = location.hostname === 'localhost' ||
                        location.hostname === '127.0.0.1' ||
                        location.hostname.startsWith('192.168.') ||
                        location.protocol === 'file:';

                    if (isDev) {
                        // å¼€å‘è€…æ¨¡å¼ï¼šå¼¹çª—æç¤º
                        setTimeout(() => {
                            const msg = `æ£€æµ‹åˆ° ${totalAdded} ä¸ªæ–°å¢æ”¿æƒæœªåœ¨å¸ƒå±€ä¸­å®šä¹‰ã€‚\n(è¯¦è§æ§åˆ¶å°)\n\næ˜¯å¦è·³è½¬åˆ° LayoutOptimizer æ›´æ–°å¸ƒå±€ï¼Ÿ`;
                            if (confirm(msg)) {
                                location.href = 'LayoutOptimizer.html';
                            }
                        }, 500); // Slight delay to ensure render happens first
                    }
                } else if (totalRemoved === 0) {
                    console.log('âœ… [Layout] ä¸€è‡´æ€§æ£€æŸ¥é€šè¿‡: CSV ä¸ å¸ƒå±€æ•°æ®å®Œå…¨åŒ¹é…');
                }
            },

            bindEvents: function () {
                const safeBind = (id, event, handler) => { const el = document.getElementById(id); if (el) el.addEventListener(event, handler); };
                safeBind('btn-connections', 'click', () => this.toggleFeature('connections'));
                safeBind('btn-close-panel', 'click', () => this.ui.closePanel());
                safeBind('btn-close-modal', 'click', () => document.getElementById('selection-modal').classList.add('hidden'));
                safeBind('btn-flip-cols', 'click', () => {
                    this.state.isFlipped = !this.state.isFlipped;
                    this.updateLayout();
                    // å¯é€‰ï¼šç»™æŒ‰é’®å¢åŠ æ¿€æ´»çŠ¶æ€æ ·å¼
                    const btn = document.getElementById('btn-flip-cols');
                    if (btn) btn.style.color = this.state.isFlipped ? 'var(--blue-400)' : 'var(--slate-500)';
                });
                safeBind('quick-nav', 'change', (e) => {
                    const y = parseInt(e.target.value);
                    if (!isNaN(y)) {
                        const targetY = (y - APP_CONFIG.minYear) * this.state.zoom;
                        document.getElementById('main-content').scrollTo({ top: targetY, behavior: 'smooth' });
                    }
                });

                // [UX] ç‚¹å‡»é¢æ¿ header ä»»æ„ä½ç½®å…³é—­é¢æ¿
                const panelHeader = document.querySelector('#editor-panel .panel-header');
                if (panelHeader) {
                    panelHeader.addEventListener('click', (e) => {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®æˆ–å…¶å­å…ƒç´ ï¼Œå¿½ç•¥
                        if (e.target.closest('button') || e.target.closest('.jump-btn')) return;
                        this.ui.closePanel();
                    });
                }

                const searchInput = document.getElementById('search-input');
                const handleSearch = (val) => {
                    const term = val.trim().toLowerCase();
                    document.querySelectorAll('.era-block-fragment').forEach(b => {
                        if (b.dataset.name) b.classList.toggle('era-dimmed', term !== "" && !b.dataset.name.toLowerCase().includes(term));
                    });
                    this.ui.populateSearchResults(term);
                };
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => handleSearch(e.target.value));
                    searchInput.addEventListener('focus', (e) => { if (e.target.value.trim().length > 0) handleSearch(e.target.value); });
                }

                const zSlide = document.getElementById('zoom-slider');
                if (zSlide) zSlide.addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    requestAnimationFrame(() => this.render.drawAll());
                });

                // Add Interaction for render area
                const renderArea = document.getElementById('render-area');
                if (renderArea) {
                    const crosshairLine = document.getElementById('crosshair-line');
                    // [ä¿®æ”¹] ç§»é™¤å¤–éƒ¨çš„ const crosshairLabel = ...

                    renderArea.addEventListener('mousemove', function (e) {
                        const rect = renderArea.getBoundingClientRect();
                        const y = e.clientY - rect.top;

                        // 1. Crosshair Line & Label
                        if (crosshairLine) { crosshairLine.style.display = 'block'; crosshairLine.style.top = y + 'px'; }
                        const crosshairLabel = document.getElementById('crosshair-label'); // Dynamic get
                        const year = Math.floor((y / Core.state.zoom) + APP_CONFIG.minYear);
                        if (crosshairLabel) { crosshairLabel.style.display = 'block'; crosshairLabel.style.top = y + 'px'; crosshairLabel.innerText = year; }


                        // [Fix] Dynamically calculate column metrics to avoid ReferenceError
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const cols = headerBody.children;
                            const colCount = cols.length;

                            if (colCount > 0) {
                                // Get actual width of first column
                                const colW = cols[0].getBoundingClientRect().width;
                                const mouseX = e.clientX - rect.left;
                                const colIdx = Math.floor(mouseX / colW);

                                if (cols.length > colIdx && colIdx >= 0) {
                                    const old = headerBody.querySelector('.active-header');
                                    const target = cols[colIdx];
                                    if (old !== target) {
                                        if (old) old.classList.remove('active-header');
                                        if (target) target.classList.add('active-header');
                                    }
                                }
                            }
                        }
                    });

                    renderArea.addEventListener('mouseleave', function () {
                        if (crosshairLine) crosshairLine.style.display = 'none';
                        const crosshairLabel = document.getElementById('crosshair-label');
                        if (crosshairLabel) crosshairLabel.style.display = 'none';

                        // Clear header highlight
                        const headerBody = document.getElementById('header-body');
                        if (headerBody) {
                            const old = headerBody.querySelector('.active-header');
                            if (old) old.classList.remove('active-header');
                        }
                    });
                }
            },

            processData: function (rows) {
                if (!rows || rows.length === 0) {
                    console.error("Panorama received empty data");
                    return;
                }

                // 1. å»ºç«‹ Code -> Name å…¨å±€æŸ¥æ‰¾è¡¨ (ç”¨äºè§£æå®—ä¸»å›½ä»£ç )
                const codeToNameMap = {};
                rows.forEach(r => {
                    const code = r.regime_code;
                    const name = r.regime_name || r.name;
                    if (code && name) codeToNameMap[code] = name;
                });

                const uniqueRegs = {};
                const groups = {};
                const rawList = [];

                rows.forEach((r, i) => {
                    const geoCode = r.geo_code || r.geo;
                    const geoName = r.geo_name || r.region || "æœªçŸ¥";

                    if (!geoCode) return;
                    if (!uniqueRegs[geoCode]) uniqueRegs[geoCode] = geoName;

                    const regimeName = r.regime_name || r.name || "æœªçŸ¥æ”¿æƒ";
                    // [Fix] Fallback é€»è¾‘ä¸ LayoutOptimizer ç»Ÿä¸€ï¼šå¦‚æœæ²¡æœ‰ Codeï¼Œä½¿ç”¨ Name ä»£æ›¿ï¼Œè€Œä¸æ˜¯ "C11"
                    const regimeCode = r.regime_code || regimeName;
                    // [Fix] ä½¿ç”¨ name + code ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œé˜²æ­¢åŒåä¸åŒæ”¿æƒè¢«é”™è¯¯åˆå¹¶
                    // ä¾‹å¦‚ï¼šæˆ˜å›½ç§¦(R1150) å’Œ ç§¦æœç§¦(C2100) å¿…é¡»åˆ†å¼€
                    const key = regimeName + '|' + regimeCode;

                    // åˆå§‹åŒ– Group
                    if (!groups[key]) {
                        groups[key] = {
                            regimeId: key, // [Unified] æ”¿æƒå”¯ä¸€æ ‡è¯†ç¬¦ (æ ¼å¼: Name|Code)
                            groupId: 'g-' + this.logic.simpleHash(key), // CSS class name (hash)
                            name: regimeName,  // æ˜¾ç¤ºåç§°ä»ç„¶æ˜¯ regimeName
                            regimeCode: regimeCode,
                            minStart: 9999, maxEnd: -9999,
                            explicitTier: parseInt(r.regime_tier || r.level || 3),
                            fragments: [],
                            visualSlices: [],
                            globalMinCol: 9999, globalMaxCol: -9999,
                            // Group çº§åˆ«çš„å®—ä¸»ä¿¡æ¯ä»…ä½œå‚è€ƒï¼ˆå–å‡ºç°è¿‡çš„ä»»ä½•ä¸€ä¸ªï¼‰
                            suzerain: null
                        };
                    }

                    let start = parseInt(r.start_year || r.year_start);
                    let end = (r.end_year === 'present' || r.year_end === 'present') ? TIME_CONFIG.MAX_YEAR : parseInt(r.end_year || r.year_end);
                    if (isNaN(start)) start = TIME_CONFIG.DEFAULT_START || -200;
                    if (isNaN(end)) end = TIME_CONFIG.MAX_YEAR;

                    // ã€å…³é”®ä¿®å¤ã€‘ä¸ºå½“å‰è¿™ä¸€è¡Œï¼ˆFragmentï¼‰è§£æå®—ä¸»å›½åç§°
                    let rawSuzCode = r.suzerain_code || r.suzerain;
                    let resolvedSuzName = null;

                    if (rawSuzCode && rawSuzCode !== 'null') {
                        if (r.suzerain_type === 'V|J' && rawSuzCode.includes('|')) {
                            // åŒé‡å…³ç³»ï¼šåˆ†åˆ«ç¿»è¯‘
                            const parts = rawSuzCode.split('|');
                            const name1 = codeToNameMap[parts[0]] || parts[0];
                            const name2 = codeToNameMap[parts[1]] || parts[1];
                            resolvedSuzName = `${name1}|${name2}`;
                        } else {
                            // å•é‡å…³ç³»
                            resolvedSuzName = codeToNameMap[rawSuzCode] || rawSuzCode;
                        }
                    } else {
                        // æ˜¾å¼æ ‡è®°ä¸ºç©ºï¼Œç¡®ä¿è¯¦æƒ…é¡µèƒ½è¯†åˆ«å‡º"æ— "
                        rawSuzCode = null;
                    }

                    // æ„å»º Fragment
                    const frag = {
                        id: i, name: key, start: start, end: end,
                        regimeCode: r.regime_code, geoCode: geoCode,
                        explicitTier: groups[key].explicitTier,

                        // ç¡®ä¿å­˜å…¥è§£æåçš„æ•°æ®
                        suzerain: rawSuzCode,
                        suzerainName: resolvedSuzName,
                        suzerainType: r.suzerain_type,
                        desc: r.desc,
                        group: groups[key] // [Fix] Link back to group for easy access
                    };

                    groups[key].fragments.push(frag);
                    groups[key].minStart = Math.min(groups[key].minStart, start);
                    groups[key].maxEnd = Math.max(groups[key].maxEnd, end);
                    groups[key].globalMinYear = Math.min(groups[key].globalMinYear, start);
                    groups[key].globalMaxYear = Math.max(groups[key].globalMaxYear, end);

                    rawList.push(frag);
                });

                this.state.rawRegions = Object.entries(uniqueRegs).map(([k, v]) => ({ id: k, label: v }));
                this.state.regimeGroups = Object.values(groups);
                this.state.rawData = rawList;

                this.updateLayout();
            },

            updateLayout: function () {
                // [v10] ä¸€è‡´æ€§æ£€æµ‹å·²ç§»è‡³ç‹¬ç«‹çš„ checkLayoutConsistency æ–¹æ³•

                this.state.regions = this.logic.applyFixedLayout(this.state.rawRegions);
                this.state.regionIndexMap = this.state.regions.reduce((acc, r, i) => { acc[r.id] = i; return acc; }, {});

                this.logic.calculateGroupCenters(this.state.regimeGroups, this.state.regionIndexMap);
                this.render.drawAll();
                this.state.dataReady = true;

                // [Fix] å¤„ç†æš‚å­˜çš„æ»šåŠ¨è¯·æ±‚ï¼ˆè§£å†³åˆå§‹åŒ–æ•°æ®æœªåŠ è½½å®Œæˆæ—¶çš„æ»šåŠ¨ä¸¢å¤±é—®é¢˜ï¼‰
                if (window._pendingScrollYear !== null) {
                    const target = window._pendingScrollYear;
                    window._pendingScrollYear = null;
                    setTimeout(() => window.scrollToYear(target), 50);
                    this.state.hasInitialScrolled = true;
                }
                // [Fix] åˆå§‹åŠ è½½æ—¶ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•å¤–éƒ¨æŒ‡ä»¤ï¼Œé»˜è®¤æ»šåŠ¨åˆ°é¡¶éƒ¨
                else if (!this.state.hasInitialScrolled) {
                    this.state.hasInitialScrolled = true;
                    setTimeout(() => {
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.scrollTop = 0;
                            mainContent.scrollLeft = 0;
                        }
                    }, 50);
                }
            },

            getStyle: function (group, frag) {
                const regimeCode = group.regimeCode;
                const name = group.name;
                const suzerainCode = (frag && frag.suzerain) ? frag.suzerain : group.suzerain;
                const suzerainType = (frag && frag.suzerainType) ? frag.suzerainType : group.suzerainType;

                if (window.parent && window.parent.GlobalUtils) {
                    try {
                        return window.parent.GlobalUtils.getStyle(regimeCode, name, suzerainCode, suzerainType);
                    } catch (e) {
                        console.warn("Call parent GlobalUtils.getStyle failed", e);
                    }
                }
                return { bg: '#666', border: '#444', className: 'texture-N', isDashed: false };
            },



            logic: {
                // [New] Perspective-Based Layout Optimization

                // Extract core regions from perspective configuration
                extractCoreRegions: function (perspective) {
                    const coreRegions = new Set();

                    Core.state.regimeGroups.forEach(group => {
                        if (perspective.coreRegimes.includes(group.regimeId)) {
                            group.fragments.forEach(frag => {
                                coreRegions.add(frag.geoCode);
                            });
                        }
                    });

                    console.log(`[${perspective.name}] æ ¸å¿ƒåŒºåŸŸ: ${coreRegions.size} åˆ—`, Array.from(coreRegions));
                    return coreRegions;
                },

                // Check if two regions belong to the same core regime
                belongToSameRegime: function (regionA, regionB, coreRegimes) {
                    for (let regimeId of coreRegimes) {
                        const group = Core.state.regimeGroups.find(g => g.regimeId === regimeId);
                        if (!group) continue;

                        const regionsInRegime = new Set(group.fragments.map(f => f.geoCode));
                        if (regionsInRegime.has(regionA) && regionsInRegime.has(regionB)) {
                            return true;
                        }
                    }
                    return false;
                },

                // Build weighted affinity matrix for perspective
                buildWeightedMatrix: function (perspective, baseMatrix) {
                    if (perspective.isDefault) {
                        // Default perspective: use base matrix as-is
                        return baseMatrix;
                    }

                    const coreRegions = this.extractCoreRegions(perspective);
                    const n = Core.state.rawRegions.length;
                    const matrix = Array(n).fill(0).map((_, i) => baseMatrix[i].slice());

                    // Apply weights
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const rA = Core.state.rawRegions[i].id;
                            const rB = Core.state.rawRegions[j].id;

                            const bothCore = coreRegions.has(rA) && coreRegions.has(rB);
                            const bothBg = !coreRegions.has(rA) && !coreRegions.has(rB);

                            if (bothCore) {
                                const sameRegime = this.belongToSameRegime(rA, rB, perspective.coreRegimes);
                                matrix[i][j] *= sameRegime
                                    ? perspective.weights.intraRegime
                                    : perspective.weights.interRegime;
                            } else if (bothBg) {
                                matrix[i][j] *= perspective.weights.background;
                            } else {
                                matrix[i][j] *= perspective.weights.background;
                            }
                        }
                    }

                    return matrix;
                },

                getRegimeTier: function (t) { return parseInt(t) || 3; },
                simpleHash: function (str) { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); },

                calculateGroupCenters: function (groups, regionIndexMap) {
                    groups.forEach(g => {
                        let totalCol = 0, count = 0;
                        g.fragments.forEach(f => {
                            const idx = regionIndexMap[f.geoCode];
                            if (idx !== undefined) {
                                totalCol += idx; count++;
                                g.globalMinCol = Math.min(g.globalMinCol, idx);
                                g.globalMaxCol = Math.max(g.globalMaxCol, idx);
                            }
                        });
                        g.centerCol = count > 0 ? (totalCol / count) : 0;
                        g.globalDuration = g.globalMaxYear - g.globalMinYear;
                    });
                },

                applyFixedLayout: function (rawRegions) {
                    let sorted = [];
                    if (Core.state.layoutData && Core.state.layoutData.colOrder) {
                        const colOrder = Core.state.layoutData.colOrder;
                        const orderMap = {};
                        colOrder.forEach((id, i) => orderMap[id] = i);

                        // [Fix v8] æ™ºèƒ½å¤„ç† colOrder ä¸­ç¼ºå¤±çš„åŒºåŸŸ
                        // æ ¹æ®æ•°å­— ID æ‰¾åˆ°ç›¸é‚»ä½ç½®æ’å…¥ï¼Œè€Œä¸æ˜¯æ”¾åˆ°æœ€å
                        const missingRegions = rawRegions.filter(r => orderMap[r.id] === undefined);
                        if (missingRegions.length > 0) {
                            console.warn(`[Layout] ${missingRegions.length} ä¸ªåŒºåŸŸä¸åœ¨ colOrder ä¸­:`, missingRegions.map(r => r.id));
                            // ä¸ºç¼ºå¤±åŒºåŸŸè®¡ç®—æ’å…¥ä½ç½®
                            missingRegions.forEach(region => {
                                const regionIdNum = parseInt(region.id);
                                // æ‰¾åˆ° colOrder ä¸­ç¬¬ä¸€ä¸ªæ¯”å½“å‰ ID å¤§çš„ä½ç½®
                                let insertRank = colOrder.length;
                                for (let i = 0; i < colOrder.length; i++) {
                                    if (parseInt(colOrder[i]) > regionIdNum) {
                                        insertRank = i;
                                        break;
                                    }
                                }
                                // ä½¿ç”¨å°æ•°ä½œä¸º rankï¼Œç¡®ä¿æ’å…¥åˆ°æ­£ç¡®ä½ç½®
                                orderMap[region.id] = insertRank - 0.5;
                            });
                        }

                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = orderMap[a.id] !== undefined ? orderMap[a.id] : 9999;
                            const rB = orderMap[b.id] !== undefined ? orderMap[b.id] : 9999;
                            return rA - rB;
                        });
                    } else {
                        // Fallback (Original fixed order)
                        const FIXED_ORDER = ['550', '530', '520', '510', '540', '440', '410', '420', '430', '330', '350', '340', '260', '270', '310', '250', '240', '320', '220', '210', '230', '190', '150', '130', '140', '160', '120', '110', '180', '170', '610', '620', '740', '730', '720', '710', '820', '810', '840', '830', '850', '910', '920', '930', '940', '950', '960'];
                        const rankMap = {}; FIXED_ORDER.forEach((c, i) => rankMap[c] = i);
                        sorted = rawRegions.slice().sort((a, b) => {
                            const rA = rankMap[a.id] !== undefined ? rankMap[a.id] : 9999;
                            const rB = rankMap[b.id] !== undefined ? rankMap[b.id] : 9999;
                            return rA - rB;
                        });
                    }

                    if (Core.state.isFlipped) {
                        sorted.reverse();
                    }
                    return sorted;
                },

                sliceFragmentsByRegion: function (fragments, colIdx, allGroups, regionIndexMap, layoutCache) {
                    if (!fragments || fragments.length === 0) return [];
                    const slices = [];

                    // 1. è·å–å½“å‰åˆ—å¯¹åº”çš„ Region ID
                    // fragments ä¸­çš„ geoCode åº”è¯¥éƒ½æ˜¯åŒä¸€ä¸ªï¼Œä½†ä¸ºäº†ä¿é™©å» Core.state.regions æŸ¥
                    const regionObj = Core.state.regions[colIdx];
                    if (!regionObj) return [];
                    const regionId = regionObj.id;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰é¢„è®¡ç®—çš„ Slice æ•°æ® (ä¼˜å…ˆ)
                    const sliceData = Core.state.sliceData && Core.state.sliceData[regionId];

                    if (sliceData && sliceData.length > 0) {
                        // === æ–°é€»è¾‘ï¼šåŸºäº Slice æ•°æ®ç”Ÿæˆ ===
                        fragments.forEach(frag => {
                            const fStart = frag.start;
                            const fEnd = frag.end;
                            const regimeName = frag.group.name;
                            const regimeCode = frag.group.regimeCode || regimeName;
                            const targetID = regimeName + "|" + regimeCode;

                            // éå†è¯¥åŒºåŸŸçš„æ‰€æœ‰åˆ‡ç‰‡
                            // ä¼˜åŒ–ï¼šå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°èµ·å§‹åˆ‡ç‰‡ï¼Œè¿™é‡Œæš‚æ—¶éå†
                            sliceData.forEach(slice => {
                                // æ£€æŸ¥åˆ‡ç‰‡æ˜¯å¦ä¸æ”¿æƒæ—¶é—´æœ‰äº¤é›†
                                const sStart = slice.start;
                                const sEnd = slice.end;
                                if (sEnd <= fStart || sStart >= fEnd) return;

                                // è®¡ç®—äº¤é›†æ—¶é—´æ®µ
                                const overlapStart = Math.max(fStart, sStart);
                                const overlapEnd = Math.min(fEnd, sEnd);
                                if (overlapStart >= overlapEnd) return;

                                // æŸ¥æ‰¾æ”¿æƒåœ¨è¯¥åˆ‡ç‰‡ä¸­çš„ä½ç½®
                                const slots = slice.slots;
                                let slotIdx = slots.indexOf(targetID);
                                // å…¼å®¹åªå­˜ ID çš„æƒ…å†µ
                                if (slotIdx === -1) slotIdx = slots.findIndex(id => id.startsWith(regimeName + '|'));

                                let totalSlots = slots.length;
                                let left = 0, width = 100;

                                if (slotIdx !== -1) {
                                    width = 100 / totalSlots;
                                    if (Core.state.isFlipped) {
                                        left = (totalSlots - 1 - slotIdx) * width;
                                    } else {
                                        left = slotIdx * width;
                                    }
                                } else {
                                    // æ²¡æ‰¾åˆ°ï¼ˆå¯èƒ½æ˜¯æ•°æ®ä¸ä¸€è‡´æˆ–æ–°æ”¿æƒï¼‰
                                    // ä»ç„¶æ˜¾ç¤ºï¼Œè¿½åŠ åˆ°æœ«å°¾
                                    const effectiveTotal = Math.max(totalSlots, 1) + 1;
                                    width = 100 / effectiveTotal;
                                    left = Core.state.isFlipped ? 0 : (effectiveTotal - 1) * width;
                                }

                                pushSlice(slices, frag, overlapStart, overlapEnd, left, width, colIdx);
                            });
                        });
                        return slices;
                    }

                    // 3. (Fallback) æ²¡æœ‰æ•°æ®æ—¶è¿”å›ç©º
                    console.warn('[Layout] No sliceData found for region ' + regionId);
                    return slices;

                    function pushSlice(outArr, originalFrag, s, e, l, w, cIdx) {
                        if (s >= e) return;
                        const newFrag = Object.assign({}, originalFrag);
                        newFrag.displayStart = s;
                        newFrag.displayEnd = e;
                        newFrag.leftPct = l;
                        newFrag.widthPct = w;

                        // æ›´æ–° Group ç»Ÿè®¡ä¿¡æ¯
                        newFrag.group.visualSlices.push({
                            cIdx: cIdx,
                            start: s, end: e,
                            left: l / 100, w: w / 100,
                            dur: e - s
                        });

                        outArr.push(newFrag);
                    }

                    return slices;
                },

                calculateLabelPositions: function (group, regionIndexMap, colWidth) {
                    const frags = group.visualSlices;
                    if (!frags || frags.length === 0) return [];

                    frags.sort((a, b) => a.cIdx - b.cIdx || a.start - b.start);

                    const clusters = [];
                    const processed = new Set();

                    frags.forEach((f, i) => {
                        if (processed.has(i)) return;
                        const currentCluster = [f];
                        processed.add(i);

                        let queue = [f];
                        while (queue.length > 0) {
                            let curr = queue.shift();
                            for (let j = 0; j < frags.length; j++) {
                                if (processed.has(j)) continue;
                                const cand = frags[j];

                                // åŒä¸€åˆ— + æ—¶é—´æ¥è§¦
                                const sameCol = (cand.cIdx === curr.cIdx);
                                const timeTouch = (cand.start <= curr.end + 5) && (cand.end >= curr.start - 5);

                                // ç›¸é‚»åˆ— + æ—¶é—´é‡å  + [Fix] æ°´å¹³æ–¹å‘çœŸæ­£æ¥è§¦
                                const neighborCol = Math.abs(cand.cIdx - curr.cIdx) === 1;
                                const timeOverlap = (cand.start < curr.end) && (cand.end > curr.start);

                                // [Fix] æ£€æŸ¥æ°´å¹³æ–¹å‘æ˜¯å¦çœŸæ­£æ¥è§¦
                                // ä½¿ç”¨å®é™…çš„ X åæ ‡èŒƒå›´æ£€æŸ¥æ˜¯å¦æœ‰æ¥è§¦æˆ–é‡å 
                                let horizontalTouch = false;
                                if (neighborCol && timeOverlap) {
                                    // è®¡ç®—ä¸¤ä¸ªç‰‡æ®µçš„å®é™… X åæ ‡èŒƒå›´
                                    const currLeft = curr.cIdx + curr.left;
                                    const currRight = curr.cIdx + curr.left + curr.w;
                                    const candLeft = cand.cIdx + cand.left;
                                    const candRight = cand.cIdx + cand.left + cand.w;

                                    // ä¸¤ä¸ªèŒƒå›´æ¥è§¦æˆ–é‡å ï¼šä¸€ä¸ªçš„å³è¾¹ç•Œ >= å¦ä¸€ä¸ªçš„å·¦è¾¹ç•Œ
                                    // å…è®¸ 0.05 çš„å®¹å·®
                                    horizontalTouch = (currRight >= candLeft - 0.05) && (candRight >= currLeft - 0.05);
                                }

                                if ((sameCol && timeTouch) || (neighborCol && timeOverlap && horizontalTouch)) {
                                    currentCluster.push(cand);
                                    processed.add(j);
                                    queue.push(cand);
                                }
                            }
                        }
                        clusters.push(currentCluster);
                    });

                    const results = clusters.map(cluster => {
                        let totalArea = 0;
                        let weightedX = 0;
                        let weightedY = 0;
                        let minTime = 9999, maxTime = -9999;
                        let minC = 9999, maxC = -9999;

                        let maxSliceArea = -1;
                        let bestSlice = null;

                        cluster.forEach(f => {
                            const h = f.dur;
                            const wPct = f.w;
                            const area = h * wPct;

                            const physCenterX = (f.cIdx + f.left + (f.w / 2)) * colWidth;
                            const physCenterY = (f.start + f.end) / 2;

                            weightedX += physCenterX * area;
                            weightedY += physCenterY * area;
                            totalArea += area;

                            minTime = Math.min(minTime, f.start);
                            maxTime = Math.max(maxTime, f.end);
                            minC = Math.min(minC, f.cIdx);
                            maxC = Math.max(maxC, f.cIdx);
                        });

                        // [Fix v2] è®¡ç®—"æœ€ä½³æ”¾ç½®åŒºåŸŸ"ï¼šè€ƒè™‘æ°´å¹³ç›¸é‚»ç‰‡æ®µçš„åˆå¹¶
                        // é‡‡æ ·å¤šä¸ªæ—¶é—´ç‚¹ï¼Œè®¡ç®—æ¯ä¸ªæ—¶é—´ç‚¹çš„åˆå¹¶å®½åº¦
                        const sampleCount = 10;
                        const timeStep = (maxTime - minTime) / sampleCount;

                        for (let i = 0; i <= sampleCount; i++) {
                            const sampleYear = minTime + i * timeStep;

                            // æ‰¾å‡ºåœ¨è¿™ä¸ªæ—¶é—´ç‚¹å­˜åœ¨çš„æ‰€æœ‰ç‰‡æ®µ
                            const activeSlices = cluster.filter(f =>
                                f.start <= sampleYear && f.end >= sampleYear
                            );

                            if (activeSlices.length === 0) continue;

                            // [Fix v3] å°†æ´»è·ƒç‰‡æ®µæŒ‰æ°´å¹³è¿æ¥åˆ†ç»„
                            // åªæœ‰çœŸæ­£æ°´å¹³æ¥è§¦çš„ç‰‡æ®µæ‰åœ¨åŒä¸€ç»„
                            const groups = [];
                            const used = new Set();

                            activeSlices.forEach((slice, idx) => {
                                if (used.has(idx)) return;

                                // å¼€å§‹ä¸€ä¸ªæ–°çš„è¿æ¥ç»„
                                const group = [slice];
                                used.add(idx);

                                // BFS æ‰¾å‡ºæ‰€æœ‰ä¸å½“å‰ç‰‡æ®µæ°´å¹³è¿æ¥çš„ç‰‡æ®µ
                                const queue = [slice];
                                while (queue.length > 0) {
                                    const curr = queue.shift();
                                    const currLeft = curr.cIdx + curr.left;
                                    const currRight = currLeft + curr.w;

                                    activeSlices.forEach((cand, candIdx) => {
                                        if (used.has(candIdx)) return;
                                        const candLeft = cand.cIdx + cand.left;
                                        const candRight = candLeft + cand.w;

                                        // æ£€æŸ¥æ˜¯å¦æ°´å¹³æ¥è§¦ï¼ˆæœ‰é‡å æˆ–ç´§é‚»ï¼‰
                                        const touches = (currRight >= candLeft - 0.05) && (candRight >= currLeft - 0.05);
                                        if (touches) {
                                            group.push(cand);
                                            used.add(candIdx);
                                            queue.push(cand);
                                        }
                                    });
                                }

                                groups.push(group);
                            });

                            // å¯¹æ¯ä¸ªè¿æ¥ç»„è®¡ç®—é¢ç§¯ï¼Œé€‰æ‹©æœ€å¤§çš„
                            groups.forEach(group => {
                                // è®¡ç®—è¯¥ç»„çš„åˆå¹¶è¾¹ç•Œ
                                let groupLeft = Infinity, groupRight = -Infinity;
                                group.forEach(f => {
                                    const left = f.cIdx + f.left;
                                    const right = left + f.w;
                                    groupLeft = Math.min(groupLeft, left);
                                    groupRight = Math.max(groupRight, right);
                                });

                                const groupWidth = groupRight - groupLeft;

                                // è®¡ç®—è¯¥ç»„çš„å…¬å…±æ—¶é—´èŒƒå›´
                                let commonStart = -Infinity, commonEnd = Infinity;
                                group.forEach(f => {
                                    commonStart = Math.max(commonStart, f.start);
                                    commonEnd = Math.min(commonEnd, f.end);
                                });
                                const commonDuration = Math.max(0, commonEnd - commonStart);

                                // è¯„åˆ† = å®½åº¦ Ã— âˆšæ—¶é—´è·¨åº¦
                                const score = groupWidth * Math.sqrt(commonDuration);

                                if (score > maxSliceArea) {
                                    maxSliceArea = score;

                                    // [Fix] ä½¿ç”¨è¯¥ç»„ç‰‡æ®µçš„é¢ç§¯åŠ æƒä¸­å¿ƒï¼ˆX å’Œ Yï¼‰
                                    let weightedCenterX = 0;
                                    let weightedCenterY = 0;
                                    let totalGroupArea = 0;
                                    group.forEach(f => {
                                        const sliceCenterX = f.cIdx + f.left + f.w / 2;
                                        const sliceCenterY = (f.start + f.end) / 2;  // ç‰‡æ®µçš„æ—¶é—´ä¸­ç‚¹
                                        const sliceArea = f.w * f.dur;  // ä½¿ç”¨ç‰‡æ®µè‡ªèº«çš„æ—¶é—´è·¨åº¦
                                        weightedCenterX += sliceCenterX * sliceArea;
                                        weightedCenterY += sliceCenterY * sliceArea;
                                        totalGroupArea += sliceArea;
                                    });
                                    const centerX = totalGroupArea > 0
                                        ? (weightedCenterX / totalGroupArea) * colWidth
                                        : (groupLeft + groupWidth / 2) * colWidth;
                                    const centerY = totalGroupArea > 0
                                        ? (weightedCenterY / totalGroupArea)
                                        : (commonStart + commonEnd) / 2;

                                    bestSlice = {
                                        x: centerX,
                                        y: centerY,  // ä½¿ç”¨åŠ æƒä¸­å¿ƒ Y
                                        w: groupWidth * colWidth,
                                        h: commonDuration,
                                        left: groupLeft * colWidth,
                                        right: groupRight * colWidth,
                                        top: commonStart,
                                        bottom: commonEnd
                                    };
                                }
                            });
                        }

                        if (totalArea === 0) return null;

                        const finalX = weightedX / totalArea;
                        const finalY = weightedY / totalArea;
                        const fullHeight = maxTime - minTime;
                        const effectiveWidthPx = (totalArea / Math.max(fullHeight, 1)) * colWidth;
                        const boundingWidthPx = (maxC - minC + 1) * colWidth;
                        const colSpan = maxC - minC + 1;

                        // [Fix] è®¡ç®—è¿™ä¸ª cluster çš„ç²¾ç¡®è¾¹ç•Œæ¡†ï¼ˆåƒç´ åæ ‡ï¼‰
                        // è€Œä¸æ˜¯æ•´ä¸ªæ”¿æƒçš„è”åˆè¾¹ç•Œæ¡†
                        let clusterMinX = Infinity, clusterMaxX = -Infinity;
                        let clusterMinY = Infinity, clusterMaxY = -Infinity;

                        cluster.forEach(f => {
                            const left = (f.cIdx + f.left) * colWidth;
                            const right = left + f.w * colWidth;
                            clusterMinX = Math.min(clusterMinX, left);
                            clusterMaxX = Math.max(clusterMaxX, right);
                            // æ³¨æ„ï¼šè¿™é‡Œçš„ Y æ˜¯å¹´ä»½ï¼Œéœ€è¦åœ¨ä½¿ç”¨æ—¶è½¬æ¢ä¸ºåƒç´ 
                            clusterMinY = Math.min(clusterMinY, f.start);
                            clusterMaxY = Math.max(clusterMaxY, f.end);
                        });

                        return {
                            x: finalX,
                            y: finalY,
                            bestSlice: bestSlice,
                            w: effectiveWidthPx,
                            fullW: boundingWidthPx,
                            colSpan: colSpan,
                            h: fullHeight,
                            area: totalArea,
                            // [Fix] æ·»åŠ  cluster çš„è¾¹ç•Œæ¡†ï¼ˆæ³¨æ„ Y æ˜¯å¹´ä»½ï¼‰
                            clusterBounds: {
                                minX: clusterMinX,
                                maxX: clusterMaxX,
                                minY: clusterMinY,  // å¹´ä»½
                                maxY: clusterMaxY   // å¹´ä»½
                            }
                        };
                    }).filter(r => r !== null);

                    if (group.explicitTier == 1) {
                        results.sort((a, b) => b.area - a.area);
                        return [results[0]];
                    }

                    return results.filter(r => r.area > 5);
                }
            },

            render: {
                drawAll: function () {
                    // æ¢å¤ä¸¥æ ¼ç¢°æ’æ£€æµ‹ï¼Œä¸ä½¿ç”¨ Monkey Patch
                    collisionMgr.reset();

                    Core.state.regimeGroups.forEach(g => g.visualSlices = []);

                    let container = document.getElementById('chart-container');
                    if (!container) return;

                    let headerBody = document.getElementById('header-body');
                    let ticksLayer = document.getElementById('ticks-layer');
                    let renderArea = document.getElementById('render-area');

                    headerBody.innerHTML = '';
                    ticksLayer.innerHTML = '<div id="crosshair-label"></div>';
                    document.getElementById('blocks-layer').innerHTML = '';
                    document.getElementById('labels-layer').innerHTML = '';
                    document.getElementById('connections-layer').innerHTML = '';

                    if (!Core.state.regions || Core.state.regions.length === 0) return;

                    let totalHeight = (APP_CONFIG.maxYear - APP_CONFIG.minYear) * Core.state.zoom + 100;
                    let colCount = Core.state.regions.length;

                    ticksLayer.style.height = totalHeight + 'px';
                    renderArea.style.height = totalHeight + 'px';

                    Core.state.regions.forEach((r, i) => {
                        let el = document.createElement('div');
                        el.className = 'header-col-label';
                        el.style.left = (i / colCount) * 100 + '%'; el.style.width = (1 / colCount) * 100 + '%'; el.innerText = r.label;
                        headerBody.appendChild(el);
                    });

                    let tickFrag = document.createDocumentFragment();
                    for (let y = APP_CONFIG.minYear; y <= APP_CONFIG.maxYear; y += 100) {
                        let top = (y - APP_CONFIG.minYear) * Core.state.zoom;
                        if (top < 0) continue;
                        let el = document.createElement('div'); el.className = 'timeline-tick-label';
                        el.style.top = top + 'px'; el.innerText = y; tickFrag.appendChild(el);
                    }
                    ticksLayer.appendChild(tickFrag);

                    Core.render.setupInteractions(renderArea, colCount);

                    let fragsByRegion = {};
                    Core.state.regimeGroups.forEach(group => {
                        let style = Core.getStyle(group);
                        let groupId = group.groupId;
                        group.fragments.forEach(f => {
                            if (!fragsByRegion[f.geoCode]) fragsByRegion[f.geoCode] = [];
                            let fragStyle = style;
                            if (f.suzerain) fragStyle = Core.getStyle(group, f);
                            fragsByRegion[f.geoCode].push(Object.assign({}, f, { style: fragStyle, groupName: group.name, groupId: groupId, group: group }));
                        });
                    });

                    let allRenderSlices = [];
                    Core.state.regions.forEach((region, colIdx) => {
                        let fragments = fragsByRegion[region.id];
                        if (fragments) {
                            let slices = Core.logic.sliceFragmentsByRegion(fragments, colIdx, Core.state.regimeGroups, Core.state.regionIndexMap, Core.state.layoutCache);
                            slices.forEach(s => { s.colIdx = colIdx; allRenderSlices.push(s); });
                        }
                    });

                    allRenderSlices.sort((a, b) => {
                        if (a.groupId !== b.groupId) return a.groupId.localeCompare(b.groupId);
                        if (Math.abs(a.displayStart - b.displayStart) > 0.1) return a.displayStart - b.displayStart;
                        return a.colIdx - b.colIdx;
                    });

                    let mergedSlices = [];
                    if (allRenderSlices.length > 0) {
                        let currentMerge = allRenderSlices[0];
                        currentMerge.colspan = 1;
                        currentMerge.startCol = currentMerge.colIdx;
                        // [Fix] ç´¯åŠ å®é™…å®½åº¦ï¼ˆä»¥"åˆ—å®½ç™¾åˆ†æ¯”å•ä½"è®¡ç®—ï¼‰
                        // ä¾‹å¦‚ï¼š100% å®½åº¦ = 1.0 ä¸ªåˆ—å®½å•ä½ï¼Œ50% å®½åº¦ = 0.5 ä¸ªåˆ—å®½å•ä½
                        currentMerge.totalWidthUnits = currentMerge.widthPct / 100;

                        for (let i = 1; i < allRenderSlices.length; i++) {
                            let next = allRenderSlices[i];
                            let prev = currentMerge;

                            // [Fix] åˆå¹¶æ¡ä»¶ï¼š
                            // 1. åŒæ”¿æƒã€ç›¸é‚»åˆ—ã€æ—¶é—´å¯¹é½
                            // 2. è¾¹ç¼˜å¯¹é½ï¼šprev å¿…é¡»å æ»¡å³è¾¹ç¼˜ï¼Œnext å¿…é¡»ä»å·¦è¾¹ç¼˜å¼€å§‹
                            // 3. [NEW] ä¸èƒ½æ˜¯ç‹¬å æ•´åˆ—çš„æƒ…å†µï¼ˆç‹¬å æ”¿æƒå¯èƒ½åªæ˜¯ç¢°å·§åŒåï¼Œä¸åº”åˆå¹¶ï¼‰
                            let basicMatch = next.groupId === prev.groupId &&
                                next.colIdx === (prev.startCol + prev.colspan) &&
                                Math.abs(next.displayStart - prev.displayStart) < 0.1 &&
                                Math.abs(next.displayEnd - prev.displayEnd) < 0.1;

                            // prev å¿…é¡»å æ®è¯¥åˆ—çš„æœ€å³ä¾§ï¼ˆç‹¬å æˆ–å³è¾¹ç¼˜å¯¹é½ï¼‰
                            let prevRightEdge = (prev.leftPct + prev.widthPct) >= 95;
                            // next å¿…é¡»ä»å·¦è¾¹ç¼˜å¼€å§‹
                            let nextLeftEdge = next.leftPct <= 5;

                            // [Fix] ç¦æ­¢åˆå¹¶ç‹¬å æ•´åˆ—çš„æƒ…å†µ
                            // å¦‚æœprevæˆ–nextç‹¬å æ•´åˆ—ï¼ˆwidthPct >= 95ï¼‰ï¼Œä¸åˆå¹¶
                            let prevIsFullWidth = prev.widthPct >= 95;
                            let nextIsFullWidth = next.widthPct >= 95;
                            let canMerge = !prevIsFullWidth && !nextIsFullWidth;

                            let isSame = basicMatch && prevRightEdge && nextLeftEdge && canMerge;
                            if (isSame) {
                                currentMerge.colspan++;
                                // [Fix] ç´¯åŠ  next çš„å®é™…å®½åº¦
                                currentMerge.totalWidthUnits += next.widthPct / 100;
                            }
                            else {
                                mergedSlices.push(currentMerge);
                                currentMerge = next;
                                currentMerge.colspan = 1;
                                currentMerge.startCol = currentMerge.colIdx;
                                currentMerge.totalWidthUnits = currentMerge.widthPct / 100;
                            }
                        }
                        mergedSlices.push(currentMerge);
                    }

                    let blocksFrag = document.createDocumentFragment();
                    mergedSlices.forEach(slice => {
                        let top = (slice.displayStart - APP_CONFIG.minYear) * Core.state.zoom;
                        let h = Math.max((slice.displayEnd - slice.displayStart) * Core.state.zoom, 1);
                        let el = document.createElement('div');

                        el.className = 'era-block-fragment ' + slice.style.className + ' ' + slice.groupId;
                        el.style.backgroundColor = slice.style.bg;
                        if (slice.style.pattern) el.style.setProperty('--pat-color', slice.style.pattern);

                        if (slice.style.className.includes('texture-V') || slice.style.className.includes('texture-VJ')) {
                            el.style.borderStyle = 'dashed'; el.style.borderColor = slice.style.border; el.style.borderWidth = '2px';
                            el.style.zIndex = parseInt(el.style.zIndex || 10) + 1;
                        } else {
                            el.style.border = '1px solid rgba(0,0,0,0.1)';
                        }

                        let isLeft = slice.startCol === 0;
                        let isRight = (slice.startCol + slice.colspan) === colCount;
                        let checkNeighbor = (c) => allRenderSlices.some(o => o.colIdx === c && o.groupId === slice.groupId && Math.max(slice.displayStart, o.displayStart) < Math.min(slice.displayEnd, o.displayEnd));
                        let hasL = checkNeighbor(slice.startCol - 1);
                        let hasR = checkNeighbor(slice.startCol + slice.colspan);

                        if (hasL || (slice.colspan > 1 && !isLeft)) el.classList.add('no-border-left');
                        if (hasR || (slice.colspan > 1 && !isRight)) el.classList.add('no-border-right');

                        let colWidthPct = 100 / colCount;
                        // [Fix] ä½¿ç”¨ç´¯åŠ çš„å®é™…å®½åº¦ï¼Œè€Œé colspan * widthPct
                        let totalWidthPct = slice.totalWidthUnits * colWidthPct;
                        let totalLeftPct = (slice.startCol * colWidthPct) + ((slice.leftPct / 100) * colWidthPct);

                        el.style.left = totalLeftPct + '%';

                        if ((hasL || hasR || slice.colspan > 1) && slice.widthPct >= 95) {
                            el.style.width = `calc(${totalWidthPct}% + 1px)`;
                            if (hasL || (!isLeft && slice.colspan > 1)) el.style.marginLeft = '-1px';
                        } else {
                            el.style.width = totalWidthPct + '%';
                        }

                        el.style.top = top + 'px'; el.style.height = h + 'px';
                        // [Fix] æ‰€æœ‰è‰²å—ä½¿ç”¨ç»Ÿä¸€çš„ z-indexï¼Œä¸ä¼šäº’ç›¸è¦†ç›–
                        el.style.zIndex = 10;
                        el.__data__ = { group: slice.group, style: slice.style, fragment: slice };

                        el.onmouseenter = () => {
                            if (!Core.state.selectedRegimeId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.add('group-hovered'));
                                if (Core.state.features.connections) Core.render.drawConnections(slice.group, '#fff');
                                // [New] Highlight Header based on this block's region
                                if (slice.geoCode) Core.ui.highlightHeader(slice.geoCode);
                            }
                        };
                        el.onmouseleave = () => {
                            if (!Core.state.selectedRegimeId) {
                                document.querySelectorAll('.' + slice.groupId).forEach(b => b.classList.remove('group-hovered'));
                                document.getElementById('connections-layer').innerHTML = '';
                                // [New] Clear Header Highlight
                                Core.ui.clearHeaderHighlight();
                            }
                        };

                        blocksFrag.appendChild(el);
                    });
                    document.getElementById('blocks-layer').appendChild(blocksFrag);

                    Core.render.drawLabels(colCount);

                    // [Fix] Redrawing destroys all DOM elements, so we MUST restore specific focus styles if active
                    // This handles cases where resize/display-change triggers redraw during a jump animation
                    if (Core.state.selectedRegimeId) {
                        // Use setTimeout to ensure DOM is fully ready
                        setTimeout(() => {
                            if (Core.ui && Core.ui.setFocus) {
                                Core.ui.setFocus(Core.state.selectedRegimeId);
                            }
                        }, 0);
                    }
                },

                setupInteractions: function (renderArea, colCount) {
                    renderArea.onclick = (e) => {
                        if (e.target.closest('#selection-modal')) return;
                        let clickedBlock = e.target.closest('.era-block-fragment');
                        if (clickedBlock && clickedBlock.__data__) {
                            e.stopPropagation();
                            let d = clickedBlock.__data__;
                            Core.state.lastClickedGeoCode = d.fragment.geoCode;

                            // [Fix] æ–¹æ¡ˆAï¼šè®¡ç®—ç‚¹å‡»ä½ç½®å¯¹åº”çš„å¹´ä»½ï¼ˆä¸åå­—çº¿ä¸€è‡´ï¼‰
                            const rect = renderArea.getBoundingClientRect();
                            const clickY = e.clientY - rect.top;
                            const clickedYear = Math.floor((clickY / Core.state.zoom) + APP_CONFIG.minYear);
                            Core.state.clickedYear = clickedYear;

                            Core.ui.setFocus(d.group.regimeId); // [Refactor] ä¼ é€’ group.regimeId
                            Core.ui.showDetails(d.group, d.style);

                            // [Sync] ç‚¹å‡»æ”¿æƒæ—¶ï¼Œå‘çˆ¶çº§ä¸ŠæŠ¥çŠ¶æ€å˜æ›´
                            // [Fix] ä½¿ç”¨ç‚¹å‡»ä½ç½®å¹´ä»½ï¼Œç¡®ä¿ä¸åå­—çº¿æ˜¾ç¤ºä¸€è‡´
                            Core.updateParentState({
                                selectedRegimeId: d.group.regimeId,
                                region: String(d.fragment.geoCode),
                                year: clickedYear
                            });

                            return;
                        }
                        if (!e.target.closest('.era-label')) Core.ui.clearFocus();
                    };
                },

                // --- é‡æ„ç‰ˆ v2.0ï¼šä½¿ç”¨ LabelSystem è¿›è¡Œæ¸²æŸ“ ---
                drawLabels: function (colCount) {
                    let labelsFrag = document.createDocumentFragment();
                    let renderArea = document.getElementById('render-area');

                    // 1. æ¸…ç†æ—§æ ‡ç­¾
                    if (renderArea) {
                        const oldItems = renderArea.querySelectorAll('.era-label, .era-dot');
                        oldItems.forEach(el => el.remove());
                    }

                    let colWidthPx = renderArea.scrollWidth / colCount;
                    if (!colWidthPx || colWidthPx < 10) colWidthPx = 100;

                    // 2. è°ƒç”¨ LabelSystem è®¡ç®—æ‰€æœ‰ä½ç½®
                    const results = LabelSystem.computeAll(
                        Core.state.regimeGroups,
                        Core.state.regionIndexMap,
                        colWidthPx,
                        Core.state.zoom
                    );

                    // 3. æ¸²æŸ“ç»“æœ
                    results.forEach(item => {
                        const { group, x, y } = item;

                        // A. æˆåŠŸæ”¾ç½®æ–‡å­—æ ‡ç­¾
                        if (!item.failed) {
                            const { layout } = item;
                            const tier = parseInt(group.explicitTier) || 3;

                            let label = document.createElement('div');
                            let layoutClass = '';

                            // [v2.0] æ ¹æ®å¸ƒå±€ç±»å‹è®¾ç½® CSS ç±»
                            if (layout.type === 'V') {
                                layoutClass = 'vertical-text';
                            } else if (layout.type === 'H2') {
                                layoutClass = 'label-h2';  // æ–°å¢ï¼šä¸¤è¡Œå¸ƒå±€
                            }

                            label.className = `era-label label-tier-${tier} ${group.groupId} ${layoutClass}`;

                            // [v2.0] H2 ç±»å‹ï¼šå°†åç§°æ‹†åˆ†ä¸ºä¸¤è¡Œ
                            if (layout.type === 'H2') {
                                const name = group.name;
                                const midPoint = Math.ceil(name.length / 2);
                                const line1 = name.substring(0, midPoint);
                                const line2 = name.substring(midPoint);
                                label.innerHTML = `<span>${line1}</span><span>${line2}</span>`;
                            } else {
                                label.innerText = group.name;
                            }

                            // å±…ä¸­å®šä½
                            // [DEBUG] æ¸²æŸ“å±‚è°ƒè¯•
                            if (['å®‰ä¸œéƒ½æŠ¤åºœ', 'åè•ƒç‹æœ'].includes(group.name)) {

                            }
                            label.style.left = x + 'px';
                            label.style.top = y + 'px';

                            // å®½åº¦å¤„ç†
                            if (layout.type === 'H2') {
                                label.style.width = layout.w + 'px';
                            } else if (layout.type === 'H') {
                                label.style.whiteSpace = 'nowrap';
                            }

                            label.style.fontSize = layout.fs + 'px';
                            label.style.lineHeight = (layout.type === 'H2') ? '1.2' : '1';

                            if (Core.state.selectedRegimeId === group.regimeId) {
                                label.classList.add('is-focused');
                            }

                            labelsFrag.appendChild(label);
                        }
                        // B. æ”¾ç½®å¤±è´¥ -> é™çº§ä¸ºå°åœ†ç‚¹
                        else {
                            let dotSize = 4;
                            // å¦‚æœæ˜¯ Tier 1/2 å¤±è´¥ï¼Œåœ†ç‚¹ç¨å¾®å¤§ä¸€ç‚¹
                            const tier = parseInt(group.explicitTier) || 3;
                            if (tier <= 2) dotSize = 6;

                            let dot = document.createElement('div');
                            dot.className = `era-dot ${group.groupId}`;
                            dot.style.cssText = `
                                position: absolute;
                                border-radius: 50%;
                                background: rgba(255,255,255,0.4);
                                cursor: help;
                                z-index: 3000;
                                transition: all 0.2s;
                                pointer-events: auto;
                            `;
                            dot.style.left = (x - dotSize / 2) + 'px';
                            dot.style.top = (y - dotSize / 2) + 'px';
                            dot.style.width = dotSize + 'px';
                            dot.style.height = dotSize + 'px';
                            dot.title = group.name; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºåå­—

                            dot.onmouseenter = () => {
                                dot.style.background = 'white';
                                dot.style.transform = 'scale(1.5)';
                                dot.style.boxShadow = '0 0 5px rgba(255,255,255,0.8)';
                            };
                            dot.onmouseleave = () => {
                                dot.style.background = 'rgba(255,255,255,0.4)';
                                dot.style.transform = 'scale(1)';
                                dot.style.boxShadow = 'none';
                            };
                            dot.onclick = (e) => {
                                e.stopPropagation();
                                Core.ui.setFocus(group.regimeId); // [Refactor] ä¼ é€’ group.regimeId
                                Core.ui.showDetails(group, Core.getStyle(group));
                            };
                            labelsFrag.appendChild(dot);
                        }
                    });

                    // 4. æŒ‚è½½ DOM
                    const labelLayer = document.getElementById('labels-layer');
                    if (labelLayer) {
                        labelLayer.innerHTML = ''; // Ensure clear
                        labelLayer.appendChild(labelsFrag);
                    } else {
                        renderArea.appendChild(labelsFrag);
                    }
                },

                drawConnections: function (group, color) {
                    let svg = document.getElementById('connections-layer');
                    svg.innerHTML = '';
                    let rect = document.getElementById('render-area').getBoundingClientRect();
                    let colW = rect.width / Core.state.regions.length;
                    let points = [];
                    group.fragments.forEach(f => {
                        let idx = Core.state.regionIndexMap[f.geoCode]; if (idx === undefined) return;
                        let top = (f.start - APP_CONFIG.minYear) * Core.state.zoom;
                        let xOffset = f.left + (f.w / 2);
                        if (isNaN(xOffset)) xOffset = 0.5;
                        points.push({ x: (idx + xOffset) * colW, y: top + (f.end - f.start) * Core.state.zoom / 2 });
                    });
                    if (points.length < 2) return;
                    points.sort((a, b) => a.x - b.x);
                    let d = "M " + points[0].x + " " + points[0].y;
                    for (let i = 1; i < points.length; i++) { let p1 = points[i - 1], p2 = points[i]; let mx = (p1.x + p2.x) / 2; d += " C " + mx + " " + p1.y + ", " + mx + " " + p2.y + ", " + p2.x + " " + p2.y; }
                    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", d); path.setAttribute("class", "connection-path"); path.setAttribute("stroke", color);
                    svg.appendChild(path);
                }
            },

            ui: {
                // [New] Highlight Header based on Region Code
                highlightHeader: function (geoCode) {
                    if (!geoCode) return;
                    const idx = Core.state.regionIndexMap[geoCode];
                    if (idx !== undefined) {
                        const headerBody = document.getElementById('header-body');
                        if (headerBody && headerBody.children[idx]) {
                            const target = headerBody.children[idx];
                            const old = headerBody.querySelector('.active-header');
                            if (old && old !== target) old.classList.remove('active-header');
                            target.classList.add('active-header');
                        }
                    }
                },
                clearHeaderHighlight: function () {
                    const headerBody = document.getElementById('header-body');
                    if (headerBody) {
                        const old = headerBody.querySelector('.active-header');
                        if (old) old.classList.remove('active-header');
                    }
                },

                closePanel: function () {
                    document.getElementById('editor-panel').classList.remove('panel-open');
                    Core.ui.clearFocus();
                },
                // [Refactor] setFocus ç°åœ¨æ¥å— group.regimeId (Name|Code æ ¼å¼)
                // å†…éƒ¨é€šè¿‡ id æŸ¥æ‰¾ groupï¼Œå†ç”¨ group.groupId (hash) æ“ä½œ DOM
                setFocus: function (regimeId) {
                    // [Refactor] setFocus åº”ä¸ºå¹‚ç­‰æ“ä½œï¼Œä»…è´Ÿè´£è®¾ç½®ç„¦ç‚¹ï¼Œä¸è´Ÿè´£åè½¬ã€‚
                    // åŸæœ‰çš„ toggle é€»è¾‘è¢«ç§»é™¤ï¼Œé˜²æ­¢ STATE_SYNC é¢„è®¾ ID åå¯¼è‡´æ­¤å¤„åˆ¤å®šä¸º"é‡å¤ç‚¹å‡»"è€Œè¯¯å…³é—­ã€‚

                    // æŸ¥æ‰¾å¯¹åº”çš„ group å¯¹è±¡
                    const group = Core.state.regimeGroups.find(g => g.regimeId === regimeId);
                    if (!group) {
                        console.warn('[setFocus] Regime not found:', regimeId);
                        return;
                    }

                    // å­˜å‚¨é€»è¾‘ ID (Name|Code)
                    Core.state.selectedRegimeId = regimeId;

                    // [Fix] ä¸ŠæŠ¥çŠ¶æ€ç»™çˆ¶é¡µé¢ï¼Œç¡®ä¿å·¦ä¸Šè§’åˆ‡æ¢æ—¶èƒ½åŒæ­¥
                    Core.updateParentState({ selectedRegimeId: regimeId });

                    // DOM æ“ä½œä½¿ç”¨ CSS å®‰å…¨çš„ groupId (hash)
                    const cssClass = group.groupId;
                    document.body.classList.add('mode-focus');
                    document.querySelectorAll('.group-hovered').forEach(el => el.classList.remove('group-hovered'));
                    document.querySelectorAll('.is-focused').forEach(el => el.classList.remove('is-focused'));
                    document.querySelectorAll('.' + cssClass).forEach(el => el.classList.add('is-focused'));

                    Core.render.drawConnections(group, '#fff');
                },
                clearFocus: function () {
                    // [Sync] åªæœ‰åœ¨ç¡®å®æœ‰é€‰ä¸­çš„æƒ…å†µä¸‹æ‰é€šçŸ¥ï¼Œé¿å…å†—ä½™
                    if (Core.state.selectedRegimeId !== null) {
                        Core.updateParentState({ selectedRegimeId: null });
                    }

                    Core.state.selectedRegimeId = null;
                    document.body.classList.remove('mode-focus');

                    // Restore original styles
                    document.querySelectorAll('.is-focused').forEach(el => {
                        el.classList.remove('is-focused');
                    });
                    document.getElementById('connections-layer').innerHTML = '';
                },
                showDetails: function (group, style) {
                    const panel = document.getElementById('editor-panel');
                    if (!panel) return;

                    panel.classList.remove('panel-right', 'panel-left');
                    const totalCols = Core.state.regions.length;
                    const centerRatio = (group.centerCol || 0) / totalCols;
                    panel.classList.add(centerRatio > 0.5 ? 'panel-left' : 'panel-right');
                    requestAnimationFrame(() => panel.classList.add('panel-open'));

                    // 1. éå†æ‰€æœ‰ç‰‡æ®µï¼Œæ”¶é›†è¯¥æ”¿æƒå†å²ä¸Šæ‰€æœ‰çš„å®—ä¸»å…³ç³»
                    const uniqueSuzerains = new Set();

                    group.fragments.forEach(f => {
                        if (!f.suzerain) {
                            uniqueSuzerains.add("æ— ");
                        }
                        else if (f.suzerainName) {
                            let txt = f.suzerainName;

                            // æƒ…å†µ A: V|J åŒé‡å…³ç³»
                            if (f.suzerainType === 'V|J' && txt.includes('|')) {
                                const parts = txt.split('|');
                                const nameV = parts[0];
                                const nameJ = parts[1] || parts[0];
                                txt = `${nameJ} (ç¾ç¸») & ${nameV} (è—©å±)`;
                            }
                            // æƒ…å†µ B: å•ä¸€å…³ç³»
                            else if (f.suzerainType) {
                                const typeMap = { 'V': 'è—©å±', 'J': 'ç¾ç¸»' };
                                const typeName = typeMap[f.suzerainType] || f.suzerainType;
                                txt = `${txt} (${typeName})`;
                            }

                            uniqueSuzerains.add(txt);
                        }
                    });

                    // 2. ç”Ÿæˆ HTML (ä¿æŒåŸé€»è¾‘ä¸å˜)
                    let suzerainHtml = '';
                    const hasOverlay = Array.from(uniqueSuzerains).some(s => s !== "æ— ");

                    if (hasOverlay) {
                        const list = Array.from(uniqueSuzerains).join(' <span style="color:var(--slate-500)">/</span> ');
                        suzerainHtml = `<div class="suzerain-tag">å®—ä¸»: ${list}</div>`;
                    }

                    const f0 = group.fragments[0];
                    const typeMap = { 'C': 'ä¸­åŸ', 'Q': 'å¾æœ', 'R': 'å‰²æ®', 'N': 'éƒ¨æ—', 'F': 'è¾¹ç–†', 'T': 'è¿‡æ¸¡', 'V': 'è—©å±' };
                    const typeLabel = typeMap[group.regimeCode.charAt(0)] || 'æœªçŸ¥';

                    let originLabel = f0.geoCode;
                    const originRegion = Core.state.rawRegions.find(r => r.id == f0.geoCode);
                    if (originRegion) originLabel = originRegion.label;

                    let detailHtml = '';
                    const fragsByGeo = {};
                    group.fragments.forEach(f => {
                        if (!fragsByGeo[f.geoCode]) fragsByGeo[f.geoCode] = [];
                        fragsByGeo[f.geoCode].push(f);
                    });

                    const sortedGeoCodes = Object.keys(fragsByGeo).sort((a, b) =>
                        (Core.state.regionIndexMap[a] || 0) - (Core.state.regionIndexMap[b] || 0)
                    );

                    const totalDur = Math.max(group.maxEnd - group.minStart, 1);

                    sortedGeoCodes.forEach(geoCode => {
                        const frags = fragsByGeo[geoCode];
                        frags.sort((a, b) => a.start - b.start);

                        let barsHtml = '';
                        let timeTexts = [];

                        // ä½¿ç”¨ç´¢å¼• i æ¥å¢åŠ  z-index
                        frags.forEach((f, i) => {
                            const left = ((f.start - group.minStart) / totalDur) * 100;
                            const width = ((f.end - f.start) / totalDur) * 100;
                            // [Fix] Use inline styles instead of Tailwind classes
                            barsHtml += `<div style="position:absolute; top:0; left:${left}%; width:${width}%; height:100%; background:${style.bg || '#888'}; opacity:0.9; border-radius:1px; min-width:3px; z-index:${10 + i};"></div>`;
                            timeTexts.push(`${f.start}~${f.end}`);
                        });

                        const regionName = Core.state.rawRegions.find(r => r.id == geoCode)?.label || geoCode;
                        const isCurrent = Core.state.lastClickedGeoCode == geoCode;

                        const rowClass = isCurrent ? 'active-row' : '';
                        const nameClass = isCurrent ? 'active-name' : '';
                        const icon = isCurrent ? 'ğŸ‘‰ ' : '';
                        const timeStr = timeTexts.join(', ');

                        detailHtml += `<div class="region-row ${rowClass}">
                            <div class="region-name ${nameClass}" title="${regionName}">${icon}${regionName}</div>
                            <div class="bar-container">${barsHtml}</div>
                            <div class="time-text" title="${timeStr}">${timeStr}</div>
                        </div>`;
                    });

                    // --- [æ–°å¢é€»è¾‘] å¤„ç†æ ‡é¢˜æ æŒ‰é’® ---
                    // [Fix] ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·ç‚¹å‡»çš„ç‰‡æ®µåŒºåŸŸï¼Œå…¶æ¬¡æ˜¯ lastClickedGeoCodeï¼Œæœ€åæ˜¯æ”¿æƒçš„ç¬¬ä¸€ä¸ªåŒºåŸŸ
                    // è¿™ç¡®ä¿äº†ä»ä»»ä½•å…¥å£ç‚¹å‡»éƒ½èƒ½è·³è½¬åˆ°æ­£ç¡®çš„åŒºåŸŸ
                    const targetGeo = Core.state.lastClickedGeoCode || (sortedGeoCodes.length > 0 ? sortedGeoCodes[0] : null);

                    // æ„å»ºè·³è½¬å‚æ•°å¯¹è±¡
                    // [Fix] æ–¹æ¡ˆAï¼šä¼˜å…ˆä½¿ç”¨ç‚¹å‡»ä½ç½®å¹´ä»½ï¼ˆä¸åå­—çº¿ä¸€è‡´ï¼‰ï¼Œfallback åˆ°è§†å£ä¸­å¿ƒå¹´ä»½
                    const yearToUse = Core.state.clickedYear || (window.getCenterYear ? window.getCenterYear() : group.minStart + 1);

                    const jumpPayload = {
                        target: 'map',
                        params: {
                            region: targetGeo,
                            // [Fix] ä½¿ç”¨ç‚¹å‡»ä½ç½®å¹´ä»½ï¼Œç¡®ä¿ä¸ç”¨æˆ·æ“ä½œæ—¶çœ‹åˆ°çš„åå­—çº¿ä¸€è‡´
                            year: yearToUse,
                            regime: group.name,
                            // [Fix] ä¼ é€’å®Œæ•´çš„ regimeIdï¼Œè®©åœ°å›¾é¡µèƒ½å¤Ÿè‡ªåŠ¨é”å®šè¯¥æ”¿æƒ
                            selectedRegimeId: group.regimeId
                        }
                    };

                    // è·å–å¹¶æ¿€æ´»æ ‡é¢˜æ æŒ‰é’®
                    const jumpBtn = document.getElementById('btn-jump-map-header');
                    if (jumpBtn) {
                        jumpBtn.classList.add('active-btn'); // æ˜¾ç¤º (CSS Controlled)
                        // ç§»é™¤æ—§ç›‘å¬å™¨ (é€šè¿‡å…‹éš†èŠ‚ç‚¹æ›¿æ¢)
                        const newBtn = jumpBtn.cloneNode(true);
                        jumpBtn.parentNode.replaceChild(newBtn, jumpBtn);

                        // ç»‘å®šæ–°äº‹ä»¶
                        newBtn.onclick = () => {
                            window.parent.postMessage({ type: "REQUEST_SWITCH", payload: jumpPayload }, window.location.origin);
                        };
                    }

                    // --- [æ›´æ–°æ¸²æŸ“] ç§»é™¤å†…å®¹åŒºçš„å¤§æŒ‰é’® ---
                    document.getElementById('editor-content').innerHTML = `
                        <div class="regime-card" style="background: ${style.bg}; color: ${style.text};">
                            <h3 class="regime-card-title">${group.name}</h3>
                            
                            <div class="regime-info-row">
                                <span class="info-badge" title="Regime Code">Code: ${group.regimeCode}</span>
                                <span class="info-badge" title="Tier Level">Tier: ${group.explicitTier}</span>
                                <span class="info-badge" title="æ”¿æƒç±»å‹">Type: ${typeLabel}</span>
                                <span class="info-badge" title="èµ·æºåŒºåŸŸ">Origin: ${originLabel}</span>
                            </div>

                            ${suzerainHtml}
                        </div>
                        
                        <div class="section-box details-gap">
                             <h4 class="section-title">ç»Ÿè¾–åŒºåŸŸ (${sortedGeoCodes.length})</h4>
                             <div class="custom-scrollbar" style="max-height:300px; overflow-y:auto; display:flex; flex-direction:column; gap:0.25rem;">${detailHtml}</div>
                        </div>
                    `;
                },
                populateSearchResults: function (term) {
                    const container = document.getElementById('search-results');
                    if (!term || term.length < 1) { container.style.display = 'none'; return; }

                    const seen = new Set();
                    const results = Core.state.regimeGroups.filter(g => {
                        if (g.name.toLowerCase().includes(term) && !seen.has(g.name)) { seen.add(g.name); return true; }
                        return false;
                    }).slice(0, 10);

                    if (results.length === 0) { container.style.display = 'none'; return; }

                    container.innerHTML = '';
                    results.forEach(g => {
                        const div = document.createElement('div');
                        div.className = 'search-item';
                        div.innerHTML = `<span>${g.name}</span> <span style="font-size:9px; color:var(--slate-500); margin-left:0.5rem">(${g.minStart})</span>`;
                        div.onclick = () => {
                            this.jumpToRegime(g);

                            // [Sync] æœç´¢é€‰ä¸­æ—¶ï¼Œå‘çˆ¶çº§ä¸ŠæŠ¥çŠ¶æ€å˜æ›´
                            Core.updateParentState({
                                selectedRegimeId: g.regimeId,
                                year: window.getCenterYear ? window.getCenterYear() : undefined
                            });

                            document.getElementById('search-input').value = '';
                            container.style.display = 'none';
                            document.querySelectorAll('.era-dimmed').forEach(el => el.classList.remove('era-dimmed'));
                        };
                        container.appendChild(div);
                    });
                    container.style.display = 'block';
                },
                jumpToRegime: function (group, targetYearOrSkip = false) {
                    const renderArea = document.getElementById('render-area');
                    const mainContent = document.getElementById('main-content');

                    const colWidth = renderArea.scrollWidth / Core.state.regions.length;
                    const targetX = (group.centerCol + 0.5) * colWidth;

                    // Determine Target Y
                    let targetY;
                    if (typeof targetYearOrSkip === 'number') {
                        // Priority 1: Specified Year (from handleJump)
                        targetY = (targetYearOrSkip - APP_CONFIG.minYear) * Core.state.zoom;
                    } else if (targetYearOrSkip === true) {
                        // Priority 2: Keep Current Y (Skip)
                        targetY = undefined;
                    } else {
                        // Priority 3: Smart Default
                        // å¦‚æœå½“å‰å¹´ä»½ (Core.state.year) åœ¨æ”¿æƒå­˜ç»­èŒƒå›´å†…ï¼Œåˆ™ç»´æŒåœ¨è¯¥å¹´ä»½
                        // å¦åˆ™ï¼ˆå¦‚ä»å…¶ä»–æ—¶ä¸ç›¸å…³çš„é¡µé¢è·³è½¬ï¼‰ï¼Œæ‰å›æ»šåˆ°æ”¿æƒèµ·å§‹å¹´ä»½
                        const currentYear = Core.state.year;
                        if (currentYear >= group.minStart && currentYear <= group.maxEnd) {
                            console.log(`[Jump] Keeping year ${currentYear} (within regime range)`);
                            targetY = (currentYear - APP_CONFIG.minYear) * Core.state.zoom;
                        } else {
                            // Default to Regime Start
                            targetY = (group.minStart - APP_CONFIG.minYear) * Core.state.zoom;
                        }
                    }

                    if (targetY === undefined) {
                        // åªåšæ°´å¹³æ»šåŠ¨ï¼Œä¸å¹²æ‰°å‚ç›´æ»šåŠ¨
                        // ç›´æ¥è®¾ç½® scrollLeft ç¡®ä¿ä¸å½±å“ scrollTop
                        const targetLeft = Math.max(0, targetX - window.innerWidth / 2);
                        mainContent.scrollLeft = targetLeft;
                    } else {
                        // åŒæ—¶æ»šåŠ¨åˆ°æ”¿æƒä½ç½®ï¼ˆæ°´å¹³+å‚ç›´ï¼‰
                        const targetTop = targetY - (window.innerHeight / 2);
                        // [Optimize] å¦‚æœè·ç¦»è¿‡è¿œ (>5000px)ï¼Œä½¿ç”¨ç¬ç§»ä»¥é˜²æ­¢å†—é•¿çš„æ»šåŠ¨åŠ¨ç”»ï¼ˆå¦‚ä»é¡¶éƒ¨åˆå§‹åŒ–æ—¶ï¼‰
                        // å¦åˆ™ä½¿ç”¨å¹³æ»‘æ»šåŠ¨æä¾›æ›´å¥½çš„ä½“éªŒ
                        const dist = Math.abs(mainContent.scrollTop - targetTop);
                        const behavior = dist > 5000 ? 'auto' : 'smooth';

                        // [Sync Protection] æ ‡è®°ä¸ºç¨‹åºåŒ–æ»šåŠ¨ï¼Œé˜²æ­¢ _setupScrollSync åœ¨æ»šåŠ¨è¿‡ç¨‹ä¸­ä¸ŠæŠ¥ä¸­é—´çŠ¶æ€
                        window._isProgrammaticScroll = true;

                        mainContent.scrollTo({
                            left: targetX - window.innerWidth / 2,
                            top: targetTop,
                            behavior: behavior
                        });

                        setTimeout(() => { window._isProgrammaticScroll = false; }, 1000);
                    }
                    // [Clean] ç§»é™¤äº† programmaticScroll ä¿æŠ¤é€»è¾‘ï¼Œå› ä¸ºä¸å†éœ€è¦é˜²æ­¢ conflict
                    setTimeout(() => {
                        Core.ui.setFocus(group.regimeId); // [Refactor] ä¼ é€’ group.regimeId
                        Core.ui.showDetails(group, Core.getStyle(group));
                    }, 500);
                }
            },

            toggleFeature: function (f) {
                this.state.features[f] = !this.state.features[f];
                document.getElementById('btn-' + f).classList.toggle('active');
                if (f === 'connections') this.render.drawAll();
            }
        };

        const collisionMgr = { rects: [], add: function (x, y, w, h, tier) { const n = { l: x + 1, t: y + 1, r: x + w - 1, b: y + h - 1 }; if (tier <= 1) { this.rects.push(n); return true; } for (let r of this.rects) if (n.l < r.r && n.r > r.l && n.t < r.b && n.b > r.t) return false; this.rects.push(n); return true; }, reset: function () { this.rects = [] } };

        document.addEventListener('DOMContentLoaded', () => Core.init());
        // [Sync] æš´éœ²ç»™çˆ¶çº§çš„åŒæ­¥ API
        window.getCenterYear = function () {
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return 2025;
            const zoom = Core.state.zoom || 1.5;
            // è®¡ç®—ä¸­å¿ƒç‚¹å¯¹åº”çš„å¹´ä»½ï¼š APP_CONFIG.minYear + (scrollTop + clientH/2) / zoom
            const midPx = el.scrollTop + (el.clientHeight / 2);
            const year = APP_CONFIG.minYear + (midPx / zoom);
            return Math.round(year);
        };

        window._pendingScrollYear = null;

        window.scrollToYear = function (year) {
            if (typeof year !== 'number' || isNaN(year)) return;
            const el = document.getElementById('main-content');
            if (!el || !Core || !Core.state) return;

            // [Fix] å¦‚æœæ•°æ®å°šæœªReadyï¼ˆé«˜åº¦å¯èƒ½ä¸å¯¹ï¼‰ï¼Œæš‚å­˜è¯·æ±‚
            if (!Core.state.dataReady || el.scrollHeight < 1000) {
                console.log(`[Panorama] Pending scroll to ${year} until ready`);
                window._pendingScrollYear = year;
                return;
            }

            const zoom = Core.state.zoom || 1.5;
            const targetPx = (year - APP_CONFIG.minYear) * zoom;
            const centerOffset = el.clientHeight / 2;
            el.scrollTo({ top: targetPx - centerOffset, behavior: 'auto' }); // auto æ›´å¿«ï¼Œsmooth å¯èƒ½æœ‰å»¶è¿Ÿ
        };
    </script>
</body>

</html>