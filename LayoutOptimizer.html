<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout Optimizer - v11.00</title>

    <!-- ğŸ”‘ å…¨å±€ç‰ˆæœ¬æ§åˆ¶ - ä¿®æ”¹æ­¤å€¼å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç¼“å­˜ -->
    <script>
        window.APP_VERSION = '2026.01.04.001';
        window.APP_CONFIG = {
            VERSION: '11.0.0',
            BUILD_DATE: '2026-01-04',
            // CDN Fallback URLs
            CDN_REACT: 'https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js',
            CDN_REACT_DOM: 'https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js',
            CDN_BABEL: 'https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js'
        };

        // ç¼“å­˜ç‰ˆæœ¬æ£€æŸ¥
        (function () {
            const storedVersion = localStorage.getItem('APP_VERSION');
            if (storedVersion && storedVersion !== window.APP_VERSION) {
                console.log('ğŸ”„ æ£€æµ‹åˆ°ç‰ˆæœ¬æ›´æ–°ï¼Œæ¸…ç†ç¼“å­˜...');
                // æ¸…ç† IndexedDB ç¼“å­˜ï¼ˆå¯é€‰ï¼Œä¿ç•™å¸ƒå±€æ•°æ®ï¼‰
                // indexedDB.deleteDatabase('EastAsiaHistoryDB');
            }
            localStorage.setItem('APP_VERSION', window.APP_VERSION);
        })();

        // ä¸º URL æ·»åŠ ç‰ˆæœ¬æŸ¥è¯¢å­—ç¬¦ä¸²ï¼ˆç”¨äºç¼“å­˜å¤±æ•ˆï¼‰
        window.APP_CONFIG.withVersion = function (url) {
            if (!url) return url;
            const separator = url.includes('?') ? '&' : '?';
            return url + separator + 'v=' + window.APP_VERSION;
        };
    </script>

    <!-- React with SRI (Subresource Integrity) -->
    <!-- React with SRI (Removed temporarily) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

    <!-- âœ… Babel å·²ç§»é™¤ - JSX å·²é¢„ç¼–è¯‘ä¸º React.createElement -->

    <!-- Tailwind CSS - å†…è”å…³é”®æ ·å¼ + CDN fallback -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style type="text/tailwindcss">
        body {
            background-color: #0f172a;
            color: #f8fafc;
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
            border: 1px solid #0f172a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }

        .matrix-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #020617;
            isolation: isolate;
        }

        .header-row {
            position: sticky;
            top: 0;
            z-index: 50;
            display: flex;
            height: 36px;
            background: #1e293b;
            border-bottom: 1px solid #475569;
        }

        .header-cell {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: #cbd5e1;
            border-right: 1px solid #334155;
            cursor: grab;
            background: #1e293b;
            padding: 0 4px;
            text-align: center;
            line-height: 1.2;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .year-col-container {
            position: sticky;
            left: 0;
            z-index: 40;
            width: 60px;
            background: #0f172a;
            border-right: 1px solid #334155;
        }

        .data-row {
            position: absolute;
            display: flex;
            width: 100%;
            border-bottom: 1px solid #1e293b;
        }

        .data-cell {
            flex-shrink: 0;
            display: flex;
            flex-direction: row;
            padding: 1px;
            gap: 1px;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .regime-block {
            flex: 1;
            height: 100%;
            border-radius: 1px;
            font-size: 10px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            overflow: hidden;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            cursor: help;
            color: #fff;
            transition: transform 0.1s;
        }

        .regime-block:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }

        .btn {
            @apply px-3 py-1.5 rounded text-xs font-bold transition-all flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-sm;
        }

        .btn-primary {
            @apply bg-blue-600 hover:bg-blue-500 text-white shadow-blue-900/20;
        }

        .btn-accent {
            @apply bg-indigo-600 hover:bg-indigo-500 text-white shadow-indigo-900/20;
        }

        .btn-success {
            @apply bg-emerald-600 hover:bg-emerald-500 text-white shadow-emerald-900/20;
        }

        .btn-purple {
            @apply bg-purple-600 hover:bg-purple-500 text-white shadow-purple-900/20;
        }

        .btn-danger {
            @apply bg-rose-600 hover:bg-rose-500 text-white shadow-rose-900/20;
        }

        .btn-dark {
            @apply bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600;
        }
    </style>
</head>

<body>
    <div id="root" class="h-screen w-screen flex flex-col"></div>

    <script>
        const { useState, useEffect, useMemo, useRef, useCallback } = React;
        const h = React.createElement; // Alias for manual React
        const Fragment = React.Fragment;

        const CONFIG = {
            MIN_YEAR: -2070,
            MAX_YEAR: 2025,
            ROW_HEIGHT: 24,
            COL_WIDTH: 100
        };



        // [New] ç§»æ¤è‡ª panorama.html çš„é«˜çº§é¢œè‰²é€»è¾‘
        const calcColor = (code) => {
            if (!code) return '#334155';
            const strCode = String(code);
            let originDigit = '1';
            let eraDigit = 4;
            if (/^\d/.test(strCode)) {
                originDigit = strCode.charAt(0);
                eraDigit = 5;
            } else {
                originDigit = strCode.length >= 3 ? strCode.charAt(2) : '1';
                eraDigit = parseInt(strCode.length >= 2 ? strCode.charAt(1) : '4') || 4;
            }
            const hueMap = { '1': 0, '5': 35, '6': 80, '2': 125, '3': 170, '7': 210, '8': 245, '4': 280, '9': 320, '0': 0 };
            const baseHue = hueMap[originDigit] !== undefined ? hueMap[originDigit] : 0;

            let hash = 0;
            for (let i = 0; i < strCode.length; i++) hash = strCode.charCodeAt(i) + ((hash << 5) - hash);
            hash = Math.abs(hash);

            const hueShift = (hash % 2 === 0) ? -6 : 6;
            let h = baseHue + hueShift;
            let l = 30 + (eraDigit * 5.0);
            l = Math.max(35, Math.min(65, l)); // ç¨å¾®æäº®ä¸€ç‚¹é€‚åº”æ·±è‰²èƒŒæ™¯
            const baseSat = 45 + (eraDigit * 5);
            const satJitter = (hash % 16) - 8;
            let s = Math.max(30, Math.min(95, baseSat + satJitter));

            if (originDigit === '0') return `hsl(0, 0%, ${l}%)`;
            if (originDigit === '6') { l -= 10; s -= 5; }

            return `hsl(${h}, ${s}%, ${l}%)`;
        };

        // [New] ç®€æ˜“ Hash å‡½æ•°
        const simpleHash = (str) => { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); };

        // --- ç®—æ³• 1: ç©¶æ TSP åˆ—æ’åº (å¸¦é˜²é€€åŒ–æœºåˆ¶) ---
        class AdvancedColumnSorter {
            constructor(ids, grid, names, onLog, bonusMatrix = null) {
                this.ids = ids; this.grid = grid; this.names = names; this.onLog = onLog;
                this.matrix = null;
                this.bonusMatrix = bonusMatrix; // [New] ç”¨äºæ³¨å…¥è§†è§’åå¥½
            }
            async precompute() {
                const n = this.ids.length;
                this.matrix = Array(n).fill(0).map(() => Array(n).fill(0));
                let ops = 0;
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        let score = 0;
                        const rA = this.ids[i], rB = this.ids[j];

                        // [New] ä¼˜å…ˆåº”ç”¨å¼ºç»‘å®š Bonus
                        if (this.bonusMatrix && this.bonusMatrix[i] && this.bonusMatrix[i][j]) {
                            score += this.bonusMatrix[i][j];
                        }

                        for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                            const setA = this.grid[rA]?.[y];
                            const setB = this.grid[rB]?.[y];
                            if (setA && setB) {
                                let common = 0;
                                setA.forEach(r => { if (setB.has(r)) common++; });
                                if (common > 0) {
                                    const nA = setA.size;
                                    const nB = setB.size;
                                    const complexityFactor = 2.0 / (nA + nB);
                                    score += (common * 10 * complexityFactor);
                                }
                            }
                        }
                        this.matrix[i][j] = this.matrix[j][i] = score;
                        ops++; if (ops % 500 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                }
            }
            getPathScore(path) {
                let score = 0;
                const n = path.length;
                for (let i = 0; i < n - 1; i++) score += this.matrix[path[i]][path[i + 1]];
                return score;
            }
            async greedyInit() {
                const n = this.ids.length;
                let bestPath = null, bestScore = -1;
                // æš´åŠ›å°è¯•ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹
                for (let startNode = 0; startNode < n; startNode++) {
                    const visited = new Set([startNode]);
                    const path = [startNode];
                    let current = startNode;
                    while (path.length < n) {
                        let bestNext = -1, maxSim = -1;
                        for (let candidate = 0; candidate < n; candidate++) {
                            if (!visited.has(candidate)) {
                                const sim = this.matrix[current][candidate];
                                if (sim > maxSim) { maxSim = sim; bestNext = candidate; }
                            }
                        }
                        if (bestNext === -1) for (let k = 0; k < n; k++) if (!visited.has(k)) { bestNext = k; break; }
                        visited.add(bestNext); path.push(bestNext); current = bestNext;
                    }
                    const s = this.getPathScore(path);
                    if (s > bestScore) { bestScore = s; bestPath = path; }
                    if (startNode % 5 === 0) await new Promise(r => setTimeout(r, 0));
                }
                return { path: bestPath, score: bestScore };
            }
            // [Manual Action Required] Replace the entire run() method with this:
            // [Optimized] å‡å°‘é»˜è®¤è¿­ä»£æ¬¡æ•°ï¼Œä½¿ç”¨åŸºäºæ—¶é—´çš„ Yield
            async run(iterations = 200000000, updateCallback, stopRef, initialPathIds = null) {
                this.onLog(`TSP: å¯åŠ¨é«˜å¼ºåº¦è®¡ç®— (Iter: ${(iterations / 1000000).toFixed(0)}M)...`);

                let init;
                if (initialPathIds && initialPathIds.length === this.ids.length) {
                    // Convert ID string array back to index array
                    const idxMap = new Map();
                    this.ids.forEach((id, idx) => idxMap.set(id, idx));

                    const idxPath = initialPathIds.map(id => idxMap.get(id));
                    if (idxPath.some(x => x === undefined)) {
                        this.onLog("âš ï¸ ç°æœ‰åˆ—é¡ºåºæ•°æ®å¼‚å¸¸ï¼Œå›é€€è‡³è´ªå¿ƒåˆå§‹åŒ–...");
                        init = await this.greedyInit(); // Fallback
                    } else {
                        const score = this.getPathScore(idxPath);
                        this.onLog(`ğŸ”„ ç»§æ‰¿ç°æœ‰åˆ—é¡ºåºä½œä¸ºèµ·ç‚¹ (Score: ${score})`);
                        init = { path: idxPath, score: score };
                    }
                } else {
                    init = await this.greedyInit(); // Start with a good greedy solution
                }

                // --- Core State ---
                let currentPath = [...init.path];
                let currentScore = init.score;
                let bestPath = [...currentPath];
                let bestScore = currentScore;

                // --- Elite Pool (Diversity Preservation) ---
                // Maintain Top 5 distinct solutions to jump between
                const elitePool = [];
                const addToElite = (path, score) => {
                    // Check similarity (Hamming distance or simple exact match)
                    const isSimilar = elitePool.some(e => Math.abs(e.score - score) < 1 && e.path.join() === path.join());
                    if (!isSimilar) {
                        elitePool.push({ path: [...path], score });
                        elitePool.sort((a, b) => b.score - a.score);
                        if (elitePool.length > 5) elitePool.pop();
                    }
                };
                addToElite(bestPath, bestScore);

                // --- Tabu Search (Short-term Memory) ---
                // Pre-allocate a small circular buffer for tabu hashes
                const tabuSize = 20;
                const tabuList = new Int32Array(tabuSize);
                let tabuPtr = 0;
                const addTabu = (path) => {
                    // Simple hash of first, middle, last elements
                    const h = path[0] ^ path[path.length >> 1] ^ path[path.length - 1];
                    tabuList[tabuPtr] = h;
                    tabuPtr = (tabuPtr + 1) % tabuSize;
                };
                const isTabu = (path) => {
                    const h = path[0] ^ path[path.length >> 1] ^ path[path.length - 1];
                    for (let i = 0; i < tabuSize; i++) if (tabuList[i] === h) return true;
                    return false;
                };

                // SA Params
                let temp = 500.0;
                const cooling = 0.999;
                let lastImprovement = 0;
                const n = this.ids.length;

                // Performance Control
                let lastYieldTime = performance.now();
                let lastUIUpdateTime = performance.now();

                for (let i = 0; i < iterations; i++) {
                    if (stopRef.current) break;

                    const moveType = Math.random();
                    let newPath = [...currentPath];
                    let delta = 0;
                    let isFullCalc = false;

                    // --- Mutation Strategies ---
                    if (moveType < 0.6) {
                        // === 2-Opt (60%) ===
                        const idx1 = Math.floor(Math.random() * n);
                        const idx2 = Math.floor(Math.random() * n);
                        const s = Math.min(idx1, idx2), e = Math.max(idx1, idx2);
                        if (s === e) continue;

                        // Delta Calculation
                        const nA = s > 0 ? currentPath[s - 1] : -1, nB = currentPath[s];
                        const nC = currentPath[e], nD = e < n - 1 ? currentPath[e + 1] : -1;
                        let oldSim = 0; if (nA !== -1) oldSim += this.matrix[nA][nB]; if (nD !== -1) oldSim += this.matrix[nC][nD];
                        let newSim = 0; if (nA !== -1) newSim += this.matrix[nA][nC]; if (nD !== -1) newSim += this.matrix[nB][nD];
                        delta = newSim - oldSim;

                        if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                            // Apply Reversal
                            let l = s, r = e;
                            while (l < r) { [newPath[l], newPath[r]] = [newPath[r], newPath[l]]; l++; r--; }
                            // 2-Opt doesn't need isFullCalc if delta is correct, but let's trust delta
                        } else {
                            continue; // Rejected
                        }
                    }
                    else if (moveType < 0.8) {
                        // === Insertion (20%) ===
                        // Good for moving a single misaligned region
                        const from = Math.floor(Math.random() * n);
                        let to = Math.floor(Math.random() * n);
                        while (to === from) to = Math.floor(Math.random() * n);

                        const [node] = newPath.splice(from, 1);
                        newPath.splice(to, 0, node);
                        isFullCalc = true;
                    }
                    else {
                        // === Double Bridge (20%) ===
                        // Strong non-reversible kick (A B C D -> A D C B)
                        // Improves topological structure
                        const pos1 = 1 + Math.floor(Math.random() * (n / 4));
                        const pos2 = pos1 + 1 + Math.floor(Math.random() * (n / 4));
                        const pos3 = pos2 + 1 + Math.floor(Math.random() * (n / 4));

                        if (pos3 < n - 1) {
                            const chunkA = newPath.slice(0, pos1);
                            const chunkB = newPath.slice(pos1, pos2);
                            const chunkC = newPath.slice(pos2, pos3);
                            const chunkD = newPath.slice(pos3);
                            newPath = [...chunkA, ...chunkD, ...chunkC, ...chunkB];
                            isFullCalc = true;
                        } else {
                            continue;
                        }
                    }

                    // --- Acceptance Logic ---
                    if (isFullCalc) {
                        const newScore = this.getPathScore(newPath);
                        delta = newScore - currentScore;
                        if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                            // Accept
                        } else {
                            continue; // Reject
                        }
                    } else {
                        // If we are here, 2-Opt was already accepted based on delta
                    }

                    // --- Update Current State ---
                    // Tabu Check: Don't go back immediately unless it's a breakthrough
                    if (!isTabu(newPath) || (currentScore + delta > bestScore)) {
                        if (isFullCalc) {
                            currentPath = newPath;
                            currentScore = this.getPathScore(newPath);
                        } else {
                            // For 2-opt, newPath was modified in place above (if we used a copy appropriately)
                            // But wait, my 2-opt above modified 'newPath' but currentPath was separate.
                            // FIX: Need to update currentPath from newPath
                            currentPath = newPath;
                            currentScore += delta;
                        }

                        addTabu(currentPath);

                        // --- Update Global Best ---
                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestPath = [...currentPath];
                            lastImprovement = i;
                            addToElite(bestPath, bestScore);

                            // Throttle UI Updates (High Priority)
                            if (updateCallback && (i - lastImprovement < 100)) updateCallback(null, bestScore);
                        }
                    }

                    // --- Annealing Schedule ---
                    if (i % 500 === 0) temp *= cooling;

                    // --- Advanced ILS Strategy (Kick & Diversity) ---
                    // If stuck for too long (e.g. 500k iters), Force Jump
                    if (temp < 0.1 || (i - lastImprovement > 300000)) {
                        // Strategy 1: Jump to a random Elite (Diversity)
                        if (elitePool.length > 0 && Math.random() < 0.5) {
                            const elite = elitePool[Math.floor(Math.random() * elitePool.length)];
                            currentPath = [...elite.path];
                            currentScore = elite.score;
                            // this.onLog(`[ILS] Jumping to Elite Score: ${currentScore}`);
                        } else {
                            // Strategy 2: Back to Best (Intensification)
                            currentPath = [...bestPath];
                            currentScore = bestScore;
                        }

                        // Apply Smart Kick: Double Bridge (Strong Perturbation)
                        // A standard 4-opt move that cannot be undone by simple 2-opt
                        const pos1 = Math.floor(n / 4);
                        const pos2 = Math.floor(n / 2);
                        const pos3 = Math.floor(3 * n / 4);
                        const chunkA = currentPath.slice(0, pos1);
                        const chunkB = currentPath.slice(pos1, pos2);
                        const chunkC = currentPath.slice(pos2, pos3);
                        const chunkD = currentPath.slice(pos3);
                        // Shuffle chunks order
                        currentPath = [...chunkA, ...chunkD, ...chunkB, ...chunkC];

                        // Recalc Score & Reset Temp
                        currentScore = this.getPathScore(currentPath);
                        temp = 200.0 + Math.random() * 100; // Randomize reheat
                        lastImprovement = i;
                    }

                    // --- UI Yielding ---
                    if (i % 4000 === 0) {
                        const now = performance.now();
                        if (now - lastYieldTime > 12) {
                            if (now - lastUIUpdateTime > 1000) {
                                this.onLog(`TSP Iter ${(i / 1000000).toFixed(2)}M: Temp ${temp.toFixed(1)} | Best ${bestScore} | Elite: ${elitePool.length}`);
                                if (updateCallback) updateCallback(null, bestScore);
                                lastUIUpdateTime = now;
                                await new Promise(r => setTimeout(r, 0));
                            } else {
                                await new Promise(r => setTimeout(r, 0));
                            }
                            lastYieldTime = performance.now();
                        }
                    }
                } // End Loop

                // --- Final Geo-Correction ---
                if (this.names) {
                    const eastKeywords = ['hokkaido', 'åŒ—æµ·é“', 'japan', 'æ—¥æœ¬', 'nihon'];
                    let eastIndexSum = 0, eastCount = 0;
                    bestPath.forEach((idx, pos) => {
                        const id = this.ids[idx];
                        const name = (this.names[id] || id).toLowerCase();
                        if (eastKeywords.some(k => name.includes(k))) { eastIndexSum += pos; eastCount++; }
                    });
                    if (eastCount > 0) {
                        const avgPos = eastIndexSum / eastCount;
                        if (avgPos < n / 2) {
                            this.onLog(`åœ°ç†ä¿®æ­£: ä¸œæ–¹æ¿å—å±…å·¦ (${avgPos.toFixed(1)} < ${n / 2}) -> ç¿»è½¬`);
                            bestPath.reverse();
                        }
                    }
                }

                return { path: bestPath.map(idx => this.ids[idx]), score: bestScore };
            }
        }

        // --- ç®—æ³• 2: å…¨å±€ä¸»åºä¼˜åŒ–å™¨ (å« Stop åŠŸèƒ½) ---
        class GlobalSequenceOptimizer {
            constructor(colOrder, grid, onLog) {
                this.cols = colOrder;
                this.grid = grid;
                this.onLog = onLog;
                this.masterSeqs = {};
                this.activeSets = {};
                // [Optimization] ç¼“å­˜ç»“æ„
                this.pairScores = {}; // ç¼“å­˜ç›¸é‚»åˆ—çš„å¾—åˆ† { "0": score, "1": score... }
                this.cutoffYears = []; // æ™ºèƒ½é‡‡æ ·ï¼šæ”¿æƒäº¤æ›¿çš„å…³é”®å¹´ä»½
                this.activeSetsByYear = {}; // å¿«é€ŸæŸ¥è¯¢ï¼š{ colId: { year: Set(regimes) } }
            }

            init(existingMasterSeqs = null) {
                // 1. åŸºç¡€æ•°æ®ç»“æ„åˆå§‹åŒ–
                let loadedCount = 0;
                this.cols.forEach(id => {
                    this.activeSets[id] = {};
                    const regimeFirstSeen = {};
                    const regimes = new Set();
                    let filledForCol = 0; // Local counter

                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.grid[id]?.[y];
                        if (set) {
                            this.activeSets[id][y] = set;
                            set.forEach(r => {
                                regimes.add(r);
                                if (!regimeFirstSeen[r]) regimeFirstSeen[r] = y;
                            });
                        }
                    }

                    // æ¢å¤æˆ–åˆå§‹åŒ–ä¸»åº
                    if (existingMasterSeqs && existingMasterSeqs[id]) {
                        loadedCount++; // [New] Count success
                        const oldSeq = existingMasterSeqs[id];
                        const newSeq = oldSeq.map(r => {
                            if (regimes.has(r)) return r;

                            // [Migration] 1. Try legacy Dash to Pipe replacement
                            let candidate = r.replace('-', '|');
                            if (regimes.has(candidate)) return candidate;

                            // [Migration] 2. Fuzzy Match: Name only -> Name|Code
                            for (const currentId of regimes) {
                                if (currentId.split('|')[0] === r) return currentId;
                                if (r.includes('|') && r.split('|')[0] === currentId) return currentId;
                            }
                            return null;
                        }).filter(r => r !== null);

                        const newSet = new Set(newSeq);
                        const newItems = Array.from(regimes).filter(r => !newSet.has(r));
                        this.masterSeqs[id] = [...newSeq, ...newItems];
                    } else {
                        // éšæœºåˆå§‹åŒ–
                        this.masterSeqs[id] = Array.from(regimes).sort(() => Math.random() - 0.5);
                    }
                });

                if (existingMasterSeqs) {
                    this.onLog(`[Init] æˆåŠŸç»§æ‰¿ ${loadedCount}/${this.cols.length} åˆ—ã€‚`);
                    if (loadedCount < this.cols.length) {
                        this.onLog(`[Init] å…¶ä½™ ${this.cols.length - loadedCount} åˆ—å·²éšæœºåˆå§‹åŒ–ã€‚`);
                    }
                }

                // [Optimization] 2. ç”Ÿæˆæ™ºèƒ½â€œåˆ‡å£å¹´ä»½â€ (Smart Sampling / Cut-off Years)
                const changeYears = new Set();
                changeYears.add(CONFIG.MIN_YEAR);

                let totalSlots = 0;
                let filledSlots = 0;

                this.cols.forEach(id => {
                    let lastSig = "";
                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.activeSets[id]?.[y];
                        const sig = set ? Array.from(set).sort().join(',') : "";
                        if (sig !== lastSig) {
                            changeYears.add(y);
                            lastSig = sig;
                        }

                        // [New] Density Stats
                        totalSlots++;
                        if (set && set.size > 0) filledSlots += set.size;
                    }
                });

                this.cutoffYears = Array.from(changeYears).sort((a, b) => a - b);

                // [New] Adaptive Weights
                const density = totalSlots > 0 ? filledSlots / totalSlots : 0.1;
                // [Normalized] å½’ä¸€åŒ–æƒé‡
                this.weights = {
                    stability: 5,
                    continuity: 0.01,
                    adjacency: 0.2,
                    gap: 0.02
                };

                // Heuristic Density Tuning
                if (density < 0.2) {
                    this.weights.gap = 0.04;
                    this.weights.adjacency = 0.3;
                    this.weights.stability = 3;
                } else if (density > 0.8) {
                    this.weights.gap = 0.01;
                    this.weights.stability = 8;
                }

                if (this.onLog) {
                    this.onLog(`SeqOpt: æ™ºèƒ½é‡‡æ ·åˆ†æå®Œæˆ (${this.cutoffYears.length} Keyframes). Density: ${density.toFixed(2)}`);
                    this.onLog(`SeqOpt Weights -> Gap: ${this.weights.gap}, Adj: ${this.weights.adjacency}, Stab: ${this.weights.stability}`);
                }
            }



            // [Enhanced] å¢å¼ºç‰ˆè´ªå¿ƒæ„é€ ï¼šé‡å¿ƒæ³• (Barycenter Heuristic)
            // åˆ©ç”¨ç‰©ç†é‡å¿ƒåŸç†ï¼Œè®©æ”¿æƒè‡ªåŠ¨è¢«å·¦å³é‚»å±…"æ‹‰"åˆ°å¯¹é½ä½ç½®
            greedyConstruct() {
                this.onLog(`[Greedy] å¼€å§‹å¢å¼ºç‰ˆè´ªå¿ƒæ„é€  (é‡å¿ƒæ³•)...`);
                const result = {};

                // === Phase 1: åŸºç¡€æ„å»º (é¦–æ¬¡å‡ºç°å¹´ä»½ç´¢å¼•) ===
                const regimeFirstYear = {};
                this.cols.forEach(colId => {
                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.activeSets[colId]?.[y];
                        if (set) set.forEach(r => regimeFirstYear[r] = (regimeFirstYear[r] === undefined ? y : Math.min(regimeFirstYear[r], y)));
                    }
                });

                // === Phase 2: åˆå§‹å¡«å…… (ç®€å•æ—¶é—´æ’åº) ===
                // å…ˆç»™ä¸€ä¸ªç²—ç³™çš„åˆå§‹è§£ï¼Œç¡®ä¿æ‰€æœ‰æ”¿æƒéƒ½åœ¨åºåˆ—ä¸­
                this.cols.forEach(colId => {
                    const regimesInCol = new Set();
                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.activeSets[colId]?.[y];
                        if (set) set.forEach(r => regimesInCol.add(r));
                    }
                    // åˆå§‹æŒ‰å¹´ä»½æ’åº
                    result[colId] = Array.from(regimesInCol).sort((a, b) => {
                        return (regimeFirstYear[a] || 0) - (regimeFirstYear[b] || 0);
                    });
                });

                // === Phase 3: é‡å¿ƒæ‰«æ (Barycenter Sweep) ===
                // æ¨¡æ‹Ÿç‰©ç†å¼•åŠ›ï¼Œåå¤æ¥å›æ‰«æï¼Œè®©æ”¿æƒå¯¹é½
                const rounds = 10;

                for (let r = 0; r < rounds; r++) {
                    // console.log(`Gravity Round ${r}`);

                    // æ­£å‘æ‰«æ (L -> R) & åå‘æ‰«æ (R -> L)
                    // å®é™…ä¸Šé‡å¿ƒæ³•ä¸€èˆ¬åªéœ€è¦åœ¨è®¡ç®—æ—¶åŒæ—¶çœ‹å·¦å³å³å¯ï¼Œè¿™é‡Œç®€åŒ–ä¸ºé€åˆ—æ›´æ–°
                    const colIndices = r % 2 === 0
                        ? Array.from({ length: this.cols.length }, (_, i) => i) // 0, 1, 2...
                        : Array.from({ length: this.cols.length }, (_, i) => i).reverse(); // n, n-1...

                    let moved = false;

                    for (const c of colIndices) {
                        const colId = this.cols[c];
                        const seq = result[colId];
                        const len = seq.length;
                        if (len < 2) continue;

                        // è®¡ç®—è¯¥åˆ—æ¯ä¸ªæ”¿æƒçš„"é‡å¿ƒåˆ†æ•°"
                        const scores = seq.map(regime => {
                            let totalPos = 0;
                            let limit = 0;

                            // 1. å·¦å¼•åŠ›
                            if (c > 0) {
                                const leftId = this.cols[c - 1];
                                const leftSeq = result[leftId];
                                const leftIdx = leftSeq.indexOf(regime); // å®é™…ä¸Šéœ€è¦æ¨¡ç³ŠåŒ¹é…ï¼Œä¸ºæ€§èƒ½æš‚ç”¨ç²¾ç¡®
                                if (leftIdx !== -1) {
                                    // å½’ä¸€åŒ–ä½ç½® (0~1)
                                    totalPos += (leftIdx / leftSeq.length) * 5.0; // æƒé‡5
                                    limit += 5.0;
                                }
                            }

                            // 2. å³å¼•åŠ›
                            if (c < this.cols.length - 1) {
                                const rightId = this.cols[c + 1];
                                const rightSeq = result[rightId];
                                const rightIdx = rightSeq.indexOf(regime);
                                if (rightIdx !== -1) {
                                    totalPos += (rightIdx / rightSeq.length) * 5.0;
                                    limit += 5.0;
                                }
                            }

                            // 3. æ—¶é—´å¼•åŠ› (ä¿æŒå†å²å¤§è‡´æœ‰åº)
                            // å½’ä¸€åŒ–å¹´ä»½ (-2070 ~ 2025) -> (0 ~ 1)
                            const year = regimeFirstYear[regime] || CONFIG.MIN_YEAR;
                            const yearNorm = (year - CONFIG.MIN_YEAR) / (CONFIG.MAX_YEAR - CONFIG.MIN_YEAR);
                            totalPos += yearNorm * 1.0; // æƒé‡1 (å¼±çº¦æŸï¼Œä»…ç”¨äºæ‰“ç ´å¹³å±€)
                            limit += 1.0;

                            return { regime, s: totalPos / limit };
                        });

                        // æ ¹æ®é‡å¿ƒåˆ†æ•°æ’åº
                        scores.sort((a, b) => a.s - b.s);

                        // æ›´æ–°åºåˆ—
                        const newSeq = scores.map(x => x.regime);

                        // ç®€å•æ£€æµ‹æ˜¯å¦å˜åŒ–
                        if (JSON.stringify(newSeq) !== JSON.stringify(seq)) {
                            result[colId] = newSeq;
                            moved = true;
                        }
                    }

                    if (!moved) break; // æå‰æ”¶æ•›
                }

                this.onLog(`[Greedy] é‡å¿ƒæ³•æ„é€ å®Œæˆ (${rounds} Rounds)ã€‚`);
                return result;
            }

            // [NEW] æ½œåŠ›å¯¼å‘çš„é’ˆå¯¹æ€§ä¿®å¤
            // è¯†åˆ«å¯ä»¥å¯¹é½ä½†æœªå¯¹é½çš„å…±äº«æ”¿æƒï¼Œç³»ç»Ÿæ€§åœ°å°è¯•ä¿®å¤
            targetedRepair(seqs, maxRounds = 50) {
                this.onLog(`[TargetedRepair] å¼€å§‹æ½œåŠ›æ‰«æ...`);
                let currentSeqs = JSON.parse(JSON.stringify(seqs));
                let currentScore = this.calculateGlobalScore(currentSeqs);
                let improvements = 0;

                for (let round = 0; round < maxRounds; round++) {
                    // === Step 1: è®¡ç®—æ‰€æœ‰"æœªå…‘ç°æ½œåŠ›" ===
                    const potentials = [];

                    for (let c = 0; c < this.cols.length - 1; c++) {
                        const idA = this.cols[c];
                        const idB = this.cols[c + 1];
                        const seqA = currentSeqs[idA];
                        const seqB = currentSeqs[idB];

                        if (!seqA || !seqB) continue;

                        // æ„å»ºä½ç½®æ˜ å°„
                        const mapA = new Map();
                        seqA.forEach((r, idx) => mapA.set(r, idx));
                        const mapB = new Map();
                        seqB.forEach((r, idx) => mapB.set(r, idx));

                        // éå†æ‰€æœ‰å…³é”®å¹´ä»½
                        for (const y of this.cutoffYears) {
                            const setA = this.activeSets[idA]?.[y];
                            const setB = this.activeSets[idB]?.[y];
                            if (!setA || !setB) continue;

                            // æ‰¾å…±äº«æ”¿æƒ
                            setA.forEach(r => {
                                if (setB.has(r) && mapA.has(r) && mapB.has(r)) {
                                    const idxA = mapA.get(r);
                                    const idxB = mapB.get(r);

                                    // è®¡ç®—å½“å‰Yå¹´çš„æ´»è·ƒæ”¿æƒåˆ—è¡¨
                                    const activeA = seqA.filter(x => setA.has(x));
                                    const activeB = seqB.filter(x => setB.has(x));

                                    const posA = activeA.indexOf(r);
                                    const posB = activeB.indexOf(r);

                                    if (posA === -1 || posB === -1) return;

                                    const distA = activeA.length - 1 - posA; // ç¦»å³è¾¹ç¼˜çš„è·ç¦»
                                    const distB = posB; // ç¦»å·¦è¾¹ç¼˜çš„è·ç¦»
                                    const gap = distA + distB;

                                    if (gap > 0) {
                                        // è®¡ç®—æ½œåŠ› = gap * duration
                                        const nextY = this.cutoffYears[this.cutoffYears.indexOf(y) + 1] || CONFIG.MAX_YEAR;
                                        const duration = nextY - y;

                                        potentials.push({
                                            regime: r,
                                            colIdxA: c,
                                            colIdxB: c + 1,
                                            idA, idB,
                                            idxA, idxB,
                                            gap,
                                            potential: gap * duration,
                                            year: y,
                                            // é˜»æŒ¡è€…ï¼šåœ¨Aåˆ—ä¸­é˜»æ­¢råˆ°è¾¾å³è¾¹ç¼˜çš„æ”¿æƒ
                                            blockersA: activeA.slice(posA + 1),
                                            // é˜»æŒ¡è€…ï¼šåœ¨Båˆ—ä¸­é˜»æ­¢råˆ°è¾¾å·¦è¾¹ç¼˜çš„æ”¿æƒ
                                            blockersB: activeB.slice(0, posB)
                                        });
                                    }
                                }
                            });
                        }
                    }

                    if (potentials.length === 0) {
                        this.onLog(`[TargetedRepair] ç¬¬ ${round + 1} è½®: æ— æœªå…‘ç°æ½œåŠ›ã€‚`);
                        break;
                    }

                    // === Step 2: æŒ‰æ½œåŠ›ä»å¤§åˆ°å°æ’åº ===
                    potentials.sort((a, b) => b.potential - a.potential);

                    // === Step 3: å°è¯•å…‘ç°æœ€å¤§æ½œåŠ› ===
                    let improved = false;

                    for (let i = 0; i < Math.min(10, potentials.length); i++) {
                        const p = potentials[i];

                        // å°è¯•ç­–ç•¥1: åœ¨Aåˆ—ä¸­ï¼ŒæŠŠé˜»æŒ¡è€…ç§»åˆ°rå‰é¢
                        if (p.blockersA.length > 0) {
                            const seqA = currentSeqs[p.idA];
                            const rIdx = seqA.indexOf(p.regime);

                            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªé˜»æŒ¡è€…
                            for (const blocker of p.blockersA) {
                                const blockerIdx = seqA.indexOf(blocker);
                                if (blockerIdx > rIdx) {
                                    // å°è¯•æŠŠ blocker ç§»åˆ° r å‰é¢
                                    const newSeqA = [...seqA];
                                    newSeqA.splice(blockerIdx, 1); // ç§»é™¤ blocker
                                    const newRIdx = newSeqA.indexOf(p.regime);
                                    newSeqA.splice(newRIdx, 0, blocker); // æ’å…¥åˆ° r å‰é¢

                                    // è¯„ä¼°åˆ†æ•°å˜åŒ–
                                    const oldScore = this.calculateColumnStability(p.idA, seqA) +
                                        (p.colIdxA > 0 ? this.calculatePairScore(this.cols[p.colIdxA - 1], p.idA, currentSeqs[this.cols[p.colIdxA - 1]], seqA) : 0) +
                                        this.calculatePairScore(p.idA, p.idB, seqA, currentSeqs[p.idB]);

                                    const newScore = this.calculateColumnStability(p.idA, newSeqA) +
                                        (p.colIdxA > 0 ? this.calculatePairScore(this.cols[p.colIdxA - 1], p.idA, currentSeqs[this.cols[p.colIdxA - 1]], newSeqA) : 0) +
                                        this.calculatePairScore(p.idA, p.idB, newSeqA, currentSeqs[p.idB]);

                                    if (newScore > oldScore) {
                                        currentSeqs[p.idA] = newSeqA;
                                        improvements++;
                                        improved = true;
                                        break;
                                    }
                                }
                            }
                        }

                        // å°è¯•ç­–ç•¥2: åœ¨Båˆ—ä¸­ï¼ŒæŠŠé˜»æŒ¡è€…ç§»åˆ°råé¢
                        if (!improved && p.blockersB.length > 0) {
                            const seqB = currentSeqs[p.idB];
                            const rIdx = seqB.indexOf(p.regime);

                            for (const blocker of p.blockersB) {
                                const blockerIdx = seqB.indexOf(blocker);
                                if (blockerIdx < rIdx) {
                                    // å°è¯•æŠŠ blocker ç§»åˆ° r åé¢
                                    const newSeqB = [...seqB];
                                    newSeqB.splice(blockerIdx, 1);
                                    const newRIdx = newSeqB.indexOf(p.regime);
                                    newSeqB.splice(newRIdx + 1, 0, blocker);

                                    const oldScore = this.calculateColumnStability(p.idB, seqB) +
                                        this.calculatePairScore(p.idA, p.idB, currentSeqs[p.idA], seqB) +
                                        (p.colIdxB < this.cols.length - 1 ? this.calculatePairScore(p.idB, this.cols[p.colIdxB + 1], seqB, currentSeqs[this.cols[p.colIdxB + 1]]) : 0);

                                    const newScore = this.calculateColumnStability(p.idB, newSeqB) +
                                        this.calculatePairScore(p.idA, p.idB, currentSeqs[p.idA], newSeqB) +
                                        (p.colIdxB < this.cols.length - 1 ? this.calculatePairScore(p.idB, this.cols[p.colIdxB + 1], newSeqB, currentSeqs[this.cols[p.colIdxB + 1]]) : 0);

                                    if (newScore > oldScore) {
                                        currentSeqs[p.idB] = newSeqB;
                                        improvements++;
                                        improved = true;
                                        break;
                                    }
                                }
                            }
                        }

                        if (improved) break;
                    }

                    if (!improved) {
                        this.onLog(`[TargetedRepair] ç¬¬ ${round + 1} è½®: æ— æ³•å…‘ç°å‰©ä½™æ½œåŠ›ã€‚`);
                        break;
                    }
                }

                const finalScore = this.calculateGlobalScore(currentSeqs);
                this.onLog(`[TargetedRepair] å®Œæˆã€‚å…± ${improvements} æ¬¡æ”¹è¿›ã€‚åˆ†æ•°: ${Math.floor(finalScore)}`);
                return { seqs: currentSeqs, score: finalScore };
            }

            // [NEW] å±€éƒ¨ä¼˜åŒ–ï¼šåªæ¥å—æ›´ä¼˜è§£çš„ Hill Climbing
            localRefine(seqs, maxSeconds = 5) {
                this.onLog(`[Refine] å¼€å§‹å±€éƒ¨ä¼˜åŒ– (${maxSeconds}ç§’)...`);
                const startTime = performance.now();
                let currentSeqs = JSON.parse(JSON.stringify(seqs));
                let currentScore = this.calculateGlobalScore(currentSeqs);
                let bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                let bestScore = currentScore;
                let improvements = 0;

                // è¿­ä»£ä¼˜åŒ–æ¯ä¸€åˆ—
                let round = 0;
                while (performance.now() - startTime < maxSeconds * 1000) {
                    round++;
                    let anyImproved = false;

                    for (let c = 0; c < this.cols.length; c++) {
                        if (performance.now() - startTime > maxSeconds * 1000) break;

                        const colId = this.cols[c];
                        const seq = currentSeqs[colId];
                        if (!seq || seq.length < 2) continue;

                        // å°è¯•æ‰€æœ‰ç›¸é‚»äº¤æ¢
                        for (let i = 0; i < seq.length - 1; i++) {
                            // Swap i and i+1
                            [seq[i], seq[i + 1]] = [seq[i + 1], seq[i]];

                            // å¿«é€Ÿè¯„ä¼°å±€éƒ¨å˜åŒ–
                            let newLocalScore = this.calculateColumnStability(colId, seq);
                            if (c > 0) {
                                newLocalScore += this.calculatePairScore(
                                    this.cols[c - 1], colId,
                                    currentSeqs[this.cols[c - 1]], seq
                                );
                            }
                            if (c < this.cols.length - 1) {
                                newLocalScore += this.calculatePairScore(
                                    colId, this.cols[c + 1],
                                    seq, currentSeqs[this.cols[c + 1]]
                                );
                            }

                            // è®¡ç®—æ—§çš„å±€éƒ¨åˆ†æ•°
                            const oldSeq = [...seq];
                            [oldSeq[i], oldSeq[i + 1]] = [oldSeq[i + 1], oldSeq[i]]; // Revert
                            let oldLocalScore = this.calculateColumnStability(colId, oldSeq);
                            if (c > 0) {
                                oldLocalScore += this.calculatePairScore(
                                    this.cols[c - 1], colId,
                                    currentSeqs[this.cols[c - 1]], oldSeq
                                );
                            }
                            if (c < this.cols.length - 1) {
                                oldLocalScore += this.calculatePairScore(
                                    colId, this.cols[c + 1],
                                    oldSeq, currentSeqs[this.cols[c + 1]]
                                );
                            }

                            if (newLocalScore > oldLocalScore) {
                                // ä¿æŒäº¤æ¢ï¼ˆå·²ç»äº¤æ¢äº†ï¼‰
                                improvements++;
                                anyImproved = true;
                                // æ›´æ–°ç¼“å­˜
                                this.stabilityScores[colId] = this.calculateColumnStability(colId, seq);
                                if (c > 0) this.pairScores[c - 1] = this.calculatePairScore(this.cols[c - 1], colId, currentSeqs[this.cols[c - 1]], seq);
                                if (c < this.cols.length - 1) this.pairScores[c] = this.calculatePairScore(colId, this.cols[c + 1], seq, currentSeqs[this.cols[c + 1]]);
                            } else {
                                // æ¢å¤äº¤æ¢
                                [seq[i], seq[i + 1]] = [seq[i + 1], seq[i]];
                            }
                        }
                    }

                    // æ›´æ–°å…¨å±€æœ€ä¼˜
                    const fullScore = this.calculateGlobalScore(currentSeqs);
                    if (fullScore > bestScore) {
                        bestScore = fullScore;
                        bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                    }

                    // å¦‚æœæ²¡æœ‰æ”¹è¿›ï¼Œæå‰é€€å‡º
                    if (!anyImproved) {
                        this.onLog(`[Refine] ç¬¬ ${round} è½®æ— æ”¹è¿›ï¼Œæå‰ç»“æŸã€‚`);
                        break;
                    }
                }

                const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                this.onLog(`[Refine] å®Œæˆã€‚å…± ${round} è½®ï¼Œ${improvements} æ¬¡æ”¹è¿›ã€‚è€—æ—¶ ${elapsed}sã€‚Score: ${Math.floor(bestScore)}`);
                return { seqs: bestSeqs, score: bestScore };
            }

            // [Core Optimization] è®¡ç®—ä¸¤åˆ—ä¹‹é—´çš„ LAY åˆ†æ•° (Adaptive)
            calculateColumnStability(id, seq) {
                let penalty = 0;
                const cutoffs = this.cutoffYears;
                const count = cutoffs.length;
                const sets = this.activeSets[id];
                const weight = this.weights.stability;

                let prevList = [];
                let currList = [];

                // Init prevList
                const y0 = cutoffs[0];
                const set0 = sets[y0];
                if (set0) {
                    const len = seq.length;
                    for (let k = 0; k < len; k++) {
                        if (set0.has(seq[k])) prevList.push(seq[k]);
                    }
                }

                for (let i = 1; i < count; i++) {
                    const y = cutoffs[i];
                    const currSet = sets[y];
                    if (!currSet) continue;

                    // Build currList based on Seq Order
                    const len = seq.length;
                    for (let k = 0; k < len; k++) {
                        if (currSet.has(seq[k])) currList.push(seq[k]);
                    }

                    // Compare
                    const prevLen = prevList.length;
                    const currLen = currList.length;

                    if (prevLen === 0 && currLen === 0) continue;

                    // Calculate Shift Penalty
                    for (let c = 0; c < currLen; c++) {
                        const item = currList[c];
                        const pIndex = prevList.indexOf(item);
                        if (pIndex !== -1) {
                            const shift = Math.abs(c - pIndex);
                            if (shift > 0) penalty += shift * weight;
                        }
                    }

                    // Swap buffers
                    const temp = prevList;
                    prevList = currList;
                    currList = temp;
                    currList.length = 0;
                }

                return -penalty;
            }

            calculatePairScore(idA, idB, seqA, seqB) {
                let score = 0;
                const cutoffs = this.cutoffYears;
                const count = cutoffs.length;

                // Weights
                const wCont = this.weights.continuity;
                const wGap = this.weights.gap;
                const wAdj = this.weights.adjacency;

                // é¢„è®¡ç®—ä½ç½®ç´¢å¼•
                const mapA = new Map();
                const lenA = seqA.length;
                for (let k = 0; k < lenA; k++) mapA.set(seqA[k], k);

                const mapB = new Map();
                const lenB = seqB.length;
                for (let k = 0; k < lenB; k++) mapB.set(seqB[k], k);

                // Helper to safely get index with fuzzy matching
                const getIdx = (map, key) => {
                    if (map.has(key)) return map.get(key);
                    if (typeof key === 'string' && key.includes('|')) {
                        const short = key.split('|')[0];
                        for (const [k, v] of map.entries()) {
                            if (k.startsWith(short + '|')) return v;
                        }
                    }
                    return undefined;
                };

                for (let i = 0; i < count; i++) {
                    const y = cutoffs[i];
                    const nextY = (i < count - 1) ? cutoffs[i + 1] : CONFIG.MAX_YEAR;
                    const duration = nextY - y;

                    const setA = this.activeSets[idA][y];
                    const setB = this.activeSets[idB][y];

                    if (!setA || !setB) continue;

                    const shared = [];
                    setA.forEach(rA => {
                        if (setB.has(rA)) {
                            shared.push(rA);
                        } else {
                            // Fuzzy Match Loop
                            const idxA = rA.indexOf('|');
                            const shortA = idxA === -1 ? rA : rA.substring(0, idxA);
                            for (const rB of setB) {
                                const idxB = rB.indexOf('|');
                                const shortB = idxB === -1 ? rB : rB.substring(0, idxB);
                                if (shortB === shortA) {
                                    shared.push(rA);
                                    break;
                                }
                            }
                        }
                    });

                    if (shared.length === 0) continue;

                    // 1. åŸºç¡€å¥–åŠ± (Continuity)
                    score += shared.length * duration * wCont;

                    let totalGap = 0;
                    let adjacencies = 0;

                    shared.forEach(r => {
                        const idxA = getIdx(mapA, r);
                        const idxB = getIdx(mapB, r);

                        if (idxA !== undefined && idxB !== undefined) {
                            const distA = lenA - 1 - idxA;
                            const distB = idxB;
                            const gap = distA + distB;

                            totalGap += gap;

                            // Adjacency Bonus: å®Œç¾è´´åˆ
                            if (gap === 0) adjacencies++;
                        }
                    });

                    // Penalty for Gap
                    score -= totalGap * duration * wGap;

                    // Bonus for Perfect Adjacency
                    score += adjacencies * duration * wAdj;
                }
                return score;
            }












            // åˆå§‹åŒ–æˆ–å…¨é‡è®¡ç®—å…¨å±€åˆ†æ•°
            calculateGlobalScore(currentSeqs) {
                let totalScore = 0;
                this.pairScores = {}; // é‡ç½®ç¼“å­˜
                this.stabilityScores = {}; // ç¼“å­˜åˆ—ç¨³å®šæ€§åˆ†æ•°

                // 1. Column Stability Scores (Unary)
                // ç¡®ä¿æ¯ä¸€åˆ—å†…éƒ¨çš„æ¼”å˜æ˜¯å¹³æ»‘çš„
                for (let c = 0; c < this.cols.length; c++) {
                    const id = this.cols[c];
                    const s = this.calculateColumnStability(id, currentSeqs[id]);
                    this.stabilityScores[id] = s;
                    totalScore += s;
                }

                // 2. Pair Scores (Binary)
                // ç¡®ä¿åˆ—ä¸åˆ—ä¹‹é—´çš„è¿æ¥æ˜¯ç´§å¯†çš„
                for (let c = 0; c < this.cols.length - 1; c++) {
                    const idA = this.cols[c];
                    const idB = this.cols[c + 1];
                    const s = this.calculatePairScore(idA, idB, currentSeqs[idA], currentSeqs[idB]);

                    this.pairScores[c] = s; // ç¼“å­˜ index-pair åˆ†æ•°
                    totalScore += s;
                }
                return totalScore;
            }

            // [Optimization] å¢é‡è®¡ç®—åˆ†æ•°å˜åŒ–
            // åªè®¡ç®—æŸä¸€åˆ—å‘ç”Ÿäº¤æ¢åï¼Œä¸å…¶å·¦å³é‚»å±…çš„åˆ†æ•°å˜åŒ–
            calculateScoreDeltaWithSwap(currentSeqs, colIdx, idx1, idx2) {
                const colId = this.cols[colIdx];
                const seq = currentSeqs[colId];

                // 1. ç¡®å®šå—å½±å“çš„é‚»å±…å¯¹
                // Pair(c) ä»£è¡¨ cols[c] å’Œ cols[c+1] ä¹‹é—´çš„åˆ†æ•°
                const leftPairIdx = colIdx - 1;
                const rightPairIdx = colIdx;

                // 2. è·å–æ—§åˆ†æ•°
                let oldScorePart = 0;
                if (leftPairIdx >= 0) oldScorePart += this.pairScores[leftPairIdx];
                if (rightPairIdx < this.cols.length - 1) oldScorePart += this.pairScores[rightPairIdx];

                // Add old stability score
                const oldStability = this.stabilityScores[colId] || 0;
                oldScorePart += oldStability;

                // 3. æ¨¡æ‹Ÿäº¤æ¢
                const temp = seq[idx1];
                seq[idx1] = seq[idx2];
                seq[idx2] = temp;

                // 4. è®¡ç®—æ–°åˆ†æ•°
                let newLeftScore = 0;
                let newRightScore = 0;

                if (leftPairIdx >= 0) {
                    const idLeft = this.cols[leftPairIdx];
                    if (currentSeqs[idLeft]) {
                        newLeftScore = this.calculatePairScore(idLeft, colId, currentSeqs[idLeft], seq);
                    }
                }
                if (rightPairIdx < this.cols.length - 1) {
                    const idRight = this.cols[rightPairIdx + 1];
                    if (currentSeqs[idRight]) {
                        newRightScore = this.calculatePairScore(colId, idRight, seq, currentSeqs[idRight]);
                    }
                }

                // New Stability Score
                const newStability = this.calculateColumnStability(colId, seq);

                // 5. æ¢å¤äº¤æ¢ (ç”±è°ƒç”¨è€…å†³å®šæ˜¯å¦åœ¨å¤§å¾ªç¯ä¸­æ­£å¼åº”ç”¨)
                seq[idx2] = seq[idx1];
                seq[idx1] = temp;

                // è¿”å› Delta å’Œæ–°çš„å±€éƒ¨ç¼“å­˜ï¼Œä»¥ä¾¿æ¥å—æ—¶æ›´æ–°
                return {
                    delta: (newLeftScore + newRightScore + newStability) - oldScorePart,
                    newLeftScore,
                    newRightScore,
                    newStability, // Return this
                    leftPairIdx,
                    rightPairIdx
                };
            }


            async run(iterations = 500000, updateCallback, stopRef, existingMasterSeqs = null) {
                this.init(existingMasterSeqs);
                this.onLog("=== SeqOpt v2.2: æ½œåŠ›å¯¼å‘ä¼˜åŒ– ===");

                // === Strategy 1: ä½¿ç”¨ç»§æ‰¿çš„å¸ƒå±€ï¼ˆå¦‚æœå­˜åœ¨ä¸”æœ‰æ•ˆï¼‰ ===
                let inheritedSeqs = null;
                let inheritedScore = -Infinity;

                // [Debug] æ£€æŸ¥ä¼ å…¥çš„ existingMasterSeqs
                this.onLog(`[Debug] existingMasterSeqs: ${existingMasterSeqs ? Object.keys(existingMasterSeqs).length + 'åˆ—' : 'NULL'}`);

                if (existingMasterSeqs && Object.keys(existingMasterSeqs).length > 0) {
                    inheritedSeqs = JSON.parse(JSON.stringify(this.masterSeqs));
                    inheritedScore = this.calculateGlobalScore(inheritedSeqs);
                    this.onLog(`[Inherited] ç»§æ‰¿å¸ƒå±€åˆ†æ•°: ${Math.floor(inheritedScore)}`);
                } else {
                    this.onLog(`[Warning] æ— ç»§æ‰¿å¸ƒå±€ï¼Œå°†ä»å¤´æ„é€ ã€‚`);
                }

                // === Strategy 2: è´ªå¿ƒæ„é€ æ–°å¸ƒå±€ + å¿«é€Ÿä¼˜åŒ– ===
                this.onLog(`[Greedy] å¼€å§‹è´ªå¿ƒæ„é€ ...`);
                let greedySeqs = this.greedyConstruct();
                let greedyScore = this.calculateGlobalScore(greedySeqs);
                this.onLog(`[Greedy] åˆå§‹æ„é€ åˆ†æ•°: ${Math.floor(greedyScore)}`);

                // å¯¹è´ªå¿ƒç»“æœè¿›è¡Œå¿«é€Ÿé’ˆå¯¹æ€§ä¿®å¤ï¼ˆç»™è´ªå¿ƒä¸€ä¸ªå…¬å¹³çš„æœºä¼šï¼‰
                const greedyRepair = this.targetedRepair(greedySeqs, 30);
                if (greedyRepair.score > greedyScore) {
                    greedySeqs = greedyRepair.seqs;
                    greedyScore = greedyRepair.score;
                    this.onLog(`[Greedy] ä¿®å¤ååˆ†æ•°: ${Math.floor(greedyScore)}`);
                }

                // === é€‰æ‹©æ›´ä¼˜çš„èµ·ç‚¹ (ç¡®ä¿ä½¿ç”¨æ›´é«˜åˆ†çš„) ===
                let currentSeqs;
                let currentScore;

                // è°ƒè¯•æ—¥å¿—ï¼šæ˜ç¡®æ˜¾ç¤ºæ¯”è¾ƒç»“æœ
                this.onLog(`[Compare] ç»§æ‰¿: ${Math.floor(inheritedScore)}, è´ªå¿ƒ: ${Math.floor(greedyScore)}`);

                if (inheritedSeqs && inheritedScore >= greedyScore) {
                    // ä¼˜å…ˆä½¿ç”¨ç»§æ‰¿å¸ƒå±€ï¼ˆåˆ†æ•°ç›¸åŒæˆ–æ›´é«˜æ—¶ï¼‰
                    this.onLog(`[Decision] âœ… ä»¥ç»§æ‰¿å¸ƒå±€ä¸ºèµ·ç‚¹`);
                    currentSeqs = inheritedSeqs;
                    currentScore = inheritedScore;
                } else {
                    this.onLog(`[Decision] ä»¥è´ªå¿ƒå¸ƒå±€ä¸ºèµ·ç‚¹`);
                    currentSeqs = greedySeqs;
                    currentScore = greedyScore;
                }

                // æ˜¾ç¤ºåˆå§‹å¸ƒå±€
                if (updateCallback) {
                    updateCallback(this.generateLayout(currentSeqs), currentScore);
                }
                await new Promise(r => setTimeout(r, 100));

                // === Phase 3: æ½œåŠ›å¯¼å‘çš„é’ˆå¯¹æ€§ä¿®å¤ ===
                const repairResult = this.targetedRepair(currentSeqs, 50);
                if (repairResult.score > currentScore) {
                    currentSeqs = repairResult.seqs;
                    currentScore = repairResult.score;
                    this.onLog(`[Improved] é’ˆå¯¹æ€§ä¿®å¤ååˆ†æ•°: ${Math.floor(currentScore)}`);
                    if (updateCallback) {
                        updateCallback(this.generateLayout(currentSeqs), currentScore);
                    }
                }
                await new Promise(r => setTimeout(r, 100));

                // === Phase 4: æ·±åº¦ä¼˜åŒ– (SA + ç­–ç•¥ä¿®å¤) ===
                this.onLog(`[Optimize] å¼€å§‹æ·±åº¦ä¼˜åŒ–ï¼Œèµ·ç‚¹åˆ†æ•°: ${Math.floor(currentScore)}`);

                let bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                let bestScore = currentScore;
                let lastImprovement = 0;
                let temp = 2000.0;
                let lastYield = performance.now();
                let lastUIUpdate = performance.now();

                // è¾…åŠ©å‡½æ•°ï¼šé’ˆå¯¹æŸä¸€åˆ—è¿›è¡Œæè‡´ä¼˜åŒ– (Defined here to be accessible throughout the loop)
                const optimizeColumn = (cIdx) => {
                    if (cIdx < 0 || cIdx >= this.cols.length) return;
                    const colId = this.cols[cIdx];
                    const originalSeq = currentSeqs[colId];
                    if (!originalSeq || originalSeq.length < 2) return;

                    const getContextScore = (s) => {
                        let sc = 0;
                        if (cIdx > 0) sc += this.calculatePairScore(this.cols[cIdx - 1], colId, currentSeqs[this.cols[cIdx - 1]], s);
                        if (cIdx < this.cols.length - 1) sc += this.calculatePairScore(colId, this.cols[cIdx + 1], s, currentSeqs[this.cols[cIdx + 1]]);
                        sc += this.calculateColumnStability(colId, s);
                        return sc;
                    };

                    let bestLocalSeq = [...originalSeq];
                    let bestLocalScore = getContextScore(originalSeq);

                    if (originalSeq.length <= 6) {
                        // [Nuclear] Full Permutation for small sets (<= 6)
                        const permute = (arr, m = []) => {
                            if (arr.length === 0) {
                                const sc = getContextScore(m);
                                if (sc > bestLocalScore) {
                                    bestLocalScore = sc;
                                    bestLocalSeq = m;
                                }
                            } else {
                                for (let i = 0; i < arr.length; i++) {
                                    const curr = arr.slice();
                                    const next = curr.splice(i, 1);
                                    permute(curr.slice(), m.concat(next));
                                }
                            }
                        };
                        permute(originalSeq);
                    } else {
                        // [Systematic Insertion Scan] for larger sets O(N^2)
                        let improved = true;
                        let scanLimit = 2; // Fast pass

                        while (improved && scanLimit > 0) {
                            improved = false;
                            scanLimit--;

                            for (let i = 0; i < bestLocalSeq.length; i++) {
                                const item = bestLocalSeq[i];
                                const tempSeq = bestLocalSeq.filter((_, idx) => idx !== i);

                                let bestPos = -1;
                                let currentMax = -Infinity;

                                for (let pos = 0; pos <= tempSeq.length; pos++) {
                                    const candidate = [...tempSeq.slice(0, pos), item, ...tempSeq.slice(pos)];
                                    const s = getContextScore(candidate);
                                    if (s > currentMax) {
                                        currentMax = s;
                                        bestPos = pos;
                                    }
                                }

                                if (currentMax > bestLocalScore + 0.001) {
                                    bestLocalScore = currentMax;
                                    bestLocalSeq = [...tempSeq.slice(0, bestPos), item, ...tempSeq.slice(bestPos)];
                                    improved = true;
                                }
                            }
                        }
                    }

                    // Apply result if better
                    if (bestLocalScore > getContextScore(originalSeq)) {
                        currentSeqs[colId] = bestLocalSeq;
                        // Update caches in place
                        this.stabilityScores[colId] = this.calculateColumnStability(colId, bestLocalSeq);
                        if (cIdx > 0) this.pairScores[cIdx - 1] = this.calculatePairScore(this.cols[cIdx - 1], colId, currentSeqs[this.cols[cIdx - 1]], bestLocalSeq);
                        if (cIdx < this.cols.length - 1) this.pairScores[cIdx] = this.calculatePairScore(colId, this.cols[cIdx + 1], bestLocalSeq, currentSeqs[this.cols[cIdx + 1]]);
                        return true;
                    }
                    return false;
                }; // End optimizeColumn

                try {
                    const deepIterations = Math.min(100000, iterations); // é™åˆ¶æ·±åº¦ä¼˜åŒ–è¿­ä»£æ¬¡æ•°
                    for (let i = 0; i < deepIterations; i++) {
                        if (stopRef.current) break;

                        const isDebugPhase = i < 100;

                        // [Mutation Strategy Selector]
                        // 30% Chance: Block Shift (To move entire timelines together and avoid breaking stability)
                        // 70% Chance: Atomic Swap (Fine tuning)
                        const mutationRoll = Math.random();

                        if (mutationRoll < 0.3) {
                            // --- Block Shift Mutation ---
                            const randColIdx = Math.floor(Math.random() * this.cols.length);
                            const colId = this.cols[randColIdx];
                            const seq = currentSeqs[colId];

                            if (seq && seq.length >= 3) {
                                // 1. Define Random Block
                                const maxBlockSize = Math.floor(seq.length * 0.7);
                                const blockSize = Math.floor(Math.random() * (maxBlockSize - 1)) + 2; // Size 2 to 70%
                                const startIdx = Math.floor(Math.random() * (seq.length - blockSize + 1));

                                // 2. Extract & Reconstruct
                                const movingBlock = seq.slice(startIdx, startIdx + blockSize);
                                const remainder = [...seq.slice(0, startIdx), ...seq.slice(startIdx + blockSize)];
                                const insertPos = Math.floor(Math.random() * (remainder.length + 1));
                                const newSeq = [...remainder.slice(0, insertPos), ...movingBlock, ...remainder.slice(insertPos)];

                                // 3. Local Score Evaluation (Fast)
                                let oldCacheScore = (this.stabilityScores[colId] || 0);
                                if (randColIdx > 0) oldCacheScore += (this.pairScores[randColIdx - 1] || 0);
                                if (randColIdx < this.cols.length - 1) oldCacheScore += (this.pairScores[randColIdx] || 0);

                                const getLocalScore = (s) => {
                                    let sc = this.calculateColumnStability(colId, s);
                                    if (randColIdx > 0) sc += this.calculatePairScore(this.cols[randColIdx - 1], colId, currentSeqs[this.cols[randColIdx - 1]], s);
                                    if (randColIdx < this.cols.length - 1) sc += this.calculatePairScore(colId, this.cols[randColIdx + 1], s, currentSeqs[this.cols[randColIdx + 1]]);
                                    return sc;
                                };

                                const newLocal = getLocalScore(newSeq);
                                const delta = newLocal - oldCacheScore;

                                // 4. Accept/Reject (SA)
                                if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                                    currentSeqs[colId] = newSeq;
                                    currentScore += delta;

                                    // Update Caches
                                    this.stabilityScores[colId] = this.calculateColumnStability(colId, newSeq);
                                    if (randColIdx > 0) this.pairScores[randColIdx - 1] = this.calculatePairScore(this.cols[randColIdx - 1], colId, currentSeqs[this.cols[randColIdx - 1]], newSeq);
                                    if (randColIdx < this.cols.length - 1) this.pairScores[randColIdx] = this.calculatePairScore(colId, this.cols[randColIdx + 1], newSeq, currentSeqs[this.cols[randColIdx + 1]]);

                                    if (currentScore > bestScore) {
                                        const verifiedScore = this.calculateGlobalScore(currentSeqs);
                                        if (verifiedScore > bestScore) {
                                            bestScore = verifiedScore;
                                            bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                                            lastImprovement = i;
                                        }
                                        currentScore = verifiedScore;
                                    }
                                }
                            }

                        } else {
                            // --- Atomic Swap Mutation (Legacy) ---
                            // 1. Random Swap Perturbation (SA)
                            const randColIdx = Math.floor(Math.random() * this.cols.length);
                            const colId = this.cols[randColIdx];
                            const seq = currentSeqs[colId];

                            // [Safety Check]
                            if (seq && seq.length >= 2) {
                                const idx1 = Math.floor(Math.random() * seq.length);
                                const idx2 = Math.floor(Math.random() * seq.length);

                                if (idx1 !== idx2) {
                                    const { delta, newLeftScore, newRightScore, newStability, leftPairIdx, rightPairIdx } =
                                        this.calculateScoreDeltaWithSwap(currentSeqs, randColIdx, idx1, idx2);

                                    if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                                        // Apply Swap
                                        [seq[idx1], seq[idx2]] = [seq[idx2], seq[idx1]];
                                        currentScore += delta;

                                        if (leftPairIdx >= 0) this.pairScores[leftPairIdx] = newLeftScore;
                                        if (rightPairIdx < this.cols.length - 1) this.pairScores[rightPairIdx] = newRightScore;
                                        this.stabilityScores[colId] = newStability;

                                        if (currentScore > bestScore) {
                                            const verifiedScore = this.calculateGlobalScore(currentSeqs);
                                            if (verifiedScore > bestScore) {
                                                bestScore = verifiedScore;
                                                bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                                                lastImprovement = i;
                                            }
                                            currentScore = verifiedScore;
                                        }
                                    }
                                }
                            }
                        }

                        // Cooling
                        if (i % 500 === 0) temp *= 0.9995;

                        // [Strategy 2] Strategic Repair (Every 1000 iters)
                        // Target: 1. Physically broken columns (Unstable)
                        //         2. Visually misaligned columns (High Gap Penalty)
                        if (i % 1000 === 0) {
                            let candidates = new Map(); // Use Map to dedupe: colIdx -> score

                            for (let c = 0; c < this.cols.length; c++) {
                                const cid = this.cols[c];
                                let severity = 0;

                                // Check Stability
                                const stab = this.stabilityScores[cid] || 0;
                                if (stab < -100) severity += stab;

                                // Check Alignment (Left)
                                if (c > 0) {
                                    const pairL = this.pairScores[c - 1] || 0;
                                    if (pairL < -500) severity += pairL; // Significant misalignment
                                }
                                // Check Alignment (Right)
                                if (c < this.cols.length - 1) {
                                    const pairR = this.pairScores[c] || 0;
                                    if (pairR < -500) severity += pairR;
                                }

                                if (severity < -100) {
                                    candidates.set(c, severity);
                                }
                            }

                            if (candidates.size > 0) {
                                // Convert to array and sort
                                const sorted = Array.from(candidates.entries())
                                    .map(([cIdx, score]) => ({ cIdx, score }))
                                    .sort((a, b) => a.score - b.score);

                                // Fix top 5 worst offenders
                                const fixCount = Math.min(sorted.length, 5);
                                for (let k = 0; k < fixCount; k++) {
                                    const improved = optimizeColumn(sorted[k].cIdx);
                                    if (improved) {
                                        const realScore = this.calculateGlobalScore(currentSeqs);
                                        if (realScore > bestScore) {
                                            bestScore = realScore;
                                            bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                                            lastImprovement = i;
                                        }
                                        currentScore = realScore;
                                    }
                                }
                                if (isDebugPhase) this.onLog(`[Strategic Fix] Optimized ${fixCount} cols (Stab/Gap).`);
                            } else {
                                // Fallback: Random Polish
                                const polishIdx = Math.floor(Math.random() * this.cols.length);
                                const improved = optimizeColumn(polishIdx);
                                if (improved) {
                                    const realScore = this.calculateGlobalScore(currentSeqs);
                                    currentScore = realScore;
                                    if (currentScore > bestScore) {
                                        bestScore = currentScore;
                                        bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                                        lastImprovement = i;
                                    }
                                }
                            }
                        }

                        // [Strategy 3] Ripple Repair (Stagnation Breaker)
                        // Dynamic Threshold: As we go deeper (i increases), we become more aggressive (threshold decreases)
                        // Early game: 20000 (Give SA time to work)
                        // Late game (>200k): 2000 (Rely purely on Ripple to break deadlocks)
                        let dynamicThreshold = 20000;
                        if (i > 100000) dynamicThreshold = 5000;
                        if (i > 300000) dynamicThreshold = 2000;

                        if (i - lastImprovement > dynamicThreshold) {
                            this.onLog(`[Ripple ILS] Stagnation > ${dynamicThreshold} at ${i}. Initiating Repair...`);

                            // Reset to best to avoid divergence
                            currentSeqs = JSON.parse(JSON.stringify(bestSeqs));
                            this.calculateGlobalScore(currentSeqs);

                            // Find worst columns
                            const colScores = this.cols.map((cid, idx) => {
                                let score = 0;
                                if (idx > 0) score += this.pairScores[idx - 1];
                                if (idx < this.cols.length - 1) score += this.pairScores[idx];
                                score += this.stabilityScores[cid] || 0;
                                return { idx, score };
                            });
                            colScores.sort((a, b) => a.score - b.score);

                            // Target worst 3 + 2 random
                            const targetIdxs = new Set(colScores.slice(0, 3).map(x => x.idx));
                            while (targetIdxs.size < 5) targetIdxs.add(Math.floor(Math.random() * this.cols.length));

                            // Optimize their neighborhood
                            targetIdxs.forEach(centerIdx => {
                                optimizeColumn(centerIdx);
                                optimizeColumn(centerIdx - 1);
                                optimizeColumn(centerIdx + 1);
                            });

                            currentScore = this.calculateGlobalScore(currentSeqs);
                            if (currentScore > bestScore) {
                                bestScore = currentScore;
                                bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                                this.onLog(`[Ripple ILS] Breakthrough! Score: ${bestScore}`);
                                if (updateCallback) updateCallback(this.generateLayout(bestSeqs), bestScore);
                            }
                            lastImprovement = i; // Reset timer
                        }

                        // UI Updates & Yielding
                        if (i < 100 && i % 10 === 0) {
                            // Debug phase
                            await new Promise(r => setTimeout(r, 0));
                        } else if (i % 2000 === 0) {
                            const now = performance.now();
                            if (now - lastYield > 12) {
                                if (now - lastUIUpdate > 1000) {
                                    this.onLog(`SeqOpt Iter ${(i / 1000000).toFixed(2)}M | Best: ${Math.floor(bestScore)} | Temp: ${temp.toFixed(0)}`);
                                    if (updateCallback) updateCallback(this.generateLayout(bestSeqs), bestScore);
                                    lastUIUpdate = now;
                                    await new Promise(r => setTimeout(r, 0));
                                } else {
                                    await new Promise(r => setTimeout(r, 0));
                                }
                                lastYield = performance.now();
                            }
                        }
                    }
                } catch (e) {
                    const errMsg = `[FATAL] SeqOpt Error: ${e.message}`;
                    this.onLog(errMsg);
                    console.error(e);
                    // Fallback to best effort
                }

                // [Final Verification] çº æ­£å¢é‡è¯¯å·®
                const finalVerifiedScore = this.calculateGlobalScore(bestSeqs);
                this.onLog(`[Verify] Incr: ${bestScore} -> Full: ${finalVerifiedScore} (Diff: ${bestScore - finalVerifiedScore})`);
                bestScore = finalVerifiedScore;

                const finalMsg = `[DEBUG] Run Completed. Final Score: ${bestScore}`;
                this.onLog(finalMsg);
                console.log(finalMsg);

                this.masterSeqs = bestSeqs;
                return { layout: this.generateLayout(bestSeqs), score: bestScore };
            }

            generateLayout(seqs) {
                const layout = {};
                this.cols.forEach(id => {
                    layout[id] = {};
                    const master = seqs[id];
                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.activeSets[id][y];
                        if (set) layout[id][y] = master.filter(r => set.has(r));
                        else layout[id][y] = [];
                    }
                });
                return layout;
            }
        }

        // --- App ---
        function App() {
            const [data, setData] = useState(null);
            const [colOrder, setColOrder] = useState([]);
            const [cellLayout, setCellLayout] = useState({});
            const [masterSeqs, setMasterSeqs] = useState(null); // å­˜å‚¨ä¸»åºåˆ—è¡¨

            const [status, setStatus] = useState('idle');
            const [tspBestScore, setTspBestScore] = useState(0); // è®°å½• TSP å†å²æœ€é«˜åˆ†
            const [logs, setLogs] = useState(['ç­‰å¾… CSV...']);
            const [isFlipped, setIsFlipped] = useState(false); // [New] ç¿»è½¬çŠ¶æ€
            const [layoutScore, setLayoutScore] = useState(0); // [New] å¸ƒå±€åˆ†æ•°
            const [draggedCol, setDraggedCol] = useState(null); // [New] æ‹–æ‹½åˆ—ç´¢å¼•
            const [dataHash, setDataHash] = useState(null); // [New] æ•°æ®æŒ‡çº¹

            const fileInputRef = useRef();
            const logEndRef = useRef();
            const gridRef = useRef();
            const stopRef = useRef(false);
            const [scrollTop, setScrollTop] = useState(0);
            const [viewportH, setViewportH] = useState(800);

            // [New] Manual Sequence Adjustment Interaction States
            const [interactionMode, setInteractionMode] = useState('idle'); // 'idle', 'select-region', 'select-regime-a', 'select-regime-b', 'confirm-move'
            const [targetRegion, setTargetRegion] = useState(null);
            const [moveRegimeA, setMoveRegimeA] = useState(null);
            const [moveRegimeB, setMoveRegimeB] = useState(null);
            const [scoreComparison, setScoreComparison] = useState(null); // { old: 0, new: 0 }



            // [New] Quick Score Calculation
            const calculateQuickScores = async (gridData, orderData, seqsData) => {
                if (!gridData || !orderData) return;
                try {
                    const sorter = new AdvancedColumnSorter(orderData, gridData, {}, () => { });
                    await sorter.precompute(); // Recalculate affinity matrix
                    const path = orderData.map((_, i) => i);
                    const tScore = sorter.getPathScore(path);
                    setTspBestScore(Math.floor(tScore));
                } catch (e) { console.warn("Quick TSP Calc failed", e); }

                if (seqsData) {
                    try {
                        const optimizer = new GlobalSequenceOptimizer(orderData, gridData, () => { });
                        optimizer.init(seqsData);
                        const lScore = optimizer.calculateGlobalScore(seqsData);
                        setLayoutScore(Math.floor(lScore));
                        // Also set initial best score reference if needed
                    } catch (e) { console.warn("Quick LAY Calc failed", e); }
                } else {
                    setLayoutScore(0);
                }
            };

            const parseContent = async (content, isJSON, preloadedColOrder = null, preloadedMasterSeqs = null) => {
                if (isJSON) {
                    try {
                        const json = JSON.parse(content);
                        if (json.colOrder) { setColOrder(json.colOrder); addLog("å·²æ¢å¤åˆ—é¡ºåºæ¨¡å…·ã€‚"); }
                        if (json.masterSeqs) { setMasterSeqs(json.masterSeqs); addLog("å·²æ¢å¤ä¸»åºåˆ—è¡¨æ¨¡å…·ã€‚"); }

                        // [New] Calculate Initial Scores immediately
                        if (data && json.colOrder) {
                            await calculateQuickScores(data.grid, json.colOrder, json.masterSeqs);
                        }

                        return json; // è¿”å›ä¾›é“¾å¼è°ƒç”¨
                    } catch (err) { alert("JSON Error"); }
                } else {
                    setDataHash(simpleHash(content)); // [New] è®¡ç®—æ•°æ® Hash
                    const lines = content.split(/\r?\n/).filter(l => l.trim());
                    const headers = lines[0].toLowerCase().split(',');
                    const findCol = (keys) => headers.findIndex(h => keys.some(k => h.includes(k)));
                    const idx = {
                        geoCode: findCol(['geo_code', 'region_code']),
                        geoName: findCol(['geo_name', 'region_name']),
                        start: findCol(['start']),
                        end: findCol(['end']),
                        regimeName: findCol(['regime_name', 'polity_name']),
                        regimeCode: findCol(['regime_code', 'polity_code'])
                    };
                    if (idx.geoName === -1) idx.geoName = idx.geoCode;
                    if (idx.regimeName === -1) idx.regimeName = idx.regimeCode;
                    if (idx.geoCode === -1 || idx.start === -1) { alert("CSV Error: Missing columns"); return; }

                    const regions = new Set();
                    const grid = {};
                    const regionNames = {};

                    for (let i = 1; i < lines.length; i++) {
                        const row = lines[i].split(',').map(s => s.trim().replace(/^"|"$/g, ''));
                        if (row.length < 4) continue;
                        const geoCode = row[idx.geoCode];
                        const geoName = row[idx.geoName] || geoCode;
                        const start = parseInt(row[idx.start]);
                        let end = row[idx.end];
                        end = (end === '' || end.toLowerCase().includes('present')) ? CONFIG.MAX_YEAR : parseInt(end);
                        const regimeName = row[idx.regimeName];
                        const regimeCode = row[idx.regimeCode] || regimeName; // è·å– Code

                        if (!geoCode || isNaN(start)) continue;
                        regions.add(geoCode);
                        regionNames[geoCode] = geoName;
                        // [New] å­˜å‚¨æ˜ å°„
                        if (!regionNames._codes) regionNames._codes = {};
                        regionNames._codes[regimeName] = regimeCode;

                        if (!grid[geoCode]) grid[geoCode] = {};
                        let loopEnd = (start === end) ? start : end - 1;
                        for (let y = start; y <= loopEnd; y++) {
                            if (y >= CONFIG.MIN_YEAR && y <= CONFIG.MAX_YEAR) {
                                if (!grid[geoCode][y]) grid[geoCode][y] = new Set();
                                // [Fix] ID ç­–ç•¥ï¼šName + Code (ç¡®ä¿è·¨æ—¶é—´æ®µçš„æ”¿æƒåŒä¸€æ€§)
                                grid[geoCode][y].add(regimeName + "|" + regimeCode);
                            }
                        }
                    }

                    const regionList = Array.from(regions).sort();
                    // è¿™é‡Œåå­—å¤ç”¨ regionNames å¯¹è±¡å­˜ code mapï¼Œç¨å¾®æœ‰ç‚¹æ‰€è°“ï¼Œä½†å¯ä»¥ç”¨ ._codes è®¿é—®
                    setData({ regions: regionList, grid, names: regionNames, codes: regionNames._codes });

                    // å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„é¢„åŠ è½½é¡ºåºï¼Œå¦åˆ™æ‰ç”¨ State
                    const currentOrder = preloadedColOrder || colOrder;
                    // [New] å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ä¸»åºæ¨¡å…·ï¼Œå¦åˆ™æ‰ç”¨ State
                    const currentMasterSeqs = preloadedMasterSeqs || masterSeqs;

                    const newRegionSet = new Set(regionList);
                    const oldRegionSet = new Set(currentOrder);

                    // æ ¡éªŒé€»è¾‘ï¼šåªæœ‰å½“ä¸¤ä¸ªé›†åˆå…ƒç´ å®Œå…¨ä¸€è‡´æ—¶ï¼Œæ‰ä¿ç•™å¸ƒå±€
                    const isSameRegions = currentOrder.length > 0 &&
                        newRegionSet.size === oldRegionSet.size &&
                        [...newRegionSet].every(x => oldRegionSet.has(x));

                    if (isSameRegions) {
                        try {
                            addLog("æ£€æµ‹åˆ°åœ°åŒºä¸€è‡´ï¼Œä¿ç•™ç°æœ‰åˆ—é¡ºåºæ¨¡å…·ã€‚");
                            // æ—¢ç„¶ä¸€è‡´ï¼Œå°±å¼ºåˆ¶åº”ç”¨è¿™ä¸ªé¡ºåº
                            if (preloadedColOrder) setColOrder(preloadedColOrder);

                            if (currentMasterSeqs) {
                                addLog("å°è¯•åº”ç”¨ç°æœ‰ä¸»åºåˆ—è¡¨åˆ°æ–°æ•°æ®...");
                                const sorter = new GlobalSequenceOptimizer(currentOrder, grid, () => { });
                                sorter.masterSeqs = currentMasterSeqs;
                                sorter.init(currentMasterSeqs);
                                setMasterSeqs(sorter.masterSeqs);
                                const newLayout = sorter.generateLayout(sorter.masterSeqs);
                                setCellLayout(newLayout);

                                const loadedScore = sorter.calculateGlobalScore(sorter.masterSeqs);
                                setLayoutScore(loadedScore);
                                addLog(`å¸ƒå±€åŠ è½½éªŒè¯: é‡æ–°è®¡ç®—å¾—åˆ†ä¸º ${Math.floor(loadedScore)}`);
                            } else {
                                // Default Init
                                const initLayout = {};
                                currentOrder.forEach(id => {
                                    initLayout[id] = {};
                                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                                        const s = grid[id][y];
                                        initLayout[id][y] = s ? Array.from(s).sort() : [];
                                    }
                                });
                                setCellLayout(initLayout);
                            }
                        } catch (e) {
                            addLog(`[Error] åº”ç”¨å¸ƒå±€å¤±è´¥: ${e.message}`);
                            console.error(e);
                            // Fallback to reset
                            setColOrder(regionList);
                            setMasterSeqs({});
                            setCellLayout({});
                        }
                    } else {
                        addLog(`åœ°åŒºæ¨¡å…·ä¸åŒ¹é… (åŸ:${oldRegionSet.size}, æ–°:${newRegionSet.size})ï¼Œé‡ç½®å¸ƒå±€ã€‚`);
                        setColOrder(regionList);
                        setMasterSeqs({});
                        setCellLayout({});
                    }
                    const finalOrder = isSameRegions ? (preloadedColOrder || currentOrder) : regionList;
                    const finalSeqs = isSameRegions ? currentMasterSeqs : null;

                    // [New] Calc Scores
                    calculateQuickScores(grid, finalOrder, finalSeqs);

                    setStatus('ready');
                }
            };

            const addLog = (msg) => setLogs(prev => [...prev.slice(-499), `> ${msg}`]);
            useEffect(() => { if (logEndRef.current) logEndRef.current.scrollIntoView({ behavior: "smooth" }); }, [logs]);

            const runDeepJointOptimization = async () => {
                if (!data || status !== 'ready') return;
                stopRef.current = false;
                setStatus('optimizing');
                addLog("=== ğŸš€ å¯åŠ¨æ·±åº¦è”åˆä¼˜åŒ– (Deep Joint Optimization) ===");

                // --- Phase 1: Column Sort ---
                addLog(`[Phase 1] åˆ—æ’åº (TSP)`);
                // Note: bonusMatrix is null, so purely based on adjacency
                const colSorter = new AdvancedColumnSorter(data.regions, data.grid, data.names, addLog);
                await colSorter.precompute();



                // Run TSP (Inherit current order if available)
                const colResult = await colSorter.run(50000000, (_, score) => {
                    if (score > tspBestScore) setTspBestScore(score);
                }, stopRef, colOrder);

                if (stopRef.current) { addLog("ä¼˜åŒ–å·²ä¸­æ­¢"); setStatus('ready'); return; }

                const newColOrder = colResult.path;
                setColOrder(newColOrder); // Update State
                setTspBestScore(colResult.score);
                addLog(`åˆ—æ’åºå®Œæˆã€‚Score: ${colResult.score}`);

                // --- Phase 2: Cell Layout ---
                setStatus('layout');
                addLog(`[Phase 2] å•å…ƒæ ¼åºåˆ—å¯¹é½`);

                // Use the NEW colOrder directly
                const cellSorter = new GlobalSequenceOptimizer(newColOrder, data.grid, addLog);

                // [Debug] æ£€æŸ¥ masterSeqs æ˜¯å¦æ­£ç¡®ä¼ é€’
                addLog(`[Debug] masterSeqs çŠ¶æ€: ${masterSeqs ? Object.keys(masterSeqs).length + 'åˆ—' : 'NULL'}`);

                const cellResult = await cellSorter.run(
                    500000, // iterations
                    (layout, s) => {
                        setCellLayout(layout);
                        setLayoutScore(Math.floor(s)); // [Fix] Update UI Score Live
                    },
                    stopRef,
                    masterSeqs // [Fix] Pass existing masterSeqs as 'Champion'
                );

                if (stopRef.current) { addLog("ä¼˜åŒ–å·²ä¸­æ­¢"); setStatus('ready'); return; }

                setMasterSeqs(cellSorter.masterSeqs);
                setCellLayout(cellResult.layout);
                setLayoutScore(Math.floor(cellResult.score));
                addLog(`æ·±åº¦ä¼˜åŒ–å®Œæˆã€‚Final TSP: ${colResult.score}, Final LAY: ${Math.floor(cellResult.score)}`);
                setStatus('ready');
            };

            // ... Inside Return JSX for Logs ...
            // <div className="h-40 overflow-y-auto ...">
            //    {logs.map((l, i) => {
            //        const isHighlight = l.includes("Breakthrough") || l.includes("New Best") || l.includes("Final Score");
            //        return (
            //          <div key={i} style={{ 
            //              color: isHighlight ? '#4ade80' : '#9ca3af',
            //              fontWeight: isHighlight ? 'bold' : 'normal'
            //          }}>{l}</div>
            //        );
            //    })}
            // </div>



            const handleFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => parseContent(evt.target.result, file.name.endsWith('.json'));
                reader.readAsText(file);
                e.target.value = '';
            };

            // [New] åŠ è½½è¿œç¨‹ CSV
            const loadRemoteCSV = async (url = null, preloadedColOrder = null, preloadedMasterSeqs = null) => {
                const GOOGLE_CSV = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSMSHMYH-_pI-2v9bqP-1Balz19zzjAW9QyykU5D1GsfnGVV4Xt-OwPjOlFKPwQL2rQ9EVGCgl7ikCs/pub?gid=0&single=true&output=csv";
                const LOCAL_CSV = "history_data.csv";

                let targetUrl = url || GOOGLE_CSV;
                addLog(`æ­£åœ¨å°è¯•åŠ è½½æ•°æ®: ${targetUrl}...`);

                const tryFetch = async (u) => {
                    // æ·»åŠ æ—¶é—´æˆ³é˜²ç¼“å­˜
                    const fetchUrl = u + (u.includes('?') ? '&' : '?') + 't=' + Date.now();
                    const res = await fetch(fetchUrl);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.text();
                };

                try {
                    const text = await tryFetch(targetUrl);
                    addLog("æ•°æ®ä¸‹è½½å®Œæˆï¼Œå¼€å§‹è§£æ...");
                    parseContent(text, false, preloadedColOrder, preloadedMasterSeqs);
                } catch (e) {
                    addLog(`åŠ è½½å¤±è´¥ (${targetUrl}): ${e.message}`);
                    if (!url && targetUrl === GOOGLE_CSV) {
                        addLog(`æ­£åœ¨å°è¯•é™çº§åŠ è½½æœ¬åœ°æ–‡ä»¶: ${LOCAL_CSV}...`);
                        try {
                            const localText = await tryFetch(LOCAL_CSV);
                            addLog("æœ¬åœ°æ•°æ®ä¸‹è½½å®Œæˆï¼Œå¼€å§‹è§£æ...");
                            parseContent(localText, false, preloadedColOrder, preloadedMasterSeqs);
                        } catch (e2) {
                            addLog(`æœ¬åœ°åŠ è½½ä¹Ÿå¤±è´¥äº†: ${e2.message}`);
                            alert(`æ— æ³•åŠ è½½äº‘ç«¯æˆ–æœ¬åœ°æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æ‰‹åŠ¨ä¸Šä¼ ã€‚`);
                        }
                    } else {
                        alert(`æ— æ³•åŠ è½½ ${targetUrl}: ${e.message}`);
                    }
                }
            };

            // [New] è‡ªåŠ¨è¿è¡Œé€»è¾‘
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const csvUrl = params.get('csv');
                const autorun = params.get('autorun');

                let loadedLayout = null;

                // 1. æ€»æ˜¯å°è¯•åŠ è½½ layout.json ä»¥æ¢å¤æ¨¡å…· (Column Order)
                fetch('layout.json?t=' + Date.now())
                    .then(res => {
                        if (res.ok) return res.text();
                        throw new Error('No layout.json');
                    })
                    .then(async text => {
                        addLog("å‘ç° layout.jsonï¼Œæ­£åœ¨æ¢å¤åˆ—é¡ºåºæ¨¡å…·...");
                        // è§£æå¹¶ä¿å­˜ï¼Œä½†ä¸ä¾èµ– State
                        loadedLayout = await parseContent(text, true);
                    })
                    .catch(() => addLog("æœªæ‰¾åˆ° layout.json æˆ–åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤æˆ–æ–°ç”Ÿæˆçš„å¸ƒå±€ã€‚"))
                    .finally(() => {
                        const preloadedOrder = loadedLayout ? loadedLayout.colOrder : null;
                        const preloadedSeqs = loadedLayout ? loadedLayout.masterSeqs : null;

                        // 2. åŠ è½½æ•°æ® (CSV)
                        if (csvUrl) {
                            loadRemoteCSV(csvUrl, preloadedOrder, preloadedSeqs);
                        } else if (autorun === 'true') {
                            // ä¸ä¼ å‚ï¼Œä½¿ç”¨ loadRemoteCSV å†…éƒ¨å®šä¹‰çš„é»˜è®¤é€»è¾‘ (Google -> history_data.csv)
                            loadRemoteCSV(null, preloadedOrder, preloadedSeqs);
                        } else {
                            // [Fix] Default behavior: Load remote CSV anyway
                            loadRemoteCSV(null, preloadedOrder, preloadedSeqs);
                        }
                    });
            }, []);

            const handleStop = () => {
                stopRef.current = true;
                addLog("ç”¨æˆ·è¯·æ±‚åœæ­¢...");
            };



            const runColumnOptimizer = async () => {
                if (!data) return;
                setStatus('ranking');
                stopRef.current = false;

                const perspective = PERSPECTIVES[selectedPerspective];
                addLog(`=== æ­¥éª¤ 1: é«˜çº§åˆ—æ’åº (TSP Deep Search) ===`);
                addLog(`è§†è§’: ${perspective.name}`);
                addLog("æ­£åœ¨é¢„è®¡ç®—äº²å’Œåº¦çŸ©é˜µ (å«åœ°ç†åå¥½)...");

                const sorter = new AdvancedColumnSorter(data.regions, data.grid, data.names, addLog);
                await sorter.precompute();

                // [New] Apply Perspective Weights
                if (!perspective.isDefault) {
                    addLog(`åº”ç”¨è§†è§’æƒé‡...`);

                    // Extract core regions
                    const coreRegions = new Set();
                    const regimeGroups = extractRegimeGroupsFromGrid(data.grid, data.regions);

                    regimeGroups.forEach(group => {
                        if (perspective.coreRegimes.includes(group.id)) {
                            group.regions.forEach(r => coreRegions.add(r));
                        }
                    });

                    addLog(`æ ¸å¿ƒåŒºåŸŸ: ${coreRegions.size} åˆ— (${Array.from(coreRegions).join(', ')})`);

                    // Apply weights to matrix
                    const n = data.regions.length;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const rA = data.regions[i];
                            const rB = data.regions[j];

                            const bothCore = coreRegions.has(rA) && coreRegions.has(rB);
                            const bothBg = !coreRegions.has(rA) && !coreRegions.has(rB);

                            if (bothCore) {
                                // Check if same regime
                                const sameRegime = regimeGroups.some(g => {
                                    if (!perspective.coreRegimes.includes(g.id)) return false;
                                    return g.regions.has(rA) && g.regions.has(rB);
                                });

                                sorter.matrix[i][j] *= sameRegime
                                    ? perspective.weights.intraRegime
                                    : perspective.weights.interRegime;
                            } else if (bothBg) {
                                sorter.matrix[i][j] *= perspective.weights.background;
                            } else {
                                sorter.matrix[i][j] *= perspective.weights.background;
                            }
                        }
                    }

                    addLog(`æƒé‡åº”ç”¨å®Œæˆ (æ ¸å¿ƒÃ—${perspective.weights.intraRegime}, èƒŒæ™¯Ã—${perspective.weights.background})`);
                }

                addLog("å¼€å§‹ SA + 2-Opt æ·±åº¦æœç´¢ (Max 50M Iters)...");
                // è¿è¡Œç®—æ³•ï¼Œä¼ å…¥å›è°ƒå®æ—¶æ›´æ–°åˆ†æ•° (ä»…å½“è¶…è¶Šå†å²æœ€é«˜åˆ†æ—¶æ›´æ–° UI)
                const result = await sorter.run(50000000, (_, score) => {
                    if (score > tspBestScore) setTspBestScore(score);
                }, stopRef);

                // é˜²é€€åŒ–æ£€æŸ¥
                if (result.score > tspBestScore) {
                    addLog(`æ–°çºªå½•ï¼Score: ${result.score} (æ—§: ${tspBestScore})`);
                    setTspBestScore(result.score);
                    setColOrder(result.path);
                } else {
                    addLog(`æœªå‘ç°æ›´ä¼˜è§£ (Current: ${result.score} vs Best: ${tspBestScore})ã€‚ä¿æŒåŸæ ·ã€‚`);
                }

                addLog("åˆ—æ’åºæ­¥éª¤ç»“æŸã€‚");
                setStatus('ready');
            };

            // Helper: Extract regime groups from grid
            const extractRegimeGroupsFromGrid = (grid, regions) => {
                const groups = new Map();

                regions.forEach(r => {
                    Object.entries(grid[r] || {}).forEach(([y, set]) => {
                        set.forEach(regimeId => {
                            const id = regimeId.trim();
                            if (!groups.has(id)) {
                                groups.set(id, { id, regions: new Set() });
                            }
                            groups.get(id).regions.add(r);
                        });
                    });
                });

                return Array.from(groups.values()).filter(g => g.regions.size >= 1);
            };

            const runCellOptimizer = async () => {
                if (!data) return;
                setStatus('layout');
                stopRef.current = false;
                addLog("=== æ­¥éª¤ 2: å…¨å±€åºåˆ—å¯¹é½ (Master Sequence) ===");
                addLog("æ„å»ºæ°¸æ’æ”¿æƒåºåˆ—ï¼Œç¡®ä¿ç»å¯¹ç»§æ‰¿ä¸åå‘ä¼ æ’­...");

                const sorter = new GlobalSequenceOptimizer(colOrder, data.grid, addLog);

                // [Fix] æ·»åŠ è°ƒè¯•æ—¥å¿—
                addLog(`[Debug] masterSeqs çŠ¶æ€: ${masterSeqs ? Object.keys(masterSeqs).length + 'åˆ—' : 'NULL'}`);

                // ä¼ å…¥å›è°ƒï¼ŒåŒæ—¶æ›´æ–° Layout å’Œ Score
                const result = await sorter.run(
                    500000,
                    (layout, score) => {
                        setCellLayout(layout);
                        if (score !== undefined) setLayoutScore(score);
                    },
                    stopRef,
                    masterSeqs // [Fix] ä¼ å…¥å·²æœ‰çš„ masterSeqs ä½œä¸ºèµ·ç‚¹
                );

                setMasterSeqs(sorter.masterSeqs);
                setCellLayout(result.layout);
                setLayoutScore(result.score); // ä½¿ç”¨çœŸå®æœ€ç»ˆå¾—åˆ†
                addLog(`æ‰€æœ‰ä¼˜åŒ–å®Œæˆã€‚æœ€ç»ˆ LayScore: ${result.score}`);
                setStatus('done');
            };

            const handleFlip = () => {
                const newFlipped = !isFlipped;
                setIsFlipped(newFlipped);

                // 1. ç¿»è½¬åˆ—é¡ºåº
                setColOrder(prev => [...prev].reverse());

                // 2. ç¿»è½¬å•å…ƒæ ¼å†…é¡ºåº (Master Seqs need to be reversed too if we want true flip, but usually visuals are enough. Actually, LAY doesn't care about internal order for flip, but rendering does.)
                // For visual consistency, let's reverse the masterSeqs effectively by reversing the layout arrays
                setCellLayout(prev => {
                    const next = {};
                    Object.keys(prev).forEach(id => {
                        next[id] = {};
                        Object.keys(prev[id]).forEach(y => {
                            next[id][y] = [...prev[id][y]].reverse();
                        });
                    });
                    return next;
                });

                addLog(`å¸ƒå±€å·²${newFlipped ? 'ç¿»è½¬' : 'è¿˜åŸ'} (North/South)`);
            };

            // === Column Drag & Drop Handlers ===
            // === Interactive Sequence Adjustment ===
            const startManualAdjustment = () => {
                setInteractionMode('select-region');
                addLog("[Manual] è¯·ç‚¹å‡»é€‰æ‹©è¦ä¿®æ”¹çš„åœ°åŒºï¼ˆåˆ—æ ‡é¢˜ï¼‰");
            };

            const handleHeaderClick = (index) => {
                if (interactionMode !== 'select-region') return;
                const colId = colOrder[index];
                setTargetRegion(colId);
                setInteractionMode('select-regime-a');
                addLog(`[Manual] å·²é€‰æ‹©åœ°åŒº: ${data.names[colId]}ã€‚è¯·ç‚¹å‡»è¦ç§»åŠ¨çš„æ”¿æƒ (A)`);
            };

            const handleRegimeClick = (regime, colId) => {
                if (colId !== targetRegion && interactionMode.startsWith('select-regime')) {
                    addLog(`[Manual] é”™è¯¯ï¼šè¯·é€‰æ‹©å½“å‰åœ°åŒº (${data.names[targetRegion]}) å†…çš„æ”¿æƒ`);
                    return;
                }

                if (interactionMode === 'select-regime-a') {
                    setMoveRegimeA(regime);
                    setInteractionMode('select-regime-b');
                    addLog(`[Manual] å·²é€‰æ‹©ç§»åŠ¨å¯¹è±¡: ${regime.split('|')[0]}ã€‚è¯·ç‚¹å‡»ç›®æ ‡ä½ç½®çš„å‚ç…§æ”¿æƒ (B)ï¼ŒA å°†è¢«æ’å…¥åˆ° B ä¹‹å‰ã€‚`);
                } else if (interactionMode === 'select-regime-b') {
                    // Prevent same regime
                    if (regime === moveRegimeA) return;

                    setMoveRegimeB(regime);
                    setInteractionMode('confirm-move');

                    try {
                        // Pre-calculate score
                        const rA = moveRegimeA;
                        const rB = regime;

                        // [Fix] Must initialize weights via init()
                        const sorter = new GlobalSequenceOptimizer(colOrder, data.grid, () => { });
                        sorter.init(JSON.parse(JSON.stringify(masterSeqs)));

                        const oldScore = sorter.calculateGlobalScore(sorter.masterSeqs);

                        // Simulate Move: Insert A before B
                        const seq = sorter.masterSeqs[targetRegion];
                        const idxA = seq.indexOf(rA);
                        let idxB = seq.indexOf(rB);

                        // Remove A first
                        seq.splice(idxA, 1);
                        // Re-find B (index might shift if A was before B)
                        idxB = seq.indexOf(rB);
                        // Insert A at B
                        seq.splice(idxB, 0, rA);

                        sorter.masterSeqs[targetRegion] = seq;
                        const newScore = sorter.calculateGlobalScore(sorter.masterSeqs);

                        setScoreComparison({ old: Math.floor(oldScore), new: Math.floor(newScore) });
                        addLog(`[Manual] é¢„è®¡ç®—å®Œæˆã€‚åŸåˆ†: ${Math.floor(oldScore)} -> æ–°åˆ†: ${Math.floor(newScore)}`);
                    } catch (e) {
                        console.error(e);
                        addLog(`[Error] é¢„è®¡ç®—å¤±è´¥: ${e.message}`);
                        setInteractionMode('select-regime-b'); // Revert
                    }
                }
            };

            const confirmMove = () => {
                try {
                    const sorter = new GlobalSequenceOptimizer(colOrder, data.grid, () => { });
                    sorter.init(JSON.parse(JSON.stringify(masterSeqs)));

                    const seq = sorter.masterSeqs[targetRegion];
                    const rA = moveRegimeA;
                    const rB = moveRegimeB;

                    const idxA = seq.indexOf(rA);
                    seq.splice(idxA, 1);
                    const idxB = seq.indexOf(rB);
                    seq.splice(idxB, 0, rA);

                    // Update State
                    setMasterSeqs(sorter.masterSeqs);
                    const newLayout = sorter.generateLayout(sorter.masterSeqs);
                    setCellLayout(newLayout);
                    setLayoutScore(scoreComparison?.new || sorter.calculateGlobalScore(sorter.masterSeqs));

                    addLog(`[Manual] ä¿®æ”¹å·²åº”ç”¨ã€‚`);
                    resetManualMode();
                } catch (e) {
                    console.error(e);
                    addLog(`[Error] åº”ç”¨ä¿®æ”¹å¤±è´¥: ${e.message}`);
                }
            };

            const cancelMove = () => {
                addLog(`[Manual] æ“ä½œå·²å–æ¶ˆã€‚`);
                resetManualMode();
            };

            const resetManualMode = () => {
                setInteractionMode('idle');
                setTargetRegion(null);
                setMoveRegimeA(null);
                setMoveRegimeB(null);
                setScoreComparison(null);
            };

            // === Column Drag (Keep this for column reordering only) ===
            const handleDragStart = (e, index) => {
                setDraggedCol(index);
                e.dataTransfer.effectAllowed = "move";
                e.dataTransfer.setData("type", "column");
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                if (draggedCol === null || draggedCol === index) return;
            };

            const handleDrop = (e, targetIndex) => {
                e.preventDefault();
                if (e.dataTransfer.getData("type") !== "column") return;
                if (draggedCol === null || draggedCol === targetIndex) return;
                const newOrder = [...colOrder];
                const [removed] = newOrder.splice(draggedCol, 1);
                newOrder.splice(targetIndex, 0, removed);
                setColOrder(newOrder);
                setDraggedCol(null);
                addLog(`åˆ—å·²æ‰‹åŠ¨é‡æ’: ${data.names[removed] || removed} -> Position ${targetIndex}`);
            };

            const totalYears = CONFIG.MAX_YEAR - CONFIG.MIN_YEAR + 1;
            const totalH = totalYears * CONFIG.ROW_HEIGHT;
            const startIdx = Math.floor(scrollTop / CONFIG.ROW_HEIGHT);
            const endIdx = Math.min(totalYears, startIdx + Math.ceil(viewportH / CONFIG.ROW_HEIGHT) + 2);
            const visibleYears = [];
            for (let i = startIdx; i < endIdx; i++) visibleYears.push(CONFIG.MIN_YEAR + i);

            const exportJSON = () => {
                // [v10] ç”Ÿæˆç‰ˆæœ¬å· YYYYMMDDHHmmss
                const now = new Date();
                const version = now.getFullYear().toString() +
                    String(now.getMonth() + 1).padStart(2, '0') +
                    String(now.getDate()).padStart(2, '0') +
                    String(now.getHours()).padStart(2, '0') +
                    String(now.getMinutes()).padStart(2, '0') +
                    String(now.getSeconds()).padStart(2, '0');

                const out = {
                    version,  // ç‰ˆæœ¬å·ï¼Œç”¨äºå®¢æˆ·ç«¯ç¼“å­˜ç­–ç•¥
                    colOrder,
                    layout: cellLayout,
                    names: data.names,
                    masterSeqs: masterSeqs,
                    tspScore: tspBestScore
                };
                console.log(`[Export] layout.json with version: ${version}`);
                const blob = new Blob([JSON.stringify(out)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'layout.json'; a.click();
            };
            // [New] æ ¹æ®è§†è§’ä½¿ç”¨ä¸åŒ ID
            const saveToDB = () => {
                if (!data || !cellLayout) return;

                const perspective = data.perspective || "default";
                // [Fix] Panorama reads 'current' by default. Match that behavior.
                const layoutId = perspective === "default" ? "current" : `layout_${perspective}`;

                // [v10] ç”Ÿæˆç‰ˆæœ¬å·ç”¨äº DB å­˜å‚¨
                const now = new Date();
                const version = now.getFullYear().toString() +
                    String(now.getMonth() + 1).padStart(2, '0') +
                    String(now.getDate()).padStart(2, '0') +
                    String(now.getHours()).padStart(2, '0') +
                    String(now.getMinutes()).padStart(2, '0') +
                    String(now.getSeconds()).padStart(2, '0');

                // [v10] Payload now includes version
                const payload = {
                    version,  // ç‰ˆæœ¬å·
                    names: data.names,
                    codes: data.codes,
                    masterSeqs: masterSeqs,
                    layout: cellLayout,
                    colOrder: colOrder,
                    grid: data.grid,
                    perspective: perspective,
                    timestamp: Date.now()
                };

                // [Fix] Explicitly use version 5 to trigger schema upgrade for users who possess legacy DB
                const request = indexedDB.open("EastAsiaHistoryDB", 5);

                request.onupgradeneeded = function (event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("layouts")) {
                        db.createObjectStore("layouts", { keyPath: "id" });
                    }
                };

                request.onsuccess = function (event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["layouts"], "readwrite");
                    const store = transaction.objectStore("layouts");

                    // [CRITICAL] Panorama expects DB entry to be { id: "current", data: payload }
                    // Wraps the payload in a 'data' property.

                    // 1. Save strictly as 'current' (This is what Panorama reads)
                    const entryCurrent = { id: 'current', data: payload };
                    store.put(entryCurrent);

                    // 2. Save as specific ID (if different)
                    if (layoutId !== 'current') {
                        const entrySpecific = { id: layoutId, data: payload };
                        store.put(entrySpecific);
                    }

                    transaction.oncomplete = function () {
                        // [Debug] Verify persistence
                        const verifyReq = indexedDB.open("EastAsiaHistoryDB");
                        verifyReq.onsuccess = (ev) => {
                            const db2 = ev.target.result;
                            const tx2 = db2.transaction(["layouts"], "readonly");
                            const st2 = tx2.objectStore("layouts");
                            const get2 = st2.get("current");
                            get2.onsuccess = () => {
                                if (get2.result && get2.result.data && get2.result.data.layout) {
                                    addLog(`[System] âœ… æˆåŠŸå†™å…¥ DB å¹¶é€šè¿‡è‡ªæ£€ (ID: current)`);
                                    if (confirm(`å¸ƒå±€å·²ä¿å­˜ä¸º [${layoutId}]ï¼\næ˜¯å¦è·³è½¬åˆ°å…¨æ™¯å›¾æŸ¥çœ‹ï¼Ÿ`)) {
                                        window.location.href = "panorama.html?t=" + Date.now();
                                    }
                                } else {
                                    alert("âŒ ä¸¥é‡é”™è¯¯ï¼šå†™å…¥åçš„æ•°æ®ç»“æ„ä¸ç¬¦åˆé¢„æœŸï¼");
                                    console.error("Verification failed. Result:", get2.result);
                                }
                            };
                        };
                    };

                    transaction.onerror = function (e) {
                        addLog(`[Error] DB äº‹åŠ¡å¤±è´¥: ${e.target.error}`);
                        console.error("Transaction Error", e);
                    }
                };

                request.onerror = function (event) {
                    console.error("IndexedDB Error", event);
                    alert("æ— æ³•æ‰“å¼€ IndexedDB");
                };
            };

            const runFlip = () => { handleFlip(); }; // Wrap handleFlip

            // çº¯ JS æ¸²æŸ“
            return h('div', { className: "h-full flex flex-col bg-slate-900 text-slate-200" },
                // 1. Top Panel
                h('div', { className: "glass-panel z-50 px-4 py-3 flex items-center justify-between shadow-xl relative backdrop-blur-md bg-opacity-90 border-b border-slate-700/50" },
                    // Left
                    h('div', { className: "flex items-center gap-4" },
                        h('div', { className: "flex flex-col leading-tight" },
                            h('span', { className: "font-bold text-lg text-slate-100 tracking-tight" }, "Layout Optimizer"),
                            h('span', { className: "text-[10px] text-purple-400 font-mono" }, "v11.0 ULTRA (No-Babel)")
                        ),
                        h('div', { className: "h-8 w-px bg-slate-700/50 mx-2" }),
                        h('div', { className: "flex gap-2" },
                            h('label', { className: "btn bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600/50 cursor-pointer" },
                                h('span', { className: "opacity-80" }, "ğŸ“ å¯¼å…¥"),
                                h('input', { type: "file", accept: ".csv,.json", onChange: handleFile, className: "hidden", ref: fileInputRef })
                            ),
                            h('button', { onClick: () => loadRemoteCSV(), className: "btn bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600/50", title: "Google Sheet / Local" }, "â˜ï¸ äº‘ç«¯æ•°æ®")
                        )
                    ),
                    // Center
                    h('div', { className: "absolute left-1/2 -translate-x-1/2 flex gap-2" },
                        (status !== 'ranking' && status !== 'layout') ? h(Fragment, null,
                            h('button', { onClick: runColumnOptimizer, className: "btn bg-slate-700 hover:bg-slate-600 text-slate-200 shadow-lg border border-slate-600/50", disabled: !data }, "1. åˆ—åº"),
                            h('button', { onClick: runCellOptimizer, className: "btn bg-slate-700 hover:bg-slate-600 text-slate-200 shadow-lg border border-slate-600/50", disabled: !data }, "2. å¸ƒå±€"),
                            h('div', { className: "w-px h-8 bg-slate-700/50 mx-1" }),
                            h('button', { onClick: runDeepJointOptimization, className: "btn bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 text-white shadow-lg shadow-emerald-900/40 border-0 font-bold px-6", disabled: !data, title: "ä¸€é”®è¿è¡Œ TSP åˆ—æ’åº + Master Seq å¸ƒå±€ä¼˜åŒ–" }, "ğŸš€ æ·±åº¦è”åˆä¼˜åŒ–")
                        ) : h('div', { className: "flex gap-2 items-center bg-slate-800 rounded px-3 border border-slate-700" },
                            h('span', { className: "text-xs font-mono text-blue-300" }, status === 'ranking' ? 'TSP SOLVING...' : 'ALIGNING...'),
                            h('button', { onClick: handleStop, className: "ml-2 text-xs text-red-400 hover:text-red-300" }, "STOP")
                        )
                    ),
                    // Right
                    h('div', { className: "flex items-center gap-4" },
                        h('div', { className: "flex flex-col items-end mr-2 font-mono text-[10px] text-slate-400 cursor-help", title: "Score Info" },
                            h('div', null, "TSP: ", h('span', { className: "text-emerald-400" }, Math.round(tspBestScore).toLocaleString())),
                            h('div', null, "LAY: ", h('span', { className: "text-blue-400" }, layoutScore !== 0 ? Math.round(layoutScore).toLocaleString() : '--'))
                        ),
                        h('div', { className: "h-8 w-px bg-slate-700/50" }),
                        h('div', { className: "flex gap-2" },
                            h('button', {
                                onClick: interactionMode === 'idle' ? startManualAdjustment : resetManualMode,
                                className: `btn ${interactionMode !== 'idle' ? 'bg-amber-600 hover:bg-amber-500' : 'bg-indigo-600 hover:bg-indigo-500'} text-white border-0`,
                                disabled: !data,
                                title: "æ‰‹åŠ¨å¾®è°ƒ"
                            }, interactionMode !== 'idle' ? 'âŒ å–æ¶ˆ' : 'ğŸ› ï¸ ä¿®æ”¹åºåˆ—'),
                            h('button', { onClick: saveToDB, className: "btn bg-teal-600 hover:bg-teal-500 text-white shadow-lg shadow-teal-900/20 border-0", disabled: !data, title: "ä¿å­˜åˆ° DB" }, "ğŸ’¾ å†™å…¥ DB"),
                            h('button', { onClick: exportJSON, className: "btn bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600", disabled: !data, title: "å¯¼å‡º JSON" }, "ğŸ“¤ å¯¼å‡º"),
                            h('a', { href: "index.html", className: "btn bg-slate-800 hover:bg-slate-700 text-slate-400 border border-slate-600/50", title: "è¿”å›é¦–é¡µ" }, "ğŸ ")
                        )
                    )
                ),

                // 2. Interaction Bar
                interactionMode !== 'idle' && h('div', { className: "h-10 bg-amber-900 border-b border-amber-600 flex items-center justify-between px-4 text-xs font-medium text-amber-100 animate-fade-in z-20 shadow-md" },
                    h('div', { className: "flex items-center gap-2" },
                        h('span', { className: "mr-2 text-amber-400 font-bold" }, "ğŸ”§ åºåˆ—ç¼–è¾‘:"),
                        interactionMode === 'select-region' && "è¯·ç‚¹å‡»é€‰æ‹©è¦ä¿®æ”¹çš„åœ°åŒºï¼ˆåˆ—æ ‡é¢˜ï¼‰",
                        interactionMode === 'select-regime-a' && h('span', null, "å·²é€‰åœ°åŒº ", h('span', { className: "text-white px-1 bg-amber-800 rounded" }, data.names[targetRegion]), "ã€‚è¯·ç‚¹å‡»è¦ç§»åŠ¨çš„æ”¿æƒ (A)"),
                        interactionMode === 'select-regime-b' && h('span', null, "å·²é€‰ ", h('span', { className: "text-white px-1 bg-amber-800 rounded" }, moveRegimeA.split('|')[0]), "ã€‚è¯·ç‚¹å‡»ç›®æ ‡é”šç‚¹æ”¿æƒ (B)"),
                        interactionMode === 'confirm-move' && scoreComparison && h('span', { className: "flex items-center gap-2" },
                            h('span', null, "å°† ", h('strong', { className: "text-white" }, moveRegimeA.split('|')[0]), " ç§»è‡³ ", h('strong', { className: "text-white" }, moveRegimeB.split('|')[0]), " ä¹‹å‰ã€‚"),
                            h('span', { className: "text-slate-400" }, "|"),
                            h('span', null, "åˆ†æ•°å˜åŒ–: ", scoreComparison.old.toLocaleString(), " â†’ ", h('span', { className: `${scoreComparison.new > scoreComparison.old ? 'text-emerald-400' : (scoreComparison.new < scoreComparison.old ? 'text-rose-400' : 'text-white')} font-bold` }, scoreComparison.new.toLocaleString()))
                        )
                    ),
                    interactionMode === 'confirm-move' ? h('div', { className: "flex gap-2" },
                        h('button', { onClick: cancelMove, className: "px-3 py-1 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded text-xs border border-slate-500" }, "âŒ å–æ¶ˆ"),
                        h('button', { onClick: confirmMove, className: "px-3 py-1 bg-emerald-600 hover:bg-emerald-500 text-white rounded text-xs font-bold shadow-lg border border-emerald-400" }, "âœ… ç¡®è®¤ä¿®æ”¹")
                    ) : h('button', { onClick: resetManualMode, className: "text-amber-400/60 hover:text-amber-200 text-xs" }, "é€€å‡º")
                ),
                // 3. Matrix Viewport
                h('div', { className: "flex-1 overflow-hidden relative flex flex-col pt-[1px]" },
                    data ? h('div', {
                        className: "matrix-viewport",
                        onScroll: (e) => setScrollTop(e.target.scrollTop),
                        ref: (el) => { if (el) { gridRef.current = el; if (el.clientHeight !== viewportH) setViewportH(el.clientHeight); } }
                    },
                        h('div', { style: { height: totalH, width: 60 + colOrder.length * CONFIG.COL_WIDTH, position: 'relative' } },
                            // Header Row
                            h('div', { className: "header-row", style: { width: '100%', minWidth: 'max-content' } },
                                h('div', {
                                    className: "header-cell sticky left-0 z-[60] w-[60px] bg-slate-800 border-r border-slate-600 text-slate-400 cursor-pointer hover:bg-slate-700 hover:text-emerald-400 transition-colors flex justify-center items-center",
                                    onClick: handleFlip
                                }, "â‡„"),
                                colOrder.map((id, index) => {
                                    const isSelected = targetRegion === id;
                                    const isModeSelectRegion = interactionMode === 'select-region';
                                    return h('div', {
                                        key: id,
                                        className: `header-cell ${draggedCol === index ? 'opacity-50 dashed-border' : ''} ${isSelected ? 'bg-amber-800/80 text-amber-100 ring-2 ring-amber-500 z-50' : ''} ${isModeSelectRegion ? 'cursor-pointer hover:bg-amber-900/50 ring-1 ring-amber-500/30' : 'cursor-move hover:bg-slate-700'} transition-all select-none`,
                                        style: { width: CONFIG.COL_WIDTH },
                                        title: data.names[id] || id,
                                        draggable: interactionMode === 'idle',
                                        onDragStart: (e) => handleDragStart(e, index),
                                        onDragOver: (e) => handleDragOver(e, index),
                                        onDrop: (e) => handleDrop(e, index),
                                        onClick: () => handleHeaderClick(index)
                                    }, data.names[id] || id);
                                })
                            ),
                            // Data Rows (Virtualized)
                            visibleYears.map(year => h('div', { key: year, className: "data-row", style: { top: (year - CONFIG.MIN_YEAR) * CONFIG.ROW_HEIGHT + 36, height: CONFIG.ROW_HEIGHT } },
                                h('div', { className: "year-col-container flex items-center justify-center h-full" },
                                    h('div', { className: "font-mono text-[10px] text-slate-500" }, year)
                                ),
                                colOrder.map(id => {
                                    const regimes = cellLayout[id]?.[year] || [];
                                    return h('div', { key: id, className: "data-cell", style: { width: CONFIG.COL_WIDTH } },
                                        regimes.map(r => {
                                            const isSelectedA = moveRegimeA === r;
                                            const isSelectedB = moveRegimeB === r;
                                            const isInteractive = (interactionMode === 'select-regime-a' && targetRegion === id) || (interactionMode === 'select-regime-b' && targetRegion === id);
                                            return h('div', {
                                                key: r,
                                                className: `regime-block ${isSelectedA ? 'ring-2 ring-amber-400 z-10 scale-105' : ''} ${isSelectedB ? 'ring-2 ring-blue-400 z-10' : ''} ${isInteractive ? 'cursor-pointer hover:opacity-80' : ''}`,
                                                style: { backgroundColor: calcColor(r.split('|')[1] || data.codes[r.split('|')[0]] || r) },
                                                title: r,
                                                onClick: (e) => { e.stopPropagation(); handleRegimeClick(r, id); }
                                            }, r.split('|')[0]);
                                        })
                                    );
                                })
                            ))
                        )
                    ) : h('div', { className: "flex-1 flex flex-col items-center justify-center text-slate-600 bg-slate-950" },
                        h('p', { className: "text-sm font-medium" }, "è¯·å¯¼å…¥ CSV æ•°æ®æ–‡ä»¶ / JSON æ¨¡å…·")
                    )
                ),
                // 4. Log Panel
                h('div', { className: "h-32 bg-slate-950 border-t border-slate-800 flex flex-col font-mono text-[10px] shadow-inner-lg z-50" },
                    h('div', { className: "px-4 py-1 bg-slate-900 border-b border-slate-800 text-slate-500 flex justify-between items-center" },
                        h('div', { className: "flex items-center gap-3" },
                            h('span', null, "CONSOLE LOG"),
                            h('button', {
                                onClick: () => navigator.clipboard.writeText(logs.join('\n')),
                                className: "text-[9px] px-1.5 py-0.5 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded text-slate-400 hover:text-white transition-colors cursor-pointer",
                                title: "Copy full logs"
                            }, "COPY")
                        ),
                        h('span', { className: status === 'ranking' || status === 'layout' ? 'text-blue-400 animate-pulse' : 'text-emerald-500' }, status === 'idle' ? 'IDLE' : status.toUpperCase())
                    ),
                    h('div', { className: "flex-1 overflow-y-auto p-2 space-y-1 text-slate-400" },
                        logs.map((l, i) => h('div', { key: i, ref: i === logs.length - 1 ? logEndRef : null }, l))
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(h(App));
    </script>
</body>

</html>