<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout Optimizer - v09.00</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

    <style type="text/tailwindcss">
        body {
            background-color: #0f172a;
            color: #f8fafc;
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; border: 1px solid #0f172a; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }

        .matrix-viewport {
            position: relative; width: 100%; height: 100%; overflow: auto; background: #020617; isolation: isolate; 
        }

        .header-row {
            position: sticky; top: 0; z-index: 50; display: flex; height: 36px; background: #1e293b; border-bottom: 1px solid #475569;
        }

        .header-cell {
            flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #cbd5e1; border-right: 1px solid #334155; cursor: grab; background: #1e293b; padding: 0 4px; text-align: center; line-height: 1.2; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
        }

        .year-col-container {
            position: sticky; left: 0; z-index: 40; width: 60px; background: #0f172a; border-right: 1px solid #334155;
        }

        .data-row {
            position: absolute; display: flex; width: 100%; border-bottom: 1px solid #1e293b;
        }

        .data-cell {
            flex-shrink: 0; display: flex; flex-direction: row; padding: 1px; gap: 1px; border-right: 1px solid rgba(255,255,255,0.05); overflow: hidden;
        }

        .regime-block {
            flex: 1; height: 100%; border-radius: 1px; font-size: 10px; font-weight: 500; display: flex; align-items: center; justify-content: center; white-space: nowrap; overflow: hidden; text-shadow: 0 1px 2px rgba(0,0,0,0.9); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1); cursor: help; color: #fff; transition: transform 0.1s;
        }
        .regime-block:hover { transform: scale(1.1); z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.6); }

        .btn { @apply px-3 py-1.5 rounded text-xs font-bold transition-all flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-sm; }
        .btn-primary { @apply bg-blue-600 hover:bg-blue-500 text-white shadow-blue-900/20; }
        .btn-accent { @apply bg-indigo-600 hover:bg-indigo-500 text-white shadow-indigo-900/20; }
        .btn-success { @apply bg-emerald-600 hover:bg-emerald-500 text-white shadow-emerald-900/20; }
        .btn-purple { @apply bg-purple-600 hover:bg-purple-500 text-white shadow-purple-900/20; }
        .btn-danger { @apply bg-rose-600 hover:bg-rose-500 text-white shadow-rose-900/20; }
        .btn-dark { @apply bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600; }
    </style>
</head>

<body>
    <div id="root" class="h-screen w-screen flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        const CONFIG = {
            MIN_YEAR: -2070,
            MAX_YEAR: 2025,
            ROW_HEIGHT: 24,
            COL_WIDTH: 100
        };

        // [New] ç§»æ¤è‡ª panorama.html çš„é«˜çº§é¢œè‰²é€»è¾‘
        const calcColor = (code) => {
            if (!code) return '#334155';
            const strCode = String(code);
            let originDigit = '1';
            let eraDigit = 4;
            if (/^\d/.test(strCode)) {
                originDigit = strCode.charAt(0);
                eraDigit = 5;
            } else {
                originDigit = strCode.length >= 3 ? strCode.charAt(2) : '1';
                eraDigit = parseInt(strCode.length >= 2 ? strCode.charAt(1) : '4') || 4;
            }
            const hueMap = { '1': 0, '5': 35, '6': 80, '2': 125, '3': 170, '7': 210, '8': 245, '4': 280, '9': 320, '0': 0 };
            const baseHue = hueMap[originDigit] !== undefined ? hueMap[originDigit] : 0;

            let hash = 0;
            for (let i = 0; i < strCode.length; i++) hash = strCode.charCodeAt(i) + ((hash << 5) - hash);
            hash = Math.abs(hash);

            const hueShift = (hash % 2 === 0) ? -6 : 6;
            let h = baseHue + hueShift;
            let l = 30 + (eraDigit * 5.0);
            l = Math.max(35, Math.min(65, l)); // ç¨å¾®æäº®ä¸€ç‚¹é€‚åº”æ·±è‰²èƒŒæ™¯
            const baseSat = 45 + (eraDigit * 5);
            const satJitter = (hash % 16) - 8;
            let s = Math.max(30, Math.min(95, baseSat + satJitter));

            if (originDigit === '0') return `hsl(0, 0%, ${l}%)`;
            if (originDigit === '6') { l -= 10; s -= 5; }

            return `hsl(${h}, ${s}%, ${l}%)`;
        };

        // [New] ç®€æ˜“ Hash å‡½æ•°
        const simpleHash = (str) => { let h = 5381; for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i); return (h >>> 0).toString(36); };

        // --- ç®—æ³• 1: ç©¶æ TSP åˆ—æ’åº (å¸¦é˜²é€€åŒ–æœºåˆ¶) ---
        class AdvancedColumnSorter {
            constructor(ids, grid, names, onLog) {
                this.ids = ids; this.grid = grid; this.names = names; this.onLog = onLog; this.matrix = null;
            }
            async precompute() {
                const n = this.ids.length;
                this.matrix = Array(n).fill(0).map(() => Array(n).fill(0));
                let ops = 0;
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        let score = 0;
                        const rA = this.ids[i], rB = this.ids[j];
                        for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                            const setA = this.grid[rA]?.[y];
                            const setB = this.grid[rB]?.[y];
                            if (setA && setB) {
                                let common = 0;
                                setA.forEach(r => { if (setB.has(r)) common++; });
                                if (common > 0) {
                                    // [Optimized] å¤æ‚åº¦æƒ©ç½šï¼šå¦‚æœä¸¤åˆ—åœ¨æŸå¹´éƒ½æ˜¯å¤šæ”¿æƒå¹¶ç«‹ (High Entropy)ï¼Œåˆ™é™ä½å…¶äº²å’Œåº¦æƒé‡
                                    // å› ä¸ºå¤šæ”¿æƒå¹¶ç«‹æ—¶ï¼Œå†…éƒ¨æ’åºå¾ˆéš¾ä¿è¯ä¸¤åˆ—çš„å…±æœ‰æ”¿æƒä¸€å®šèƒ½ç´§é‚»ï¼Œæ•…å…¶è¿æ¥ä»·å€¼æ‰“æŠ˜
                                    const nA = setA.size;
                                    const nB = setB.size;
                                    const complexityFactor = 2.0 / (nA + nB); // 1vs1=1.0, 1vs2=0.66, 2vs2=0.5
                                    score += (common * 10 * complexityFactor);
                                }
                            }
                        }
                        this.matrix[i][j] = this.matrix[j][i] = score;
                        ops++; if (ops % 500 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                }
            }
            getPathScore(path) {
                let score = 0;
                const n = path.length;
                for (let i = 0; i < n - 1; i++) score += this.matrix[path[i]][path[i + 1]];
                return score;
            }
            async greedyInit() {
                const n = this.ids.length;
                let bestPath = null, bestScore = -1;
                // æš´åŠ›å°è¯•ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹
                for (let startNode = 0; startNode < n; startNode++) {
                    const visited = new Set([startNode]);
                    const path = [startNode];
                    let current = startNode;
                    while (path.length < n) {
                        let bestNext = -1, maxSim = -1;
                        for (let candidate = 0; candidate < n; candidate++) {
                            if (!visited.has(candidate)) {
                                const sim = this.matrix[current][candidate];
                                if (sim > maxSim) { maxSim = sim; bestNext = candidate; }
                            }
                        }
                        if (bestNext === -1) for (let k = 0; k < n; k++) if (!visited.has(k)) { bestNext = k; break; }
                        visited.add(bestNext); path.push(bestNext); current = bestNext;
                    }
                    const s = this.getPathScore(path);
                    if (s > bestScore) { bestScore = s; bestPath = path; }
                    if (startNode % 5 === 0) await new Promise(r => setTimeout(r, 0));
                }
                return { path: bestPath, score: bestScore };
            }
            // [Manual Action Required] Replace the entire run() method with this:
            async run(iterations = 50000000, updateCallback, stopRef) {
                this.onLog("TSP: å¤šç‚¹è´ªå©ªåˆå§‹åŒ–...");
                const init = await this.greedyInit();
                let currentPath = [...init.path];
                let currentScore = init.score;
                let bestPath = [...currentPath];
                let bestScore = currentScore;
                // SA å‚æ•°è°ƒä¼˜ï¼šæå¤§è¿­ä»£æ¬¡æ•° + ææ…¢å†·å´
                let temp = 5000;
                const cooling = 0.99999;
                let lastImprovement = 0;
                const n = this.ids.length;

                // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘ now() è°ƒç”¨
                let lastYieldTime = Date.now();
                for (let i = 0; i < iterations; i++) {
                    if (stopRef.current) break;
                    // ç­–ç•¥é€‰æ‹©: 80% 2-Opt (åŒºé—´ç¿»è½¬), 10% Swap (ç‚¹äº¤æ¢), 10% Insert (ç‚¹æ’å…¥)
                    const moveType = Math.random();
                    let newPath = [...currentPath];
                    let delta = 0;

                    if (moveType < 0.8) {
                        // === 2-Opt (Reverse Segment) ===
                        const idx1 = Math.floor(Math.random() * n);
                        const idx2 = Math.floor(Math.random() * n);
                        const s = Math.min(idx1, idx2), e = Math.max(idx1, idx2);
                        if (s === e) continue;
                        const nA = s > 0 ? currentPath[s - 1] : -1, nB = currentPath[s];
                        const nC = currentPath[e], nD = e < n - 1 ? currentPath[e + 1] : -1;
                        let oldSim = 0; if (nA !== -1) oldSim += this.matrix[nA][nB]; if (nD !== -1) oldSim += this.matrix[nC][nD];
                        let newSim = 0; if (nA !== -1) newSim += this.matrix[nA][nC]; if (nD !== -1) newSim += this.matrix[nB][nD];
                        delta = newSim - oldSim;
                        if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                            let l = s, r = e;
                            while (l < r) { [currentPath[l], currentPath[r]] = [currentPath[r], currentPath[l]]; l++; r--; }
                            currentScore += delta;
                        }
                    } else if (moveType < 0.9) {
                        // === Swap (Two nodes) ===
                        const idx1 = Math.floor(Math.random() * n);
                        const idx2 = Math.floor(Math.random() * n);
                        if (idx1 === idx2) continue;

                        [newPath[idx1], newPath[idx2]] = [newPath[idx2], newPath[idx1]];
                        const newScore = this.getPathScore(newPath); // å…¨é‡é‡ç®—
                        delta = newScore - currentScore;
                        if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                            currentPath = newPath;
                            currentScore = newScore;
                        }
                    } else {
                        // === Insert (Move one node to another place) ===
                        const from = Math.floor(Math.random() * n);
                        const to = Math.floor(Math.random() * n);
                        if (from === to) continue;
                        const [node] = newPath.splice(from, 1);
                        newPath.splice(to, 0, node);
                        const newScore = this.getPathScore(newPath); // å…¨é‡é‡ç®—
                        delta = newScore - currentScore;
                        if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                            currentPath = newPath;
                            currentScore = newScore;
                        }
                    }
                    // æ›´æ–°æœ€ä¼˜è§£
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestPath = [...currentPath];
                        lastImprovement = i;
                        // èŠ‚æµå›è°ƒï¼Œä¸”åªåœ¨çœŸæ­£çªç ´æ—¶å°½é‡æ›´æ–°
                        if (updateCallback && (i % 500 === 0)) updateCallback(null, bestScore);
                    }
                    // å†·å´ä¸å›ç« (Reheating)
                    if (i % 1000 === 0) temp *= cooling;

                    // å¦‚æœ 1,000,000 æ¬¡æ²¡æœ‰æå‡ï¼Œä¸”æ¸©åº¦è¿‡ä½ï¼Œåˆ™å›ç«
                    if (i - lastImprovement > 1000000 && temp < 50) {
                        temp = 2000 + Math.random() * 1000; // çŒ›ç«åŠ çƒ­
                        currentPath = [...bestPath]; // å›é€€åˆ°æœ€ä¼˜
                        currentScore = bestScore;
                        lastImprovement = i;
                        this.onLog(`[Reheat] æ·±åº¦éœ‡è¡... (Iter ${i})`);
                    }
                    // æ‰¹é‡ Yieldï¼Œä¿è¯ UI å“åº”ä½†ä¸è¿‡åº¦æ‹–æ…¢ (æ¯ 50ms ä¸€æ¬¡)
                    if (i % 10000 === 0) {
                        const now = Date.now();
                        if (now - lastYieldTime > 50) { // Time Slice
                            this.onLog(`TSP Iter ${(i / 1000000).toFixed(2)}M: Temp ${temp.toFixed(1)} | Best ${bestScore}`);
                            if (updateCallback) updateCallback(null, bestScore);
                            await new Promise(r => setTimeout(r, 0));
                            lastYieldTime = Date.now();
                        }
                    }
                }
                // Post-Processing: å¼ºåˆ¶åœ°ç†å®šå‘ (åŒ—æµ·é“/æ—¥æœ¬ -> å³ä¾§)
                // ç›¸æ¯”äºå¹¶åœ¨ Score é‡ŒåŠ  Biasï¼Œäº‹åç¿»è½¬æ›´ç¨³å¥
                if (this.names) {
                    const eastKeywords = ['hokkaido', 'åŒ—æµ·é“', 'japan', 'æ—¥æœ¬', 'nihon'];
                    let eastIndexSum = 0;
                    let eastCount = 0;

                    bestPath.forEach((idx, pos) => {
                        const id = this.ids[idx];
                        const name = (this.names[id] || id).toLowerCase();
                        if (eastKeywords.some(k => name.includes(k))) {
                            eastIndexSum += pos;
                            eastCount++;
                        }
                    });

                    if (eastCount > 0) {
                        const avgPos = eastIndexSum / eastCount;
                        if (avgPos < n / 2) {
                            this.onLog(`åœ°ç†ä¿®æ­£: æ£€æµ‹åˆ°ä¸œæ–¹æ¿å—åœ¨å·¦ä¾§ (AvgPos ${avgPos.toFixed(1)} < ${n / 2})ï¼Œæ‰§è¡Œè‡ªåŠ¨ç¿»è½¬...`);
                            bestPath.reverse();
                        } else {
                            this.onLog(`åœ°ç†ä¿®æ­£: ä¸œæ–¹æ¿å—ä½ç½®æ­£ç¡® (AvgPos ${avgPos.toFixed(1)})ã€‚`);
                        }
                    }
                }

                return { path: bestPath.map(idx => this.ids[idx]), score: bestScore };
            }
        }

        // --- ç®—æ³• 2: å…¨å±€ä¸»åºä¼˜åŒ–å™¨ (å« Stop åŠŸèƒ½) ---
        class GlobalSequenceOptimizer {
            constructor(colOrder, grid, onLog) {
                this.cols = colOrder;
                this.grid = grid;
                this.onLog = onLog;
                this.masterSeqs = {};
                this.activeSets = {};
            }

            init(existingMasterSeqs = null) {
                this.cols.forEach(id => {
                    this.activeSets[id] = {};
                    const regimeFirstSeen = {};
                    const regimes = new Set();

                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.grid[id]?.[y];
                        if (set) {
                            this.activeSets[id][y] = set;
                            set.forEach(r => {
                                regimes.add(r);
                                if (!regimeFirstSeen[r]) regimeFirstSeen[r] = y;
                            });
                        }
                    }

                    // å¦‚æœæœ‰ç°æˆçš„ä¸»åºï¼Œå°½é‡æ²¿ç”¨
                    if (existingMasterSeqs && existingMasterSeqs[id]) {
                        // è¿‡æ»¤æ‰å½“å‰æ•°æ®ä¸­ä¸å­˜åœ¨çš„ï¼Œè¡¥å……æ–°çš„
                        const oldSeq = existingMasterSeqs[id];
                        const newSeq = oldSeq.map(r => {
                            // [Migration] å°è¯•è¿ç§»æ—§çš„ ID æ ¼å¼ (- -> |)
                            if (regimes.has(r)) return r;
                            const migrated = r.replace('-', '|');
                            if (regimes.has(migrated)) return migrated;
                            return null;
                        }).filter(r => r !== null);

                        const newSet = new Set(newSeq);
                        const newItems = Array.from(regimes).filter(r => !newSet.has(r));
                        this.masterSeqs[id] = [...newSeq, ...newItems];
                    } else {
                        // [Optimized] æ”¹ä¸ºéšæœºåˆå§‹åŒ– (Random Shuffle)ï¼Œæ¶ˆé™¤â€œå…ˆæ¥ååˆ°â€çš„æ—¶é—´åè§
                        // ç»“åˆ High Temp SAï¼Œè¿™èƒ½è®©ç®—æ³•æ¢ç´¢åˆ° [å®‹, å¾] è¿™ç§éæ—¶é—´åºä½†ç»“æ„æ›´ä¼˜çš„è§£
                        this.masterSeqs[id] = Array.from(regimes).sort(() => Math.random() - 0.5);
                    }
                });
            }

            calculateGlobalScore(currentSeqs) {
                let score = 0;
                for (let c = 0; c < this.cols.length - 1; c++) {
                    const idA = this.cols[c];
                    const idB = this.cols[c + 1];
                    const seqA = currentSeqs[idA];
                    const seqB = currentSeqs[idB];

                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y += 5) {
                        const setA = this.activeSets[idA][y];
                        const setB = this.activeSets[idB][y];
                        if (setA && setB) {
                            const layoutA = seqA.filter(r => setA.has(r));
                            const layoutB = seqB.filter(r => setB.has(r));
                            if (layoutA.length > 0 && layoutB.length > 0) {
                                // [Optimized] å¤§å¹…å¢åŠ å¯¹é½å¥–åŠ±ï¼Œå¼ºè¿«ç®—æ³•å¯»æ‰¾èƒ½å¤Ÿè¿é€šçš„åºåˆ— (ä¾‹å¦‚æ‰“ç ´æ—¶é—´åº [å¾,å®‹,å´] -> [å®‹,å¾,å´])
                                if (layoutA[layoutA.length - 1] === layoutB[0]) score += 1000;
                            }
                        }
                    }
                }
                return score;
            }

            async run(iterations = 500000, updateCallback, stopRef, existingMasterSeqs = null) {
                this.init(existingMasterSeqs);
                this.onLog("SeqOpt: ä¸»åºåˆå§‹åŒ–å®Œæˆï¼Œå¼€å§‹å…¨å±€ä¼˜åŒ– (High Temp)...");

                let currentSeqs = JSON.parse(JSON.stringify(this.masterSeqs));
                let currentScore = this.calculateGlobalScore(currentSeqs);
                let bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                let bestScore = currentScore;

                // [Optimized] å‡æ¸©çŒ›ç«ï¼šå…è®¸æ›´å¤§çš„ç»“æ„æ€§å˜åŠ¨
                let temp = 500.0;
                const cooling = 0.9995;

                for (let i = 0; i < iterations; i++) {
                    if (stopRef.current) break;

                    const randColIdx = Math.floor(Math.random() * this.cols.length);
                    const colId = this.cols[randColIdx];
                    const seq = currentSeqs[colId];
                    if (seq.length < 2) continue;

                    const idx1 = Math.floor(Math.random() * seq.length);
                    const idx2 = Math.floor(Math.random() * seq.length);
                    if (idx1 === idx2) continue;

                    const r1 = seq[idx1];
                    const r2 = seq[idx2];
                    seq[idx1] = r2;
                    seq[idx2] = r1;

                    const newScore = this.calculateGlobalScore(currentSeqs);
                    const delta = newScore - currentScore;

                    if (delta > 0 || Math.random() < Math.exp(delta / temp)) {
                        currentScore = newScore;
                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestSeqs = JSON.parse(JSON.stringify(currentSeqs));
                        }
                    } else {
                        seq[idx1] = r1;
                        seq[idx2] = r2;
                    }

                    if (i % 500 === 0) temp *= cooling;

                    if (i % 5000 === 0) {
                        this.onLog(`SeqOpt Iter ${i}: Temp ${temp.toFixed(1)} | Score ${bestScore}`);
                        if (updateCallback) {
                            const layout = this.generateLayout(bestSeqs);
                            updateCallback(layout, bestScore);
                        }
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                this.masterSeqs = bestSeqs; // æ›´æ–°å†…éƒ¨çŠ¶æ€
                return { layout: this.generateLayout(bestSeqs), score: bestScore };
            }

            generateLayout(seqs) {
                const layout = {};
                this.cols.forEach(id => {
                    layout[id] = {};
                    const master = seqs[id];
                    for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                        const set = this.activeSets[id][y];
                        if (set) layout[id][y] = master.filter(r => set.has(r));
                        else layout[id][y] = [];
                    }
                });
                return layout;
            }
        }

        // --- App ---
        function App() {
            const [data, setData] = useState(null);
            const [colOrder, setColOrder] = useState([]);
            const [cellLayout, setCellLayout] = useState({});
            const [masterSeqs, setMasterSeqs] = useState(null); // å­˜å‚¨ä¸»åºåˆ—è¡¨

            const [status, setStatus] = useState('idle');
            const [tspBestScore, setTspBestScore] = useState(0); // è®°å½• TSP å†å²æœ€é«˜åˆ†
            const [logs, setLogs] = useState(['ç­‰å¾… CSV...']);
            const [isFlipped, setIsFlipped] = useState(false); // [New] ç¿»è½¬çŠ¶æ€
            const [layoutScore, setLayoutScore] = useState(0); // [New] å¸ƒå±€åˆ†æ•°
            const [draggedCol, setDraggedCol] = useState(null); // [New] æ‹–æ‹½åˆ—ç´¢å¼•
            const [dataHash, setDataHash] = useState(null); // [New] æ•°æ®æŒ‡çº¹

            const fileInputRef = useRef();
            const logEndRef = useRef();
            const gridRef = useRef();
            const stopRef = useRef(false);
            const [scrollTop, setScrollTop] = useState(0);
            const [viewportH, setViewportH] = useState(800);

            const addLog = (msg) => setLogs(prev => [...prev.slice(-49), `> ${msg}`]);
            useEffect(() => { if (logEndRef.current) logEndRef.current.scrollIntoView({ behavior: "smooth" }); }, [logs]);

            // [New] æ ¸å¿ƒæ•°æ®è§£æ (å¤ç”¨é€»è¾‘)
            // preloadedColOrder: ä» layout.json é¢„åŠ è½½çš„é¡ºåºï¼Œç”¨äºè§£å†³ React State å¼‚æ­¥æ›´æ–°å¯¼è‡´çš„â€œæ¢å¤å¤±è´¥â€é—®é¢˜
            // preloadedMasterSeqs: [New] é¢„åŠ è½½çš„ä¸»åºæ¨¡å…·
            // [New] Quick Score Calculation
            const calculateQuickScores = async (gridData, orderData, seqsData) => {
                if (!gridData || !orderData) return;
                try {
                    const sorter = new AdvancedColumnSorter(orderData, gridData, {}, () => { });
                    await sorter.precompute(); // Recalculate affinity matrix
                    const path = orderData.map((_, i) => i);
                    const tScore = sorter.getPathScore(path);
                    setTspBestScore(Math.floor(tScore));
                } catch (e) { console.warn("Quick TSP Calc failed", e); }

                if (seqsData) {
                    try {
                        const optimizer = new GlobalSequenceOptimizer(orderData, gridData, () => { });
                        optimizer.init(seqsData);
                        const lScore = optimizer.calculateGlobalScore(seqsData);
                        setLayoutScore(Math.floor(lScore));
                    } catch (e) { console.warn("Quick LAY Calc failed", e); }
                } else {
                    setLayoutScore(0);
                }
            };

            const parseContent = (content, isJSON, preloadedColOrder = null, preloadedMasterSeqs = null) => {
                if (isJSON) {
                    try {
                        const json = JSON.parse(content);
                        if (json.colOrder) { setColOrder(json.colOrder); addLog("å·²æ¢å¤åˆ—é¡ºåºæ¨¡å…·ã€‚"); }
                        if (json.masterSeqs) { setMasterSeqs(json.masterSeqs); addLog("å·²æ¢å¤ä¸»åºåˆ—è¡¨æ¨¡å…·ã€‚"); }
                        return json; // è¿”å›ä¾›é“¾å¼è°ƒç”¨
                    } catch (err) { alert("JSON Error"); }
                } else {
                    setDataHash(simpleHash(content)); // [New] è®¡ç®—æ•°æ® Hash
                    const lines = content.split(/\r?\n/).filter(l => l.trim());
                    const headers = lines[0].toLowerCase().split(',');
                    const findCol = (keys) => headers.findIndex(h => keys.some(k => h.includes(k)));
                    const idx = {
                        geoCode: findCol(['geo_code', 'region_code']),
                        geoName: findCol(['geo_name', 'region_name']),
                        start: findCol(['start']),
                        end: findCol(['end']),
                        regimeName: findCol(['regime_name', 'polity_name']),
                        regimeCode: findCol(['regime_code', 'polity_code'])
                    };
                    if (idx.geoName === -1) idx.geoName = idx.geoCode;
                    if (idx.regimeName === -1) idx.regimeName = idx.regimeCode;
                    if (idx.geoCode === -1 || idx.start === -1) { alert("CSV Error: Missing columns"); return; }

                    const regions = new Set();
                    const grid = {};
                    const regionNames = {};

                    for (let i = 1; i < lines.length; i++) {
                        const row = lines[i].split(',').map(s => s.trim().replace(/^"|"$/g, ''));
                        if (row.length < 4) continue;
                        const geoCode = row[idx.geoCode];
                        const geoName = row[idx.geoName] || geoCode;
                        const start = parseInt(row[idx.start]);
                        let end = row[idx.end];
                        end = (end === '' || end.toLowerCase().includes('present')) ? CONFIG.MAX_YEAR : parseInt(end);
                        const regimeName = row[idx.regimeName];
                        const regimeCode = row[idx.regimeCode] || regimeName; // è·å– Code

                        if (!geoCode || isNaN(start)) continue;
                        regions.add(geoCode);
                        regionNames[geoCode] = geoName;
                        // [New] å­˜å‚¨æ˜ å°„
                        if (!regionNames._codes) regionNames._codes = {};
                        regionNames._codes[regimeName] = regimeCode;

                        if (!grid[geoCode]) grid[geoCode] = {};
                        let loopEnd = (start === end) ? start : end - 1;
                        for (let y = start; y <= loopEnd; y++) {
                            if (y >= CONFIG.MIN_YEAR && y <= CONFIG.MAX_YEAR) {
                                if (!grid[geoCode][y]) grid[geoCode][y] = new Set();
                                // [Fix] ID ç­–ç•¥ï¼šName + Code (ç¡®ä¿è·¨æ—¶é—´æ®µçš„æ”¿æƒåŒä¸€æ€§)
                                grid[geoCode][y].add(regimeName + "|" + regimeCode);
                            }
                        }
                    }

                    const regionList = Array.from(regions).sort();
                    // è¿™é‡Œåå­—å¤ç”¨ regionNames å¯¹è±¡å­˜ code mapï¼Œç¨å¾®æœ‰ç‚¹æ‰€è°“ï¼Œä½†å¯ä»¥ç”¨ ._codes è®¿é—®
                    setData({ regions: regionList, grid, names: regionNames, codes: regionNames._codes });

                    // å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„é¢„åŠ è½½é¡ºåºï¼Œå¦åˆ™æ‰ç”¨ State
                    const currentOrder = preloadedColOrder || colOrder;
                    // [New] å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ä¸»åºæ¨¡å…·ï¼Œå¦åˆ™æ‰ç”¨ State
                    const currentMasterSeqs = preloadedMasterSeqs || masterSeqs;

                    const newRegionSet = new Set(regionList);
                    const oldRegionSet = new Set(currentOrder);

                    // æ ¡éªŒé€»è¾‘ï¼šåªæœ‰å½“ä¸¤ä¸ªé›†åˆå…ƒç´ å®Œå…¨ä¸€è‡´æ—¶ï¼Œæ‰ä¿ç•™å¸ƒå±€
                    const isSameRegions = currentOrder.length > 0 &&
                        newRegionSet.size === oldRegionSet.size &&
                        [...newRegionSet].every(x => oldRegionSet.has(x));

                    if (isSameRegions) {
                        addLog("æ£€æµ‹åˆ°åœ°åŒºä¸€è‡´ï¼Œä¿ç•™ç°æœ‰åˆ—é¡ºåºæ¨¡å…·ã€‚");
                        // æ—¢ç„¶ä¸€è‡´ï¼Œå°±å¼ºåˆ¶åº”ç”¨è¿™ä¸ªé¡ºåº (å› ä¸ºå¦‚æœç”¨äº† preloadedColOrderï¼Œstate å¯èƒ½è¿˜æ²¡æ›´)
                        if (preloadedColOrder) setColOrder(preloadedColOrder);

                        if (currentMasterSeqs) {
                            addLog("å°è¯•åº”ç”¨ç°æœ‰ä¸»åºåˆ—è¡¨åˆ°æ–°æ•°æ®...");
                            const sorter = new GlobalSequenceOptimizer(currentOrder, grid, () => { });
                            sorter.masterSeqs = currentMasterSeqs;
                            sorter.init(currentMasterSeqs);
                            setMasterSeqs(sorter.masterSeqs); // [Fix] æ›´æ–° State ä¸ºè¿ç§»åçš„æ–°æ•°æ® (ç¡®ä¿ SaveToDB æ­£ç¡®)
                            const newLayout = sorter.generateLayout(sorter.masterSeqs);
                            setCellLayout(newLayout);
                        } else {
                            const initLayout = {};
                            currentOrder.forEach(id => {
                                initLayout[id] = {};
                                for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                                    const s = grid[id][y];
                                    initLayout[id][y] = s ? Array.from(s).sort() : [];
                                }
                            });
                            setCellLayout(initLayout);
                        }
                    } else {
                        addLog("åœ°åŒºæ¨¡å…·ä¸åŒ¹é… (æ•°é‡/IDå·®å¼‚)ï¼Œé‡ç½®å¸ƒå±€ã€‚");
                        setColOrder(regionList);
                        setMasterSeqs(null);
                        setTspBestScore(0);
                        const initLayout = {};
                        regionList.forEach(id => {
                            initLayout[id] = {};
                            for (let y = CONFIG.MIN_YEAR; y <= CONFIG.MAX_YEAR; y++) {
                                const s = grid[id][y];
                                initLayout[id][y] = s ? Array.from(s).sort() : [];
                            }
                        });
                        setCellLayout(initLayout);
                    }
                    const finalOrder = isSameRegions ? (preloadedColOrder || currentOrder) : regionList;
                    const finalSeqs = isSameRegions ? currentMasterSeqs : null;

                    // [New] Calc Scores
                    calculateQuickScores(grid, finalOrder, finalSeqs);

                    setStatus('ready');
                }
            };

            const handleFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => parseContent(evt.target.result, file.name.endsWith('.json'));
                reader.readAsText(file);
                e.target.value = '';
            };

            // [New] åŠ è½½è¿œç¨‹ CSV
            const loadRemoteCSV = async (url = null, preloadedColOrder = null, preloadedMasterSeqs = null) => {
                const GOOGLE_CSV = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSMSHMYH-_pI-2v9bqP-1Balz19zzjAW9QyykU5D1GsfnGVV4Xt-OwPjOlFKPwQL2rQ9EVGCgl7ikCs/pub?gid=0&single=true&output=csv";
                const LOCAL_CSV = "history_data.csv";

                let targetUrl = url || GOOGLE_CSV;
                addLog(`æ­£åœ¨å°è¯•åŠ è½½æ•°æ®: ${targetUrl}...`);

                const tryFetch = async (u) => {
                    // æ·»åŠ æ—¶é—´æˆ³é˜²ç¼“å­˜
                    const fetchUrl = u + (u.includes('?') ? '&' : '?') + 't=' + Date.now();
                    const res = await fetch(fetchUrl);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.text();
                };

                try {
                    const text = await tryFetch(targetUrl);
                    addLog("æ•°æ®ä¸‹è½½å®Œæˆï¼Œå¼€å§‹è§£æ...");
                    parseContent(text, false, preloadedColOrder, preloadedMasterSeqs);
                } catch (e) {
                    addLog(`åŠ è½½å¤±è´¥ (${targetUrl}): ${e.message}`);
                    if (!url && targetUrl === GOOGLE_CSV) {
                        addLog(`æ­£åœ¨å°è¯•é™çº§åŠ è½½æœ¬åœ°æ–‡ä»¶: ${LOCAL_CSV}...`);
                        try {
                            const localText = await tryFetch(LOCAL_CSV);
                            addLog("æœ¬åœ°æ•°æ®ä¸‹è½½å®Œæˆï¼Œå¼€å§‹è§£æ...");
                            parseContent(localText, false, preloadedColOrder, preloadedMasterSeqs);
                        } catch (e2) {
                            addLog(`æœ¬åœ°åŠ è½½ä¹Ÿå¤±è´¥äº†: ${e2.message}`);
                            alert(`æ— æ³•åŠ è½½äº‘ç«¯æˆ–æœ¬åœ°æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æ‰‹åŠ¨ä¸Šä¼ ã€‚`);
                        }
                    } else {
                        alert(`æ— æ³•åŠ è½½ ${targetUrl}: ${e.message}`);
                    }
                }
            };

            // [New] è‡ªåŠ¨è¿è¡Œé€»è¾‘
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const csvUrl = params.get('csv');
                const autorun = params.get('autorun');

                let loadedLayout = null;

                // 1. æ€»æ˜¯å°è¯•åŠ è½½ layout.json ä»¥æ¢å¤æ¨¡å…· (Column Order)
                fetch('layout.json?t=' + Date.now())
                    .then(res => {
                        if (res.ok) return res.text();
                        throw new Error('No layout.json');
                    })
                    .then(text => {
                        addLog("å‘ç° layout.jsonï¼Œæ­£åœ¨æ¢å¤åˆ—é¡ºåºæ¨¡å…·...");
                        // è§£æå¹¶ä¿å­˜ï¼Œä½†ä¸ä¾èµ– State
                        loadedLayout = parseContent(text, true);
                    })
                    .catch(() => addLog("æœªæ‰¾åˆ° layout.json æˆ–åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤æˆ–æ–°ç”Ÿæˆçš„å¸ƒå±€ã€‚"))
                    .finally(() => {
                        const preloadedOrder = loadedLayout ? loadedLayout.colOrder : null;
                        const preloadedSeqs = loadedLayout ? loadedLayout.masterSeqs : null;

                        // 2. åŠ è½½æ•°æ® (CSV)
                        if (csvUrl) {
                            loadRemoteCSV(csvUrl, preloadedOrder, preloadedSeqs);
                        } else if (autorun === 'true') {
                            // ä¸ä¼ å‚ï¼Œä½¿ç”¨ loadRemoteCSV å†…éƒ¨å®šä¹‰çš„é»˜è®¤é€»è¾‘ (Google -> history_data.csv)
                            loadRemoteCSV(null, preloadedOrder, preloadedSeqs);
                        }
                    });
            }, []);

            const handleStop = () => {
                stopRef.current = true;
                addLog("ç”¨æˆ·è¯·æ±‚åœæ­¢...");
            };



            const runColumnOptimizer = async () => {
                if (!data) return;
                setStatus('ranking');
                stopRef.current = false;
                addLog("=== æ­¥éª¤ 1: é«˜çº§åˆ—æ’åº (TSP Deep Search) ===");
                addLog("æ­£åœ¨é¢„è®¡ç®—äº²å’Œåº¦çŸ©é˜µ (å«åœ°ç†åå¥½)...");
                const sorter = new AdvancedColumnSorter(data.regions, data.grid, data.names, addLog);
                await sorter.precompute();

                addLog("å¼€å§‹ SA + 2-Opt æ·±åº¦æœç´¢ (Max 50M Iters)...");
                // è¿è¡Œç®—æ³•ï¼Œä¼ å…¥å›è°ƒå®æ—¶æ›´æ–°åˆ†æ•° (ä»…å½“è¶…è¶Šå†å²æœ€é«˜åˆ†æ—¶æ›´æ–° UI)
                const result = await sorter.run(50000000, (_, score) => {
                    if (score > tspBestScore) setTspBestScore(score);
                }, stopRef);

                // é˜²é€€åŒ–æ£€æŸ¥
                if (result.score > tspBestScore) {
                    addLog(`æ–°çºªå½•ï¼Score: ${result.score} (æ—§: ${tspBestScore})`);
                    setTspBestScore(result.score);
                    setColOrder(result.path);
                } else {
                    addLog(`æœªå‘ç°æ›´ä¼˜è§£ (Current: ${result.score} vs Best: ${tspBestScore})ã€‚ä¿æŒåŸæ ·ã€‚`);
                }

                addLog("åˆ—æ’åºæ­¥éª¤ç»“æŸã€‚");
                setStatus('ready');
            };

            const runCellOptimizer = async () => {
                if (!data) return;
                setStatus('layout');
                stopRef.current = false;
                addLog("=== æ­¥éª¤ 2: å…¨å±€åºåˆ—å¯¹é½ (Master Sequence) ===");
                addLog("æ„å»ºæ°¸æ’æ”¿æƒåºåˆ—ï¼Œç¡®ä¿ç»å¯¹ç»§æ‰¿ä¸åå‘ä¼ æ’­...");

                const sorter = new GlobalSequenceOptimizer(colOrder, data.grid, addLog);

                // ä¼ å…¥å›è°ƒï¼ŒåŒæ—¶æ›´æ–° Layout å’Œ Score
                const result = await sorter.run(
                    500000,
                    (layout, score) => {
                        setCellLayout(layout);
                        if (score !== undefined) setLayoutScore(score);
                    },
                    stopRef,
                    null // [Fix] å¼ºåˆ¶ä¼ å…¥ nullï¼Œå¿½ç•¥å·²åŠ è½½çš„æ—§é¡ºåº (masterSeqs)ï¼Œç¡®ä¿æ¯æ¬¡éƒ½ä»éšæœºæ´—ç‰Œå¼€å§‹ï¼Œå½»åº•æ¶ˆé™¤å…ˆå…¥ä¸ºä¸»çš„åè§
                );

                setMasterSeqs(sorter.masterSeqs);
                setCellLayout(result.layout);
                setLayoutScore(result.score); // ä½¿ç”¨çœŸå®æœ€ç»ˆå¾—åˆ†
                addLog(`æ‰€æœ‰ä¼˜åŒ–å®Œæˆã€‚æœ€ç»ˆ LayScore: ${result.score}`);
                setStatus('done');
            };

            const handleFlip = () => {
                const newFlipped = !isFlipped;
                setIsFlipped(newFlipped);

                // 1. ç¿»è½¬åˆ—é¡ºåº
                setColOrder(prev => [...prev].reverse());

                // 2. ç¿»è½¬å•å…ƒæ ¼å†…é¡ºåº
                setCellLayout(prev => {
                    const next = {};
                    Object.keys(prev).forEach(id => {
                        next[id] = {};
                        Object.keys(prev[id]).forEach(y => {
                            next[id][y] = [...prev[id][y]].reverse();
                        });
                    });
                    return next;
                });
                addLog(`å¸ƒå±€å·²${newFlipped ? 'ç¿»è½¬' : 'è¿˜åŸ'} (North/South)`);
            };

            // [New] æ‹–æ‹½å¤„ç†
            const handleDragStart = (e, index) => {
                setDraggedCol(index);
                e.dataTransfer.effectAllowed = "move";
            };

            const handleDragOver = (e, index) => {
                e.preventDefault(); // å…è®¸ Drop
                if (draggedCol === null || draggedCol === index) return;
            };

            const handleDrop = (e, targetIndex) => {
                e.preventDefault();
                if (draggedCol === null || draggedCol === targetIndex) return;

                const newOrder = [...colOrder];
                const [removed] = newOrder.splice(draggedCol, 1);
                newOrder.splice(targetIndex, 0, removed);

                setColOrder(newOrder);
                setDraggedCol(null);
                addLog(`åˆ—å·²æ‰‹åŠ¨é‡æ’: ${data.names[removed] || removed} -> Position ${targetIndex}`);
            };

            const totalYears = CONFIG.MAX_YEAR - CONFIG.MIN_YEAR + 1;
            const totalH = totalYears * CONFIG.ROW_HEIGHT;
            const startIdx = Math.floor(scrollTop / CONFIG.ROW_HEIGHT);
            const endIdx = Math.min(totalYears, startIdx + Math.ceil(viewportH / CONFIG.ROW_HEIGHT) + 2);
            const visibleYears = [];
            for (let i = startIdx; i < endIdx; i++) visibleYears.push(CONFIG.MIN_YEAR + i);

            const exportJSON = () => {
                const out = {
                    colOrder,
                    layout: cellLayout,
                    names: data.names,
                    masterSeqs: masterSeqs, // å¯¼å‡ºæ¨¡å…·
                    tspScore: tspBestScore
                };
                const blob = new Blob([JSON.stringify(out)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'layout.json'; a.click();
            };

            const saveToDB = () => {
                if (!data) return;
                const out = {
                    colOrder,
                    layout: cellLayout,
                    names: data.names,
                    masterSeqs: masterSeqs,
                    tspScore: tspBestScore,
                    dataHash: dataHash, // [New] å­˜å‚¨æŒ‡çº¹
                    timestamp: Date.now()
                };

                // [Fix] Remove hardcoded version to allow opening any existing version
                const request = indexedDB.open("EastAsiaHistoryDB");

                request.onupgradeneeded = function (event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("layouts")) {
                        db.createObjectStore("layouts", { keyPath: "id" });
                    }
                };

                request.onsuccess = function (event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["layouts"], "readwrite");
                    const store = transaction.objectStore("layouts");

                    // ä½¿ç”¨å›ºå®š ID "current" ä»¥ä¾¿è¦†ç›–æ›´æ–°
                    const putReq = store.put({ id: "current", data: out });

                    putReq.onsuccess = function () {
                        addLog("å¸ƒå±€æ•°æ®å·²å†™å…¥ IndexedDB (EastAsiaHistoryDB/layouts/current)");
                        alert("æ•°æ®åº“å†™å…¥æˆåŠŸï¼(è¯·ç¡®ä¿å…¨æ™¯é¡µå·²å¼€å¯ DB è¯»å–åŠŸèƒ½)");
                    };

                    putReq.onerror = function (e) {
                        alert("IndexedDB å†™å…¥å¤±è´¥: " + e.target.error);
                    };
                };

                request.onerror = function (event) {
                    alert("æ— æ³•æ‰“å¼€ IndexedDB: " + event.target.errorCode);
                };
            };

            return (
                <div className="h-full flex flex-col bg-slate-900 text-slate-200">
                    <div className="glass-panel z-50 px-4 py-3 flex items-center justify-between shadow-xl relative backdrop-blur-md bg-opacity-90 border-b border-slate-700/50">
                        {/* Left: Branding & Inputs */}
                        <div className="flex items-center gap-4">
                            <div className="flex flex-col leading-tight">
                                <span className="font-bold text-lg text-slate-100 tracking-tight">Layout Optimizer</span>
                                <span className="text-[10px] text-purple-400 font-mono">v09.00 INTELLIGENT</span>
                            </div>
                            <div className="h-8 w-px bg-slate-700/50 mx-2"></div>

                            <div className="flex gap-2">
                                <label className="btn bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600/50 cursor-pointer">
                                    <span className="opacity-80">ğŸ“ å¯¼å…¥</span>
                                    <input type="file" accept=".csv,.json" onChange={handleFile} className="hidden" ref={fileInputRef} />
                                </label>
                                <button onClick={() => loadRemoteCSV()} className="btn bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600/50" title="Google Sheet / Local">
                                    â˜ï¸ äº‘ç«¯æ•°æ®
                                </button>
                            </div>
                        </div>

                        {/* Center: Controls */}
                        <div className="absolute left-1/2 -translate-x-1/2 flex gap-2">
                            {status !== 'ranking' && status !== 'layout' ? (
                                <>
                                    <button onClick={runColumnOptimizer} className="btn bg-emerald-700 hover:bg-emerald-600 text-white shadow-lg shadow-emerald-900/20 border border-emerald-600/50" disabled={!data}>
                                        1. ä¼˜åŒ–åˆ—åº
                                    </button>
                                    <button onClick={runCellOptimizer} className="btn bg-emerald-600 hover:bg-emerald-500 text-white shadow-lg shadow-emerald-900/20 border-0" disabled={!data}>
                                        2. ä¼˜åŒ–å¸ƒå±€
                                    </button>
                                </>
                            ) : (
                                <div className="flex gap-2 items-center bg-slate-800 rounded px-3 border border-slate-700">
                                    <svg className="w-4 h-4 animate-spin text-blue-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                                    <span className="text-xs font-mono text-blue-300">{status === 'ranking' ? 'TSP SOLVING...' : 'ALIGNING...'}</span>
                                    <button onClick={handleStop} className="ml-2 text-xs text-red-400 hover:text-red-300">STOP</button>
                                </div>
                            )}
                        </div>

                        {/* Right: Actions & Score */}
                        <div className="flex items-center gap-4">
                            {/* Score Board */}
                            <div className="flex flex-col items-end mr-2 font-mono text-[10px] text-slate-400 cursor-help" title="TSP: é‚»æ¥äº²å’ŒåŠ›æ€»åˆ† (è¶Šé«˜ä¸ä»…ä»£è¡¨ç›¸é‚»ç´§å¯†ï¼Œä¹Ÿä»£è¡¨å†å²è¿ç»­æ€§å¥½)&#010;LAY: å…¨å±€å¯¹é½ä¸€è‡´æ€§åˆ†æ•° (è¶Šé«˜ä»£è¡¨æ”¿æƒç»§æ‰¿å…³ç³»è¶Šé¡ºç•…)">
                                <div>TSP: <span className="text-emerald-400">{Math.round(tspBestScore).toLocaleString()}</span></div>
                                <div>LAY: <span className="text-blue-400">{layoutScore > 0 ? Math.round(layoutScore).toLocaleString() : '-'}</span></div>
                            </div>
                            <div className="h-8 w-px bg-slate-700/50"></div>

                            <div className="flex gap-2">
                                <button onClick={saveToDB} className="btn bg-teal-600 hover:bg-teal-500 text-white shadow-lg shadow-teal-900/20 border-0" disabled={!data} title="ä¿å­˜åˆ° IndexedDB ä¾›å…¨æ™¯å›¾è¯»å–">
                                    ğŸ’¾ å†™å…¥ DB
                                </button>
                                <button onClick={exportJSON} className="btn bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600" disabled={!data} title="å¯¼å‡º JSON æ¨¡å…·">
                                    ğŸ“¤ å¯¼å‡º
                                </button>
                                <a href="index.html" className="btn bg-slate-800 hover:bg-slate-700 text-slate-400 border border-slate-600/50" title="è¿”å›é¦–é¡µ">
                                    ğŸ 
                                </a>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 overflow-hidden relative flex flex-col pt-[1px]">
                        {data ? (
                            <div
                                className="matrix-viewport"
                                onScroll={(e) => setScrollTop(e.target.scrollTop)}
                                ref={(el) => { if (el) { gridRef.current = el; if (el.clientHeight !== viewportH) setViewportH(el.clientHeight); } }}
                            >
                                <div style={{ height: totalH, width: 60 + colOrder.length * CONFIG.COL_WIDTH, position: 'relative' }}>
                                    <div className="header-row" style={{ width: '100%', minWidth: 'max-content' }}>
                                        {/* Flip Button (Icon) */}
                                        <div
                                            className="header-cell sticky left-0 z-[60] w-[60px] bg-slate-800 border-r border-slate-600 text-slate-400 cursor-pointer hover:bg-slate-700 hover:text-emerald-400 transition-colors flex justify-center items-center"
                                            onClick={handleFlip}
                                            title="å·¦å³ç¿»è½¬å¸ƒå±€ (Flip Horizontal)"
                                        >
                                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                                            </svg>
                                        </div>
                                        {colOrder.map((id, index) => (
                                            <div
                                                key={id}
                                                className={`header-cell ${draggedCol === index ? 'opacity-50 dashed-border' : ''} cursor-move hover:bg-slate-700 transition-colors select-none`}
                                                style={{ width: CONFIG.COL_WIDTH }}
                                                title={data.names[id] || id}
                                                draggable
                                                onDragStart={(e) => handleDragStart(e, index)}
                                                onDragOver={(e) => handleDragOver(e, index)}
                                                onDrop={(e) => handleDrop(e, index)}
                                            >
                                                {data.names[id] || id}
                                            </div>
                                        ))}
                                    </div>
                                    {visibleYears.map(year => (
                                        <div key={year} className="data-row" style={{ top: (year - CONFIG.MIN_YEAR) * CONFIG.ROW_HEIGHT + 36, height: CONFIG.ROW_HEIGHT }}>
                                            <div className="year-col-container flex items-center justify-center h-full">
                                                <div className="font-mono text-[10px] text-slate-500">{year}</div>
                                            </div>
                                            {colOrder.map(id => {
                                                const regimes = cellLayout[id]?.[year] || [];
                                                return (
                                                    <div key={id} className="data-cell" style={{ width: CONFIG.COL_WIDTH }}>
                                                        {regimes.map(r => (
                                                            <div key={r} className="regime-block"
                                                                style={{ backgroundColor: calcColor(r.split('|')[1] || data.codes[r.split('|')[0]] || r) }}
                                                                title={r}>
                                                                {r.split('|')[0]}
                                                            </div>
                                                        ))}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ) : (
                            <div className="flex-1 flex flex-col items-center justify-center text-slate-600 bg-slate-950">
                                <p className="text-sm font-medium">è¯·å¯¼å…¥ CSV æ•°æ®æ–‡ä»¶ / JSON æ¨¡å…·</p>
                            </div>
                        )}
                    </div>

                    <div className="h-32 bg-slate-950 border-t border-slate-800 flex flex-col font-mono text-[10px] shadow-inner-lg z-50">
                        <div className="px-4 py-1 bg-slate-900 border-b border-slate-800 text-slate-500 flex justify-between">
                            <span>CONSOLE LOG</span>
                            <span className={status === 'ranking' || status === 'layout' ? 'text-blue-400 animate-pulse' : 'text-emerald-500'}>
                                {status === 'idle' ? 'IDLE' : status.toUpperCase()}
                            </span>
                        </div>
                        <div className="flex-1 overflow-y-auto p-2 space-y-1 text-slate-400">
                            {logs.map((l, i) => (
                                <div key={i} ref={i === logs.length - 1 ? logEndRef : null}>{l}</div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>